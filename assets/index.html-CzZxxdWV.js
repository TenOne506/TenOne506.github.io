import{_ as a,c as n,e as t,o as e}from"./app-BChvZF5M.js";const l={};function p(i,s){return e(),n("div",null,[...s[0]||(s[0]=[t(`<h3 id="词典的搜索结构" tabindex="-1"><a class="header-anchor" href="#词典的搜索结构"><span>词典的搜索结构</span></a></h3><p>主要有两种，哈希表和搜索树 哈希（Hashing）和搜索树（Search trees）在字典查找中的应用及其优缺点：</p><ul><li>哈希： <ul><li>在一些搜索引擎中用于字典查找。将词汇项（键）哈希到一个足够大的整数空间，使哈希冲突不太可能发生；若发生冲突则通过辅助结构解决。</li><li>查询时，对每个查询词分别哈希并跟随指针到相应文档列表，需处理哈希冲突逻辑。</li><li>存在问题：难以找到查询词的细微变体（如重音和非重音版本），无法执行前缀查找（如查找以“automat”开头的所有词）；在词汇量不断增长的场景（如网络）中，为当前需求设计的哈希函数可能几年后就不够用。</li></ul></li><li>搜索树： <ul><li>克服了哈希的许多问题，例如可以枚举所有以特定前缀开头的词汇项。</li><li>最著名的搜索树是二叉树，每个内部节点有两个子节点。搜索从根节点开始，每个内部节点进行一个二分测试，根据测试结果向该节点下方的两个子树之一继续搜索。</li><li>高效搜索（比较次数为 O(logM)）的关键在于树保持平衡，即任何节点下的两个子树的术语数量要么相等，要么相差 1。主要问题是重新平衡，当向二叉搜索树中插入或删除术语时，需要重新平衡以保持平衡特性。</li></ul></li></ul><p>常用于字典的搜索树是 B 树​ —— 一种搜索树，其中每个内部节点的子节点数量落在区间 [a,b]内，a与 b为合适的正整数。</p><hr><h3 id="模糊搜索" tabindex="-1"><a class="header-anchor" href="#模糊搜索"><span>模糊搜索</span></a></h3><p>在模糊搜索中，*通配符的位置决定了我们的检索策略。</p><ol><li>后缀与前导通配符查询 <ul><li>后缀通配符查询（如 mon*） *只在字符串末尾出现时，可以直接利用搜索树处理：从根节点依次沿 m → o → n遍历，就能枚举出字典中所有以 mon为前缀的词项集合 W，再通过标准倒排索引批量检索包含这些词项的文档。</li><li>前导通配符查询（如 *mon） 当 *出现在开头，正向搜索不再适用。我们可以构建反向 B 树：把词项反向书写（例如 lemon变成 n o m e l），树的路径就对应反向词。这样，从根节点沿 n → o → m向下走，就能枚举出所有以 mon为后缀的词项集合 R。</li></ul></li><li>处理中间带 *的通配符查询 更进一步，结合普通 B 树（regular B-tree）与反向 B 树（reverse B-tree），我们还能处理只含单个 * 的更一般情况，例如 se*mon。思路如下： <ol><li>前缀匹配：用普通 B 树找出所有以 se为前缀的词项集合 W。</li><li>后缀匹配：用反向 B 树找出所有以 mon为后缀的词项集合 R。</li><li>交集筛选：取 W ∩ R，得到既以 se开头又以 mon结尾的词项。</li><li>文档检索：利用标准倒排索引检索包含这些词项的文档。 只需两棵 B 树——普通与反向——就能灵活应对单星号通配符的各种位置，显著提升搜索的表达能力。</li></ol></li></ol><hr><h4 id="通用模糊查询" tabindex="-1"><a class="header-anchor" href="#通用模糊查询"><span>通用模糊查询</span></a></h4><p>我们现在研究两种用于处理一般通配符查询的技术。这两种技术共享一个通用策略：​ 把给定的通配符查询 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">q_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示为一个在特殊构造的索引上进行的布尔查询 Q，使得 Q的答案集合是匹配 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">q_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的词项集合的一个超集。然后，我们将 Q的每个答案词项与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">q_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 逐一比对，剔除那些不匹配 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">q_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的词项。此时我们就得到了真正匹配 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">q_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的词项集合，并可转而使用标准倒排索引来检索文档。</p><p>好的，我会把<strong>置换词索引（Permuterm Index）<strong>和</strong>k-gram 索引</strong>的核心原理、流程、优缺点以及一个简单示例，整理成<strong>适合博客发布的总结</strong>，并与前面的搜索树通配符处理方法形成体系化讲解。</p><hr><h5 id="置换词索引-permuterm-index" tabindex="-1"><a class="header-anchor" href="#置换词索引-permuterm-index"><span>置换词索引（Permuterm Index）</span></a></h5><p>核心思想</p><ul><li>为每个词项末尾添加一个特殊标记 <code>$</code>（表示词结束），例如 <code>hello</code> → <code>hello$</code>。</li><li>对该字符串做<strong>所有可能的循环移位（rotations）</strong>，每个移位都指向原始词项。</li><li>这样，无论 <code>*</code> 出现在词的开头、中间还是结尾，都可以通过<strong>旋转查询</strong>把它变成 “<code>*</code> 在末尾” 的形式，再用搜索树做前缀匹配。</li></ul><p><strong>示例</strong><br> 词项：<code>hello</code> → <code>hello$</code><br> 循环移位集合：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#24292eff;--shiki-dark:#eef0f9;--shiki-light-bg:#ffffff;--shiki-dark-bg:#17191e;"><pre class="shiki shiki-themes min-light houston vp-code"><code class="language-"><span class="line"><span>hello$</span></span>
<span class="line"><span>ello$h</span></span>
<span class="line"><span>llo$he</span></span>
<span class="line"><span>lo$hel</span></span>
<span class="line"><span>o$hell</span></span>
<span class="line"><span>$hello</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些移位在索引中都指向 <code>hello</code>。</p><p><strong>查询示例</strong></p><ul><li>查询 <code>m*n</code> → 旋转成 <code>n$m*</code> → 在索引中查找得到 <code>man</code>、<code>moron</code> 等。</li><li>查询 <code>fi*mo*er</code> → 旋转成 <code>er$fi*</code> → 找到候选词后逐一检查是否包含 <code>mo</code>，过滤掉 <code>filibuster</code>，保留 <code>fishmonger</code>。</li></ul><p>优点</p><ul><li>能处理任意位置的单个 <code>*</code> 通配符查询。</li></ul><p>缺点</p><ul><li>索引体积大：每个词要存所有循环移位，英语词典空间可能增加近 <strong>10 倍</strong>。</li></ul><hr><h5 id="k-gram-索引" tabindex="-1"><a class="header-anchor" href="#k-gram-索引"><span>k-gram 索引</span></a></h5><p>核心思想</p><ul><li><strong>k-gram</strong> 是长度为 k 的字符序列，例如 3-gram 就是连续的 3 个字符。</li><li>为词项生成所有 k-gram（并在首尾加 <code>$</code> 标记边界），建立从 k-gram 到包含它的词项的倒排列表。</li><li>查询时把通配符拆成多个 k-gram，用布尔查询（AND）在 k-gram 索引中找候选词，再做<strong>后过滤</strong>剔除不符合原查询的词。</li></ul><p><strong>示例</strong><br> 词项：<code>castle</code><br> 3-gram 集合：<code>$ca</code>, <code>cas</code>, <code>ast</code>, <code>stl</code>, <code>tle</code>, <code>le$</code><br> 在索引中，<code>cas</code> → <code>castle</code>、<code>case</code> 等词。</p><p><strong>查询示例</strong></p><ul><li>查询 <code>re*ve</code> → 转成布尔查询 <code>$re AND ve$</code> → 在 3-gram 索引中找到 <code>relive</code>、<code>remove</code>、<code>retrieve</code>。</li><li>查询 <code>red*</code> → 布尔查询 <code>$re AND red</code> → 可能匹配到 <code>retired</code>（含两个 3-gram 但不满足 <code>red*</code>），需要<strong>后过滤</strong>去掉它。</li></ul><p><strong>优点</strong></p><ul><li>支持任意位置通配符，不必生成大量循环移位，空间相对可控。</li></ul><p><strong>缺点</strong></p><ul><li>需要额外的后过滤步骤，查询处理更复杂；布尔组合的通配符查询会增加计算量。</li></ul><hr><h5 id="小结对比" tabindex="-1"><a class="header-anchor" href="#小结对比"><span>小结对比</span></a></h5><table><thead><tr><th>方法</th><th>原理</th><th>适用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>搜索树（普通/反向 B 树）</strong></td><td>前缀/后缀匹配 + 集合交集</td><td>单 <code>*</code> 在开头、中间、结尾</td><td>实现直观，速度快</td><td>只能处理单 <code>*</code> 且需两棵树配合</td></tr><tr><td><strong>置换词索引</strong></td><td>循环移位 + 前缀匹配</td><td>单 <code>*</code> 任意位置</td><td>支持任意位置通配符</td><td>索引体积大（约 10 倍）</td></tr><tr><td><strong>k-gram 索引</strong></td><td>k-gram 倒排 + 布尔 AND + 后过滤</td><td>单/多 <code>*</code> 任意位置</td><td>空间较置换词小，灵活</td><td>需后过滤，查询步骤多</td></tr></tbody></table><hr><h3 id="拼写纠错" tabindex="-1"><a class="header-anchor" href="#拼写纠错"><span>拼写纠错</span></a></h3><h4 id="_1-k‐gram-索引用于拼写纠正" tabindex="-1"><a class="header-anchor" href="#_1-k‐gram-索引用于拼写纠正"><span>1. k‑gram 索引用于拼写纠正</span></a></h4><p>为进一步缩小需要计算编辑距离的词汇范围，可以借助 <strong>k‑gram 索引</strong>（第 3.2.2 节）快速检索与查询词 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 编辑距离较低的候选词。</p><ul><li><p><strong>基本思想</strong><br> 检索与查询词共享 <strong>许多公共 k‑gram</strong> 的词汇项。<br> 对“许多公共 k‑gram”给出合理定义后，检索过程相当于对查询串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 的所有 k‑gram 的倒排列表做一次线性扫描。</p></li><li><p><strong>示例（2‑gram / bigram）</strong><br> 图 3.7 展示查询 <code>bord</code> 的三个 bigram 的部分倒排记录：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#24292eff;--shiki-dark:#eef0f9;--shiki-light-bg:#ffffff;--shiki-dark-bg:#17191e;"><pre class="shiki shiki-themes min-light houston vp-code"><code class="language-"><span class="line"><span>[bo] → aboard → about → boardroom → border</span></span>
<span class="line"><span>[or] → border → lord → morbid → sordid</span></span>
<span class="line"><span>[rd] → aboard → ardent → boardroom → border</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>若要求候选词至少包含其中 <strong>两个</strong> bigram，一次扫描倒排表即可枚举出 <code>aboard</code>、<code>boardroom</code>、<code>border</code> 等词。</p></li><li><p><strong>初步方法的缺陷</strong><br> 仅要求匹配固定数量的 k‑gram 会引入不合理候选，例如 <code>boardroom</code> 明显不是 <code>bord</code> 的合理拼写纠正。</p></li></ul><hr><h4 id="_2-基于-jaccard-系数的-k‐gram-重叠度量" tabindex="-1"><a class="header-anchor" href="#_2-基于-jaccard-系数的-k‐gram-重叠度量"><span>2. 基于 Jaccard 系数的 k‑gram 重叠度量</span></a></h4><p>为了在枚举阶段过滤掉不相关词，需要更精细的 <strong>重叠度量方法</strong>。</p><ul><li><p><strong>Jaccard 系数定义</strong><br> 给定两个集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>J</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∣</mi><mi>A</mi><mo>∩</mo><mi>B</mi><mi mathvariant="normal">∣</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>A</mi><mo>∪</mo><mi>B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">J(A,B) = \\frac{|A \\cap B|}{|A \\cup B|} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>这里 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> = 查询 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 的 k‑gram 集合，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> = 某词汇项 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 的 k‑gram 集合。</p></li><li><p><strong>线性扫描适配</strong><br> 扫描倒排列表时，对每个词汇项 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 实时计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">J(q, t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>，若超过预设阈值则保留，否则跳过。</p></li><li><p><strong>关键优化</strong><br> 计算 Jaccard 并不需要完整的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 的 k‑gram 列表，只需：</p><ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 的 k‑gram 集合（扫描时已知）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 的 k‑gram 总数（可预计算并存储在倒排项中）<br> 例：<code>q = bord</code> 与 <code>t = bordroom</code> 匹配 2 个 bigram，<code>bord</code> 有 3 个 bigram，<code>bordroom</code> 有 8 个 bigram：</li></ol><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>J</mi><mo>=</mo><mfrac><mn>2</mn><mrow><mn>8</mn><mo>+</mo><mn>3</mn><mo>−</mo><mn>2</mn></mrow></mfrac><mo>=</mo><mfrac><mn>2</mn><mn>9</mn></mfrac></mrow><annotation encoding="application/x-tex"> J = \\frac{2}{8 + 3 - 2} = \\frac{2}{9} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0908em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">9</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></li><li><p><strong>可替换度量</strong><br> 除 Jaccard 外，也可采用其他支持倒排扫描时高效计算的重叠度量。</p></li></ul><hr><h4 id="_3-拼写纠错的实用流程" tabindex="-1"><a class="header-anchor" href="#_3-拼写纠错的实用流程"><span>3. 拼写纠错的实用流程</span></a></h4><p>有实证支持的三步法：</p><ol><li><strong>候选生成</strong><br> 利用 <strong>k‑gram 索引</strong> 枚举一组可能是查询词 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 潜在纠正项的词汇项集合。</li><li><strong>编辑距离计算</strong><br> 计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 与候选集中每个词的编辑距离（Levenshtein 距离）。</li><li><strong>最佳纠正选取</strong><br> 从候选集中挑选与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> 编辑距离最小的词作为最终纠正结果。</li></ol><hr><h3 id="语音纠错" tabindex="-1"><a class="header-anchor" href="#语音纠错"><span>语音纠错</span></a></h3><p>在容错检索（tolerant retrieval）的众多方法中，<strong>Phonetic correction</strong>（语音纠错）专门用于处理因发音相近而产生的拼写错误。它的应用场景尤其集中在人名搜索——很多时候用户输入的查询在读音上与目标词一致，只是拼写不同。</p><p>核心思路是为每个词生成一个 <strong>phonetic hash</strong>（语音哈希），让发音相似的词映射到同一个哈希值。这一思想最早来自 20 世纪初国际警察部门的需求——他们需要在不同国家拼写各异的通缉犯姓名之间建立匹配。因此，该方法更多用于纠正专有名词（proper nouns）里的语音拼写错误。</p><p>实现语音哈希的算法通常被统称为 <strong>Soundex algorithms</strong>（Soundex 算法）。最初的 Soundex 算法存在多个变体，基本构建方案如下：</p><ol><li>将每个待索引的词转换为 4 字符简化形式，并基于这些简化形式建立倒排索引（，称为 <strong>soundex index</strong>。</li><li>对查询词执行同样的转换。</li><li>当查询需要Soundex 匹配时，就在 soundex index 中进行搜索。</li></ol><p>不同 Soundex 算法的差异主要体现在“词 → 4 字符形式”的转换规则上。常见的一种转换结果是4 字符代码：首字符为字母，后三位为 0–9 的数字。</p><hr><h4 id="soundex-算法步骤与示例" tabindex="-1"><a class="header-anchor" href="#soundex-算法步骤与示例"><span>Soundex 算法步骤与示例</span></a></h4><p>Soundex 算法的具体流程可以拆解为以下步骤：</p><ol><li>保留术语的首字母。</li><li>将以下字母全部替换为 ‘0’：<br><code>A, E, I, O, U, H, W, Y</code></li><li>按以下映射将字母转为数字： <ul><li><code>B, F, P, V → 1 </code></li><li><code>C, G, J, K, Q, S, X, Z → 2 </code></li><li><code>D, T → 3 </code></li><li><code>L → 4 </code></li><li><code>M, N → 5 </code></li><li><code>R → 6 </code></li></ul></li><li>反复删除连续相同数字对中的一个。</li><li>去掉结果字符串中的所有 0，尾部补零至四位长度，返回前四位——即一个字母加三位数字。</li></ol><p><strong>举例</strong>：</p><ul><li>Hermann → H655<br> 当输入查询（例如 herman）时，先计算其 Soundex 代码，再从 <strong>soundex index</strong> 中检索所有与该代码匹配的词汇项，然后在标准的 <strong>inverted index</strong>（倒排索引）上执行最终查询。</li></ul><hr><h4 id="算法背后的观察与局限" tabindex="-1"><a class="header-anchor" href="#算法背后的观察与局限"><span>算法背后的观察与局限</span></a></h4><p>Soundex 的设计基于两个关键观察：</p><ol><li>在转录姓名时，元音被视为可互换。</li><li>发音相似的辅音，会被归入同一等价类，例如 D 和 T。<br> 这让相关姓名常常拥有相同的 Soundex 代码。</li></ol><p>虽然这些规则在很多场景（尤其是欧洲语言）下有效，但它本质上是 依赖书写系统。例如中文姓名的 <strong>Wade-Giles</strong>（威妥玛拼音）与汉语拼音转写：</p><ul><li>Soundex 能部分处理两者的差异，比如将 Wade-Giles 的 <em>hs</em> 与 Pinyin 的 <em>x</em> 都映射为 2。</li><li>但在另一些情况下会失效，比如 Wade-Giles 的 <em>j</em> 与 Pinyin 的 <em>r</em> 会得到不同的映射结果。</li></ul><p>这意味着，跨语言或跨书写系统的语音匹配，仅靠 Soundex 可能无法完全覆盖所有情况，需要结合其他方法或定制规则来提升效果。</p>`,72)])])}const r=a(l,[["render",p]]),o=JSON.parse('{"path":"/searchengine/gbeltx3f/","title":"词典与容错检索","lang":"zh-CN","frontmatter":{"title":"词典与容错检索","createTime":"2026/02/03 15:44:42","permalink":"/searchengine/gbeltx3f/"},"readingTime":{"minutes":10.42,"words":3125},"git":{"createdTime":1770109690000},"filePathRelative":"searchengine/setheory/词典与容错检索.md","headers":[]}');export{r as comp,o as data};
