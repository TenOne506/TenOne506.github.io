const t='{"documentCount":241,"nextId":241,"documentIds":{"0":"/article/vwx36sni/","1":"/article/vwx36sni/#首先从矩阵最朴素的乘法开始写","2":"/article/b4qf25le/","3":"/article/cre8vxts/","4":"/article/vwx36sni/#nvidia-cuda-简单并行化矩阵乘法","5":"/code/","6":"/article/cre8vxts/#标题-2","7":"/article/vwx36sni/#nvidia-cuda-共享内存优化矩阵乘法","8":"/code/#_2024-12-05","9":"/compiler/","10":"/article/cre8vxts/#标题-3","11":"/article/vwx36sni/#nvidia-cuda-共享内存优化矩阵乘法v2","12":"/compiler/#预计记录学习编译器之间的笔记-可能注重的是优化方面的内容。","13":"/demo/","14":"/article/cre8vxts/#标题-4","15":"/demo/g2tvk6f4/","16":"/article/vwx36sni/#nvidia-cuda-共享内存优化矩阵乘法v3","17":"/demo/2mscnzci/","18":"/article/cre8vxts/#标题-5","19":"/article/vwx36sni/#第二重量级的优化-避免bank-conflict","20":"/detail/","21":"/article/cre8vxts/#标题-6","22":"/interview/","23":"/article/vwx36sni/#最具重量级的优化cutlas源码实现","24":"/detail/#记录一下一些问题和八股","25":"/interview/9eed5kmb/","26":"/interview/#暑期","27":"/interview/dmf8vxec/","28":"/interview/gyx9gbc0/","29":"/article/vwx36sni/#cutlass-如何解决-bank-conflicts","30":"/interview/qlzo21lh/","31":"/interview/9eed5kmb/#卓驭-高性能计算实习生-ai引擎","32":"/interview/skeumcj2/","33":"/interview/dmf8vxec/#字节跳动-广告系统架构实习生","34":"/interview/gyx9gbc0/#小米-深度学习训练框架优化工程师","35":"/interview/0lu03eoc/","36":"/article/vwx36sni/#至此先告一段落-期待后续更新优化-2024-12-3","37":"/interview/qlzo21lh/#小红书-深度学习推理-训练引擎实习生","38":"/interview/fjaiilvp/","39":"/interview/0lu03eoc/#一面","40":"/searchengine/","41":"/interview/fjaiilvp/#一面","42":"/searchengine/s4gmkip2/","43":"/interview/0lu03eoc/#二面","44":"/code/jwbbt6n0/","45":"/code/21u1dt6u/","46":"/interview/fjaiilvp/#二面","47":"/searchengine/s4gmkip2/#让计算机理解文本","48":"/code/zzh7de4a/","49":"/interview/0lu03eoc/#总结","50":"/code/jwbbt6n0/#买股票最佳时期ii","51":"/code/007uzhd9/","52":"/code/f5hptujc/","53":"/code/21u1dt6u/#最长递增子序列","54":"/code/m3csyiki/","55":"/code/yen4efmn/","56":"/interview/fjaiilvp/#总结","57":"/searchengine/s4gmkip2/#one-hot编码","58":"/code/zzh7de4a/#零钱兑换","59":"/code/j4h215xq/","60":"/code/re4vdcwm/","61":"/code/gwtromz4/","62":"/code/jwbbt6n0/#_2-买卖股票问题iii","63":"/code/007uzhd9/#徒步旅行中补给问题","64":"/code/f5hptujc/#滑动窗口最大值","65":"/code/m3csyiki/#字母异位组分词","66":"/code/yen4efmn/#最长连续序列","67":"/searchengine/s4gmkip2/#word2vec模型","68":"/code/zzh7de4a/#零钱兑换2","69":"/code/j4h215xq/#全排列","70":"/code/43ijhbod/","71":"/code/rlm1bd5d/","72":"/code/re4vdcwm/#括号生成","73":"/code/gwtromz4/#电话号码的字母组合","74":"/code/jwbbt6n0/#_3-买股票最近时期iii","75":"/searchengine/s4gmkip2/#bert模型","76":"/code/43ijhbod/#组合","77":"/code/dnzgzwfx/","78":"/code/rlm1bd5d/#组合总和","79":"/code/iyjhj0vy/","80":"/code/dnzgzwfx/#删除数组中重复项","81":"/code/k79q49x0/","82":"/code/o7lzvlkj/","83":"/code/cc0i3555/","84":"/code/iyjhj0vy/#合并区间","85":"/code/42s1n4g0/","86":"/code/w9vja2wg/","87":"/code/dnzgzwfx/#删除数组中重复项-1","88":"/code/k79q49x0/#除自身以外数组的乘积","89":"/code/xgswn7ui/","90":"/code/o7lzvlkj/#几乎唯一子数组的最大和","91":"/code/elmrwor8/","92":"/code/9cog373s/","93":"/code/cc0i3555/#得到k个黑块的最少涂色次数","94":"/code/z83lpo7h/","95":"/code/ibyxw9eh/","96":"/compiler/5ln5fsdl/","97":"/compiler/x8vvxq5h/","98":"/compiler/5c3gzmxg/","99":"/code/42s1n4g0/#找到字符串中所有字母的异位词","100":"/code/w9vja2wg/#无重复字符的最长字串","101":"/code/xgswn7ui/#检查所有长度为k的二进制子串","102":"/compiler/nf98rvwp/","103":"/code/elmrwor8/#爱生气的书店老板","104":"/code/9cog373s/#买股票最佳时期i","105":"/compiler/azd9z9j5/","106":"/code/z83lpo7h/#最大子数组和","107":"/code/ibyxw9eh/#跳跃游戏","108":"/compiler/jk8a2ccy/","109":"/compiler/7i6uia7e/","110":"/compiler/5ln5fsdl/#llvm","111":"/compiler/tpgyje22/","112":"/compiler/jk8a2ccy/#nfa","113":"/compiler/7i6uia7e/#nfa到dfa的转换","114":"/compiler/5ln5fsdl/#安装llvm","115":"/compiler/tpgyje22/#hopcroft-s-algorithm","116":"/compiler/rbwmrfsq/","117":"/compiler/8sjic5fc/","118":"/compiler/jk8a2ccy/#nfa的构造","119":"/compiler/dvqjcl8x/","120":"/compiler/li1lwkdo/","121":"/compiler/u251haho/","122":"/compiler/3w60mmfm/","123":"/compiler/tpgyje22/#brzozowski-algorithm","124":"/compiler/rbwmrfsq/#扫描器的实现","125":"/compiler/gpeccshs/","126":"/compiler/fbf7a362/","127":"/compiler/8sjic5fc/#从dfa到正则表达式","128":"/compiler/37x9w7my/","129":"/compiler/2zgr48e8/","130":"/compiler/b108dz3z/","131":"/compiler/li1lwkdo/#上下文无关语法","132":"/compiler/u5vzyifv/","133":"/compiler/2kr9psoo/","134":"/compiler/u251haho/#递归下降的语法分析","135":"/compiler/wnftm2le/","136":"/compiler/r38ss97h/","137":"/compiler/3w60mmfm/#ll-1-语法","138":"/compiler/fnji6gck/","139":"/compiler/ch2f3arv/","140":"/compiler/h2uliq39/","141":"/compiler/tpgyje22/#两者比较","142":"/compiler/gpeccshs/#自底向上解析器","143":"/compiler/0xlscir8/","144":"/compiler/fbf7a362/#lr解析算法","145":"/compiler/37x9w7my/#错误恢复","146":"/compiler/2zgr48e8/#无用产生式示例","147":"/compiler/li1lwkdo/#最左推导和最右推导","148":"/compiler/u5vzyifv/#概念性路线图","149":"/compiler/2kr9psoo/#ir的结构组织","150":"/compiler/u251haho/#消除直接左递归","151":"/compiler/wnftm2le/#图形化的中间表示-graphical-irs","152":"/compiler/r38ss97h/#栈机代码","153":"/compiler/3w60mmfm/#集合","154":"/compiler/fnji6gck/#llvm-ir-示例","155":"/compiler/h2uliq39/#static-single-assignment-form-ssa","156":"/compiler/gpeccshs/#lr-1-语法","157":"/compiler/0xlscir8/#将值保存在寄存器中","158":"/compiler/9q1sjixf/","159":"/compiler/qdwjf35y/","160":"/compiler/ssxqplgy/","161":"/compiler/fbf7a362/#句柄-handle-的概念","162":"/compiler/37x9w7my/#一元运算符","163":"/compiler/2zgr48e8/#减少lr-1-表的大小","164":"/compiler/li1lwkdo/#文法的二义性","165":"/compiler/u5vzyifv/#概述","166":"/compiler/2kr9psoo/#ir的抽象级别","167":"/compiler/u251haho/#消除间接左递归","168":"/compiler/wnftm2le/#解析树","169":"/compiler/r38ss97h/#三地址码","170":"/compiler/3w60mmfm/#集合-1","171":"/compiler/fnji6gck/#静态单赋值形式-static-single-assignment-ssa","172":"/compiler/goegb3y4/","173":"/compiler/ks6u8ih8/","174":"/compiler/gpeccshs/#lr解析样例","175":"/compiler/0xlscir8/#为数据区域分配值","176":"/compiler/9q1sjixf/#解析树、语法树和抽象语法树的对比","177":"/compiler/uh5fqlb5/","178":"/compiler/ssxqplgy/#等价树遍历","179":"/compiler/fbf7a362/#详细计算步骤","180":"/compiler/37x9w7my/#处理上下文相关的歧义","181":"/compiler/2zgr48e8/#使用其他构造方法","182":"/compiler/2kr9psoo/#ir使用模式","183":"/compiler/n4bm9it1/","184":"/compiler/u251haho/#左公共因子","185":"/compiler/wnftm2le/#抽象语法树-abstract-syntax-tree-ast","186":"/compiler/r38ss97h/#表示ir","187":"/compiler/1kzbvj7g/","188":"/compiler/3w60mmfm/#ll-1-分析表的构建","189":"/compiler/fnji6gck/#ssa的特点","190":"/compiler/goegb3y4/#建模词法作用域","191":"/compiler/ks6u8ih8/#复合类型","192":"/compiler/9q1sjixf/#总结","193":"/compiler/uh5fqlb5/#自动变量","194":"/compiler/ssxqplgy/#翻译表达式","195":"/compiler/fbf7a362/#示例-构建括号列表文法的lr-1-解析表","196":"/compiler/37x9w7my/#总结","197":"/compiler/2kr9psoo/#命名空间","198":"/compiler/wnftm2le/#有向无环图-directed-acyclic-graph","199":"/compiler/r38ss97h/#从线性代码构建cfg","200":"/compiler/fnji6gck/#ssa的优势","201":"/compiler/goegb3y4/#建模类的继承结构","202":"/compiler/ks6u8ih8/#数组","203":"/compiler/uh5fqlb5/#静态变量","204":"/compiler/ssxqplgy/#处理非本地计算","205":"/compiler/2kr9psoo/#实际考虑因素","206":"/compiler/wnftm2le/#控制流图","207":"/compiler/r38ss97h/#构建步骤","208":"/compiler/fnji6gck/#ssa的构建","209":"/compiler/ks6u8ih8/#字符串","210":"/compiler/uh5fqlb5/#不规则变量","211":"/compiler/ssxqplgy/#翻译控制流语句","212":"/compiler/wnftm2le/#基本块的长度","213":"/compiler/r38ss97h/#示例","214":"/compiler/fnji6gck/#ssa示例","215":"/compiler/ks6u8ih8/#枚举类型","216":"/compiler/uh5fqlb5/#虚拟内存布局","217":"/compiler/ssxqplgy/#构建抽象语法树-ast","218":"/compiler/wnftm2le/#数据依赖图","219":"/compiler/r38ss97h/#注意事项","220":"/compiler/fnji6gck/#_1-基本算术运算","221":"/compiler/ks6u8ih8/#结构体与聚合","222":"/compiler/uh5fqlb5/#存储分配","223":"/compiler/ssxqplgy/#构建三地址码","224":"/compiler/wnftm2le/#调用图","225":"/compiler/fnji6gck/#_2-函数定义","226":"/compiler/ks6u8ih8/#对象和类","227":"/compiler/uh5fqlb5/#数组存储分配","228":"/compiler/wnftm2le/#回顾总结","229":"/compiler/fnji6gck/#_3-控制流","230":"/compiler/ks6u8ih8/#类型等价","231":"/compiler/uh5fqlb5/#字符串","232":"/compiler/fnji6gck/#_4-内存操作","233":"/compiler/ks6u8ih8/#表达式的类型推断","234":"/compiler/uh5fqlb5/#结构体与对象","235":"/compiler/ks6u8ih8/#章节回顾","236":"/compiler/uh5fqlb5/#对象记录的内存布局-object-records","237":"/compiler/uh5fqlb5/#多重继承的内存布局","238":"/compiler/uh5fqlb5/#将存储布局引入翻译过程","239":"/compiler/uh5fqlb5/#对其与补充-alignment-restrictions-and-padding","240":"/compiler/uh5fqlb5/#章节回顾"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,1],"1":[1,1,50],"2":[1,1,1],"3":[1,1,1],"4":[3,1,104],"5":[1,1,7],"6":[2,1,1],"7":[3,1,126],"8":[3,1,16],"9":[1,1,1],"10":[2,3,1],"11":[3,1,118],"12":[3,1,1],"13":[1,1,3],"14":[2,4,1],"15":[1,1,2],"16":[3,1,136],"17":[1,1,2],"18":[2,5,1],"19":[3,1,94],"20":[1,1,1],"21":[2,6,118],"22":[1,1,40],"23":[1,1,84],"24":[1,1,3],"25":[1,1,1],"26":[1,1,4],"27":[1,1,1],"28":[1,1,1],"29":[4,2,186],"30":[1,1,1],"31":[4,1,4],"32":[1,1,1],"33":[2,1,115],"34":[2,1,5],"35":[1,1,6],"36":[5,1,1],"37":[3,1,60],"38":[1,1,1],"39":[1,1,135],"40":[1,1,3],"41":[1,1,117],"42":[1,1,5],"43":[1,1,127],"44":[1,1,1],"45":[1,1,1],"46":[1,1,136],"47":[1,1,56],"48":[1,1,1],"49":[1,1,18],"50":[1,1,115],"51":[1,1,1],"52":[1,1,1],"53":[1,1,87],"54":[1,1,1],"55":[1,1,1],"56":[1,1,34],"57":[2,1,9],"58":[1,1,113],"59":[1,1,1],"60":[1,1,1],"61":[1,1,1],"62":[2,1,46],"63":[1,1,131],"64":[1,1,62],"65":[1,1,51],"66":[1,1,117],"67":[1,1,251],"68":[1,1,88],"69":[1,1,60],"70":[1,1,1],"71":[1,1,1],"72":[1,1,60],"73":[1,1,82],"74":[2,1,33],"75":[1,1,231],"76":[1,1,30],"77":[1,1,1],"78":[1,1,41],"79":[1,1,1],"80":[1,1,47],"81":[1,1,1],"82":[1,1,1],"83":[1,1,1],"84":[1,1,69],"85":[1,1,1],"86":[1,1,1],"87":[1,1,80],"88":[1,1,86],"89":[1,1,1],"90":[1,1,97],"91":[1,1,1],"92":[1,1,1],"93":[1,1,88],"94":[1,1,1],"95":[1,1,1],"96":[1,1,1],"97":[1,1,10],"98":[3,1,13],"99":[1,1,67],"100":[1,1,64],"101":[1,1,70],"102":[1,1,119],"103":[1,1,96],"104":[1,1,73],"105":[1,1,68],"106":[1,1,132],"107":[1,1,71],"108":[1,1,1],"109":[1,1,1],"110":[1,1,37],"111":[1,1,1],"112":[1,1,61],"113":[1,1,121],"114":[1,1,103],"115":[3,1,116],"116":[1,1,1],"117":[1,1,1],"118":[1,1,28],"119":[1,1,12],"120":[1,1,1],"121":[3,1,19],"122":[3,1,6],"123":[2,1,55],"124":[1,1,22],"125":[3,1,6],"126":[3,1,1],"127":[1,1,117],"128":[1,1,2],"129":[1,1,74],"130":[1,1,54],"131":[1,1,90],"132":[1,1,30],"133":[1,1,1],"134":[1,3,32],"135":[1,1,1],"136":[1,1,49],"137":[3,3,26],"138":[2,1,1],"139":[1,1,164],"140":[1,1,21],"141":[1,1,34],"142":[1,3,49],"143":[1,1,85],"144":[1,3,28],"145":[1,1,59],"146":[1,1,42],"147":[1,1,35],"148":[1,1,23],"149":[1,1,27],"150":[1,3,112],"151":[4,1,14],"152":[1,1,42],"153":[1,4,71],"154":[3,2,17],"155":[6,1,199],"156":[3,3,27],"157":[1,1,45],"158":[1,1,14],"159":[1,1,52],"160":[1,1,31],"161":[3,3,23],"162":[1,1,63],"163":[3,1,94],"164":[1,1,78],"165":[1,1,19],"166":[1,1,39],"167":[1,3,78],"168":[1,5,25],"169":[1,1,62],"170":[1,4,36],"171":[6,2,10],"172":[1,1,50],"173":[1,1,49],"174":[1,3,24],"175":[1,1,83],"176":[2,1,68],"177":[1,1,22],"178":[1,1,35],"179":[1,3,68],"180":[1,1,63],"181":[1,1,47],"182":[1,1,22],"183":[1,1,184],"184":[1,3,61],"185":[6,5,13],"186":[1,1,27],"187":[1,1,266],"188":[3,3,84],"189":[1,8,5],"190":[1,1,30],"191":[1,1,26],"192":[1,1,21],"193":[1,1,44],"194":[1,1,57],"195":[4,3,80],"196":[1,1,10],"197":[1,1,40],"198":[5,5,63],"199":[1,1,6],"200":[1,8,10],"201":[1,1,143],"202":[1,2,18],"203":[1,1,40],"204":[1,1,67],"205":[1,1,16],"206":[1,5,112],"207":[1,2,27],"208":[1,8,8],"209":[1,2,20],"210":[1,1,28],"211":[1,1,1],"212":[1,5,37],"213":[1,2,21],"214":[1,8,20],"215":[1,2,38],"216":[1,1,13],"217":[3,2,19],"218":[1,5,39],"219":[1,2,6],"220":[2,8,16],"221":[1,2,41],"222":[1,1,1],"223":[1,2,20],"224":[1,5,42],"225":[2,8,10],"226":[1,2,7],"227":[1,2,2],"228":[1,5,12],"229":[2,8,38],"230":[1,2,29],"231":[1,2,22],"232":[2,8,26],"233":[1,1,56],"234":[1,2,15],"235":[1,1,12],"236":[4,2,72],"237":[1,2,9],"238":[1,1,31],"239":[6,2,26],"240":[1,1,10]},"averageFieldLength":[1.4232365145228212,1.639004149377593,42.85892116182571],"storedFields":{"0":{"title":"矩阵乘法从0开始优化到cutlas","titles":[]},"1":{"title":"首先从矩阵最朴素的乘法开始写","titles":["矩阵乘法从0开始优化到cutlas"]},"2":{"title":"自定义组件","titles":[]},"3":{"title":"Markdown","titles":[]},"4":{"title":"Nvidia CUDA 简单并行化矩阵乘法","titles":["矩阵乘法从0开始优化到cutlas"]},"5":{"title":"前言","titles":[]},"6":{"title":"标题 2","titles":["Markdown"]},"7":{"title":"Nvidia CUDA 共享内存优化矩阵乘法","titles":["矩阵乘法从0开始优化到cutlas"]},"8":{"title":"2024/12/05","titles":["前言"]},"9":{"title":"前言","titles":[]},"10":{"title":"标题 3","titles":["Markdown","标题 2"]},"11":{"title":"Nvidia CUDA 共享内存优化矩阵乘法V2","titles":["矩阵乘法从0开始优化到cutlas"]},"12":{"title":"预计记录学习编译器之间的笔记，可能注重的是优化方面的内容。","titles":["前言"]},"13":{"title":"Demo","titles":[]},"14":{"title":"标题 4","titles":["Markdown","标题 2","标题 3"]},"15":{"title":"bar","titles":[]},"16":{"title":"Nvidia CUDA 共享内存优化矩阵乘法V3","titles":["矩阵乘法从0开始优化到cutlas"]},"17":{"title":"foo","titles":[]},"18":{"title":"标题 5","titles":["Markdown","标题 2","标题 3","标题 4"]},"19":{"title":"第二重量级的优化,避免bank conflict","titles":["矩阵乘法从0开始优化到cutlas"]},"20":{"title":"detail","titles":[]},"21":{"title":"标题 6","titles":["Markdown","标题 2","标题 3","标题 4","标题 5"]},"22":{"title":"前言","titles":[]},"23":{"title":"最具重量级的优化Cutlas源码实现","titles":["矩阵乘法从0开始优化到cutlas"]},"24":{"title":"记录一下一些问题和八股","titles":["detail"]},"25":{"title":"卓驭高性能计算","titles":[]},"26":{"title":"暑期","titles":["前言"]},"27":{"title":"字节广告系统架构","titles":[]},"28":{"title":"小米训练框架优化","titles":[]},"29":{"title":"Cutlass 如何解决 bank conflicts","titles":["矩阵乘法从0开始优化到cutlas","最具重量级的优化Cutlas源码实现"]},"30":{"title":"小红书训练推理引擎","titles":[]},"31":{"title":"卓驭：高性能计算实习生(AI引擎)","titles":["卓驭高性能计算"]},"32":{"title":"百度","titles":[]},"33":{"title":"字节跳动：广告系统架构实习生","titles":["字节广告系统架构"]},"34":{"title":"小米：深度学习训练框架优化工程师","titles":["小米训练框架优化"]},"35":{"title":"腾讯云基础架构部门","titles":[]},"36":{"title":"至此先告一段落,期待后续更新优化 2024.12.3","titles":["矩阵乘法从0开始优化到cutlas"]},"37":{"title":"小红书：深度学习推理/训练引擎实习生","titles":["小红书训练推理引擎"]},"38":{"title":"腾讯机器学习平台部","titles":[]},"39":{"title":"一面","titles":["腾讯云基础架构部门"]},"40":{"title":"搜索引擎","titles":[]},"41":{"title":"一面","titles":["腾讯机器学习平台部"]},"42":{"title":"向量化","titles":[]},"43":{"title":"二面","titles":["腾讯云基础架构部门"]},"44":{"title":"买股票动态规划问题","titles":[]},"45":{"title":"最长递增子序列","titles":[]},"46":{"title":"二面","titles":["腾讯机器学习平台部"]},"47":{"title":"让计算机理解文本","titles":["向量化"]},"48":{"title":"零钱兑换","titles":[]},"49":{"title":"总结","titles":["腾讯云基础架构部门"]},"50":{"title":"买股票最佳时期Ⅱ","titles":["买股票动态规划问题"]},"51":{"title":"徒步旅行中补给问题","titles":[]},"52":{"title":"滑动窗口最大值","titles":[]},"53":{"title":"最长递增子序列","titles":["最长递增子序列"]},"54":{"title":"字母异位组分词","titles":[]},"55":{"title":"最长连续序列","titles":[]},"56":{"title":"总结","titles":["腾讯机器学习平台部"]},"57":{"title":"One-Hot编码","titles":["向量化"]},"58":{"title":"零钱兑换","titles":["零钱兑换"]},"59":{"title":"全排列","titles":[]},"60":{"title":"括号生成","titles":[]},"61":{"title":"电话号码字母组合","titles":[]},"62":{"title":"2.买卖股票问题Ⅲ","titles":["买股票动态规划问题"]},"63":{"title":"徒步旅行中补给问题","titles":["徒步旅行中补给问题"]},"64":{"title":"滑动窗口最大值","titles":["滑动窗口最大值"]},"65":{"title":"字母异位组分词","titles":["字母异位组分词"]},"66":{"title":"最长连续序列","titles":["最长连续序列"]},"67":{"title":"Word2Vec模型","titles":["向量化"]},"68":{"title":"零钱兑换2","titles":["零钱兑换"]},"69":{"title":"全排列","titles":["全排列"]},"70":{"title":"组合","titles":[]},"71":{"title":"组合总和","titles":[]},"72":{"title":"括号生成","titles":["括号生成"]},"73":{"title":"电话号码的字母组合","titles":["电话号码字母组合"]},"74":{"title":"3.买股票最近时期Ⅲ","titles":["买股票动态规划问题"]},"75":{"title":"Bert模型","titles":["向量化"]},"76":{"title":"组合","titles":["组合"]},"77":{"title":"删除数组中重复项","titles":[]},"78":{"title":"组合总和","titles":["组合总和"]},"79":{"title":"合并区间","titles":[]},"80":{"title":"删除数组中重复项","titles":["删除数组中重复项"]},"81":{"title":"除自身以外数组的乘积","titles":[]},"82":{"title":"几乎唯一子数组的最大和","titles":[]},"83":{"title":"得到K个黑块的最少涂色次数","titles":[]},"84":{"title":"合并区间","titles":["合并区间"]},"85":{"title":"找到字符串中所有字母的异位词","titles":[]},"86":{"title":"无重复字符的最长字串","titles":[]},"87":{"title":"删除数组中重复项","titles":["删除数组中重复项"]},"88":{"title":"除自身以外数组的乘积","titles":["除自身以外数组的乘积"]},"89":{"title":"检查所有长度为K的二进制子串","titles":[]},"90":{"title":"几乎唯一子数组的最大和","titles":["几乎唯一子数组的最大和"]},"91":{"title":"爱生气的书店老板","titles":[]},"92":{"title":"买股票最近时期Ⅰ","titles":[]},"93":{"title":"得到K个黑块的最少涂色次数","titles":["得到K个黑块的最少涂色次数"]},"94":{"title":"最大子数组和","titles":[]},"95":{"title":"跳跃游戏","titles":[]},"96":{"title":"LLVM简介","titles":[]},"97":{"title":"EaC","titles":[]},"98":{"title":"intro to compiler","titles":[]},"99":{"title":"找到字符串中所有字母的异位词","titles":["找到字符串中所有字母的异位词"]},"100":{"title":"无重复字符的最长字串","titles":["无重复字符的最长字串"]},"101":{"title":"检查所有长度为K的二进制子串","titles":["检查所有长度为K的二进制子串"]},"102":{"title":"有限自动机","titles":[]},"103":{"title":"爱生气的书店老板","titles":["爱生气的书店老板"]},"104":{"title":"买股票最佳时期I","titles":["买股票最近时期Ⅰ"]},"105":{"title":"正则表达式","titles":[]},"106":{"title":"最大子数组和","titles":["最大子数组和"]},"107":{"title":"跳跃游戏","titles":["跳跃游戏"]},"108":{"title":"RE到NFA","titles":[]},"109":{"title":"NFA到DFA的转换","titles":[]},"110":{"title":"LLVM","titles":["LLVM简介"]},"111":{"title":"NFA的最小化","titles":[]},"112":{"title":"NFA","titles":["RE到NFA"]},"113":{"title":"NFA到DFA的转换","titles":["NFA到DFA的转换"]},"114":{"title":"安装LLVM","titles":["LLVM简介"]},"115":{"title":"Hopcroft’s algorithm","titles":["NFA的最小化"]},"116":{"title":"扫描器的实现","titles":[]},"117":{"title":"DFA到RE","titles":[]},"118":{"title":"NFA的构造","titles":["RE到NFA"]},"119":{"title":"练习题答案","titles":[]},"120":{"title":"上下文无关语法","titles":[]},"121":{"title":"自顶向下解析器与LL(1)语法","titles":[]},"122":{"title":"非递归LL(1)语法","titles":[]},"123":{"title":"Brzozowski algorithm","titles":["NFA的最小化"]},"124":{"title":"扫描器的实现","titles":["扫描器的实现"]},"125":{"title":"自底向上解析器与LR(1)语法","titles":[]},"126":{"title":"构造LR(1)解析表","titles":[]},"127":{"title":"从DFA到正则表达式","titles":["DFA到RE"]},"128":{"title":"实用主题","titles":[]},"129":{"title":"高级主题","titles":[]},"130":{"title":"总结","titles":[]},"131":{"title":"上下文无关语法","titles":["上下文无关语法"]},"132":{"title":"概述","titles":[]},"133":{"title":"IR分类","titles":[]},"134":{"title":"递归下降的语法分析","titles":["自顶向下解析器与LL(1)语法"]},"135":{"title":"图IR","titles":[]},"136":{"title":"线性IR","titles":[]},"137":{"title":"LL(1)语法","titles":["非递归LL(1)语法"]},"138":{"title":"LLVM IR示例","titles":[]},"139":{"title":"符号表","titles":[]},"140":{"title":"命名空间","titles":[]},"141":{"title":"两者比较","titles":["NFA的最小化"]},"142":{"title":"自底向上解析器","titles":["自底向上解析器与LR(1)语法"]},"143":{"title":"内存中值的放置","titles":[]},"144":{"title":"LR解析算法","titles":["构造LR(1)解析表"]},"145":{"title":"错误恢复","titles":["实用主题"]},"146":{"title":"无用产生式示例","titles":["高级主题"]},"147":{"title":"最左推导和最右推导","titles":["上下文无关语法"]},"148":{"title":"概念性路线图","titles":["概述"]},"149":{"title":"IR的结构组织","titles":["IR分类"]},"150":{"title":"消除直接左递归","titles":["自顶向下解析器与LL(1)语法"]},"151":{"title":"图形化的中间表示（Graphical IRs）","titles":["图IR"]},"152":{"title":"栈机代码","titles":["线性IR"]},"153":{"title":"FIRSTFIRSTFIRST集合","titles":["非递归LL(1)语法","LL(1)语法"]},"154":{"title":"LLVM IR 示例","titles":["LLVM IR示例"]},"155":{"title":"Static single-assignment form(SSA)","titles":["命名空间"]},"156":{"title":"LR(1)语法","titles":["自底向上解析器与LR(1)语法"]},"157":{"title":"将值保存在寄存器中","titles":["内存中值的放置"]},"158":{"title":"各种树之间的区别","titles":[]},"159":{"title":"介绍","titles":[]},"160":{"title":"语法制导翻译","titles":[]},"161":{"title":"句柄（Handle）的概念","titles":["构造LR(1)解析表"]},"162":{"title":"一元运算符","titles":["实用主题"]},"163":{"title":"减少LR(1)表的大小","titles":["高级主题"]},"164":{"title":"文法的二义性","titles":["上下文无关语法"]},"165":{"title":"概述","titles":["概述"]},"166":{"title":"IR的抽象级别","titles":["IR分类"]},"167":{"title":"消除间接左递归","titles":["自顶向下解析器与LL(1)语法"]},"168":{"title":"解析树","titles":["图IR","图形化的中间表示（Graphical IRs）"]},"169":{"title":"三地址码","titles":["线性IR"]},"170":{"title":"FOLLOWFOLLOWFOLLOW集合","titles":["非递归LL(1)语法","LL(1)语法"]},"171":{"title":"静态单赋值形式（Static Single Assignment, SSA）","titles":["LLVM IR示例"]},"172":{"title":"命名环境建模","titles":[]},"173":{"title":"类型信息","titles":[]},"174":{"title":"LR解析样例","titles":["自底向上解析器与LR(1)语法"]},"175":{"title":"为数据区域分配值","titles":["内存中值的放置"]},"176":{"title":"解析树、语法树和抽象语法树的对比","titles":["各种树之间的区别"]},"177":{"title":"内存布局","titles":[]},"178":{"title":"等价树遍历","titles":["语法制导翻译"]},"179":{"title":"详细计算步骤","titles":["构造LR(1)解析表"]},"180":{"title":"处理上下文相关的歧义","titles":["实用主题"]},"181":{"title":"使用其他构造方法","titles":["高级主题"]},"182":{"title":"IR使用模式","titles":["IR分类"]},"183":{"title":"引言介绍","titles":[]},"184":{"title":"左公共因子","titles":["自顶向下解析器与LL(1)语法"]},"185":{"title":"抽象语法树（Abstract Syntax Tree, AST）","titles":["图IR","图形化的中间表示（Graphical IRs）"]},"186":{"title":"表示IR","titles":["线性IR"]},"187":{"title":"运行时命名支持","titles":[]},"188":{"title":"LL(1)分析表的构建","titles":["非递归LL(1)语法"]},"189":{"title":"SSA的特点","titles":["LLVM IR示例","静态单赋值形式（Static Single Assignment, SSA）"]},"190":{"title":"建模词法作用域","titles":["命名环境建模"]},"191":{"title":"复合类型","titles":["类型信息"]},"192":{"title":"总结","titles":["各种树之间的区别"]},"193":{"title":"自动变量","titles":["内存布局"]},"194":{"title":"翻译表达式","titles":["语法制导翻译"]},"195":{"title":"示例：构建括号列表文法的LR(1)解析表","titles":["构造LR(1)解析表"]},"196":{"title":"总结","titles":["实用主题"]},"197":{"title":"命名空间","titles":["IR分类"]},"198":{"title":"有向无环图（Directed Acyclic Graph）","titles":["图IR","图形化的中间表示（Graphical IRs）"]},"199":{"title":"从线性代码构建CFG","titles":["线性IR"]},"200":{"title":"SSA的优势","titles":["LLVM IR示例","静态单赋值形式（Static Single Assignment, SSA）"]},"201":{"title":"建模类的继承结构","titles":["命名环境建模"]},"202":{"title":"数组","titles":["类型信息","复合类型"]},"203":{"title":"静态变量","titles":["内存布局"]},"204":{"title":"处理非本地计算","titles":["语法制导翻译"]},"205":{"title":"实际考虑因素","titles":["IR分类"]},"206":{"title":"控制流图","titles":["图IR","图形化的中间表示（Graphical IRs）"]},"207":{"title":"构建步骤","titles":["线性IR","从线性代码构建CFG"]},"208":{"title":"SSA的构建","titles":["LLVM IR示例","静态单赋值形式（Static Single Assignment, SSA）"]},"209":{"title":"字符串","titles":["类型信息","复合类型"]},"210":{"title":"不规则变量","titles":["内存布局"]},"211":{"title":"翻译控制流语句","titles":["语法制导翻译"]},"212":{"title":"基本块的长度","titles":["图IR","图形化的中间表示（Graphical IRs）"]},"213":{"title":"示例","titles":["线性IR","从线性代码构建CFG"]},"214":{"title":"SSA示例","titles":["LLVM IR示例","静态单赋值形式（Static Single Assignment, SSA）"]},"215":{"title":"枚举类型","titles":["类型信息","复合类型"]},"216":{"title":"虚拟内存布局","titles":["内存布局"]},"217":{"title":"构建抽象语法树（AST）","titles":["语法制导翻译","翻译控制流语句"]},"218":{"title":"数据依赖图","titles":["图IR","图形化的中间表示（Graphical IRs）"]},"219":{"title":"注意事项","titles":["线性IR","从线性代码构建CFG"]},"220":{"title":"1. 基本算术运算","titles":["LLVM IR示例","静态单赋值形式（Static Single Assignment, SSA）"]},"221":{"title":"结构体与聚合","titles":["类型信息","复合类型"]},"222":{"title":"存储分配","titles":["内存布局"]},"223":{"title":"构建三地址码","titles":["语法制导翻译","翻译控制流语句"]},"224":{"title":"调用图","titles":["图IR","图形化的中间表示（Graphical IRs）"]},"225":{"title":"2. 函数定义","titles":["LLVM IR示例","静态单赋值形式（Static Single Assignment, SSA）"]},"226":{"title":"对象和类","titles":["类型信息","复合类型"]},"227":{"title":"数组存储分配","titles":["内存布局","存储分配"]},"228":{"title":"回顾总结","titles":["图IR","图形化的中间表示（Graphical IRs）"]},"229":{"title":"3. 控制流","titles":["LLVM IR示例","静态单赋值形式（Static Single Assignment, SSA）"]},"230":{"title":"类型等价","titles":["类型信息","复合类型"]},"231":{"title":"字符串","titles":["内存布局","存储分配"]},"232":{"title":"4. 内存操作","titles":["LLVM IR示例","静态单赋值形式（Static Single Assignment, SSA）"]},"233":{"title":"表达式的类型推断","titles":["类型信息"]},"234":{"title":"结构体与对象","titles":["内存布局","存储分配"]},"235":{"title":"章节回顾","titles":["类型信息"]},"236":{"title":"对象记录的内存布局(Object Records)","titles":["内存布局","存储分配"]},"237":{"title":"多重继承的内存布局","titles":["内存布局","存储分配"]},"238":{"title":"将存储布局引入翻译过程","titles":["内存布局"]},"239":{"title":"对其与补充(Alignment Restrictions and Padding)","titles":["内存布局","将存储布局引入翻译过程"]},"240":{"title":"章节回顾","titles":["内存布局"]}},"dirtCount":0,"index":[["她可以选择设计编译器尽可能多地在语法驱动阶段完成翻译",{"2":{"238":1}}],["她必须编写代码来实现它",{"2":{"178":1}}],["超类方法的编译代码使用基于该超类的对象记录布局的偏移量",{"2":{"237":1}}],["细节非常重要",{"2":{"236":1}}],["细微差异masked",{"2":{"37":1}}],["章节回顾",{"0":{"235":1,"240":1}}],["强类型系统",{"2":{"232":1}}],["历史上",{"2":{"230":1}}],["模糊调用的运行时解析对于调用图的构建来说是一个严重的问题",{"2":{"224":1}}],["模型特性",{"2":{"67":1}}],["模型架构",{"2":{"67":1,"75":1}}],["模型详解",{"2":{"67":1}}],["模型",{"2":{"67":1}}],["模型压缩",{"2":{"37":1}}],["软件工程实践和语言特性都使调用图的构建变得复杂",{"2":{"224":1}}],["评估控制表达式",{"2":{"223":1}}],["联合体的类型是其组成部分类型的交替",{"2":{"221":1}}],["依赖图中每个操作都有一个节点",{"2":{"218":1}}],["依然保持",{"2":{"155":1}}],["依然可以优化称一次性赋值的虚拟寄存器",{"2":{"155":1}}],["边是从定义指向使用",{"2":{"218":1}}],["边栏中的图显示了对于如下输入的抽象语法树",{"2":{"217":1}}],["边表示可能的控制流转移",{"2":{"206":1}}],["边表示控制流的转移",{"2":{"206":1}}],["z",{"2":{"213":3}}],["zebra",{"2":{"21":1}}],["仅在块边界插入代码",{"2":{"212":1}}],["仅有这两种组合",{"2":{"78":1}}],["懒代码移动",{"2":{"212":1}}],["拥有更多的节点和边",{"2":{"212":1}}],["释放可能是隐式的或显式的",{"2":{"210":1}}],["真正的字符串类型在几个重要方面与数组类型不同",{"2":{"209":1}}],["插入φ函数",{"2":{"208":1}}],["顺序执行",{"2":{"207":1}}],["添加基本块之间的控制流边",{"2":{"207":1}}],["添加边表示控制流转移",{"2":{"206":1}}],["添加项",{"2":{"179":2}}],["测试",{"2":{"206":1}}],["识别死代码",{"2":{"206":1}}],["识别左递归产生式",{"2":{"150":1}}],["理解和维护",{"2":{"204":1}}],["理论上可支持1",{"2":{"47":1}}],["←",{"2":{"204":4}}],["打开新作用域的语句",{"2":{"204":1}}],["打翻",{"2":{"155":1}}],["普通",{"2":{"201":1}}],["路径的具体细节取决于语言",{"2":{"201":1}}],["路径上的第",{"2":{"67":1}}],["默认",{"2":{"201":1}}],["私有成员对子类不可见也不可访问",{"2":{"201":1}}],["私有的",{"2":{"201":1}}],["受保护成员对子类是可见且可访问的",{"2":{"201":1}}],["受保护的",{"2":{"201":1}}],["公有成员对子类也是可见且可访问的",{"2":{"201":1}}],["公共",{"2":{"201":1}}],["带有继承的查找设有一个封闭的类结构",{"2":{"201":1}}],["确定两种类型等价的方法以及推断表达式类型的规则组成",{"2":{"235":1}}],["确定基本块之间的控制流关系",{"2":{"206":1}}],["确定适当的访问方法",{"2":{"201":1}}],["确定性ir是被编译代码的主要表示形式",{"2":{"182":1}}],["确定性ir",{"2":{"182":1}}],["源语言可能包含类似于以下规则集的语法",{"2":{"204":1}}],["源语言中建立继承的语句会使编译器将类作用域链接在一起以形成层次结构",{"2":{"201":1}}],["源代码通常需要一个名称来开始引用或引用链",{"2":{"210":1}}],["源代码语法结构的完整表示",{"2":{"176":1}}],["源代码本身对于这个目的来说是不够的",{"2":{"165":1}}],["清晰的依赖关系有助于识别并行机会",{"2":{"200":1}}],["揭示细微的错误",{"2":{"235":1}}],["揭示冗余",{"2":{"198":1}}],["揭示了初始测试引用的是xo",{"2":{"155":1}}],["好处在于生成更优质的编译代码",{"2":{"198":1}}],["空终止字符串需要一个额外的元素来标记字符串的末尾",{"2":{"231":1}}],["空终止字符串",{"2":{"231":1}}],["空",{"2":{"195":1}}],["空间",{"2":{"155":1}}],["持有指向过程本地数据区的指针",{"2":{"194":1}}],["持有股票这个是不可能的状态定义为负无穷",{"2":{"50":1}}],["向上传递",{"2":{"194":1}}],["向量维度",{"2":{"67":1}}],["向量化",{"0":{"42":1},"1":{"47":1,"57":1,"67":1,"75":1}}],["向量",{"2":{"29":1,"67":2}}],["视为同义词",{"2":{"193":1}}],["激活",{"2":{"193":1}}],["激活记录",{"2":{"193":1}}],["典型的构造类型包括数组",{"2":{"191":1}}],["典型的编译器处理一系列的过程并为它们生成代码",{"2":{"183":1}}],["复杂性主要体现在搜索路径上",{"2":{"201":1}}],["复杂任务",{"2":{"67":1}}],["复合类型让程序员能够以新颖且特定于程序的方式组织信息",{"2":{"191":1}}],["复合类型",{"0":{"191":1},"1":{"202":1,"209":1,"215":1,"221":1,"226":1,"230":1}}],["隐式声明的规则是特定于语言的",{"2":{"190":1}}],["隐藏层到输出层的权重矩阵",{"2":{"67":1}}],["↓",{"2":{"190":1}}],["消掉",{"2":{"188":1}}],["消除冗余",{"2":{"208":1}}],["消除不可达代码",{"2":{"207":1}}],["消除",{"2":{"167":1}}],["消除aia",{"2":{"167":1}}],["消除间接左递归的步骤如下",{"2":{"167":1}}],["消除间接左递归",{"0":{"167":1}}],["消除直接左递归",{"0":{"150":1}}],["消除factor从goto表中去除了一个列",{"2":{"146":1}}],["消除无用产生式也有其代价",{"2":{"146":1}}],["亦可以用",{"2":{"188":1}}],["∩follow",{"2":{"188":4}}],["∩first",{"2":{"188":2}}],["缓存策略如最近最少使用来管理缓存条目的替换",{"2":{"187":1}}],["缓存包含键",{"2":{"187":1}}],["若β=",{"2":{"188":1}}],["若命中则直接使用对应的代码指针",{"2":{"187":1}}],["若老板不生气则顾客是满意的",{"2":{"103":1}}],["调试",{"2":{"206":1}}],["调度使用适当的方法向量来定位实现",{"2":{"187":1}}],["调用图几乎总是作为衍生的中间表示",{"2":{"224":1}}],["调用图中每个过程有一个节点",{"2":{"224":1}}],["调用图",{"0":{"224":1}}],["调用",{"2":{"193":1}}],["调用的代码必须为q分配并初始化一个活动记录",{"2":{"187":1}}],["调用方需要将寄存器r中的重要值保存到自己的活动记录",{"2":{"187":1}}],["调用方保存寄存器",{"2":{"187":1}}],["调用factorial",{"2":{"183":5}}],["调用必须为被调用者声明的对象创建存储空间",{"2":{"183":1}}],["调用机制提供了一种标准的方法来调用一个过程",{"2":{"183":1}}],["调用提供了一个在过程之间有序转移控制的机制",{"2":{"183":1}}],["调用过程",{"2":{"183":1}}],["调用递归函数",{"2":{"58":1,"68":1}}],["调用一次",{"2":{"23":1}}],["查找以定位方法的实现",{"2":{"187":1}}],["完整的方法向量虽然会稍微增加一些运行时的空间需求",{"2":{"187":1}}],["完整表示语法规则",{"2":{"176":1}}],["毫无疑问",{"2":{"187":1}}],["系统通常使用运行时堆",{"2":{"210":1}}],["系统可以使用内联方法缓存",{"2":{"187":1}}],["系列寄存器",{"2":{"155":1}}],["继之以存储布局",{"2":{"238":1}}],["继承可以创建只能通过额外类型信息来解析的模糊过程调用",{"2":{"224":1}}],["继承环境也会影响命名实体的属性",{"2":{"201":1}}],["继承的数据成员x",{"2":{"187":1}}],["继承的数据成员与父类保持相同偏移量",{"2":{"187":1}}],["继续计算所有项集",{"2":{"195":1}}],["继续使用上面的文法",{"2":{"170":1}}],["继续应用第一个产生式",{"2":{"150":1}}],["方法向量中的偏移量在整个继承层次链中必须保持一致",{"2":{"236":1}}],["方法的活动记录仍然捕捉命名空间的词法作用域部分和执行状态",{"2":{"187":1}}],["方法名称会被解析为一个坐标",{"2":{"187":1}}],["方法控制信息和局部名称存储使用激活记录",{"2":{"187":1}}],["方式",{"2":{"37":1}}],["且",{"2":{"194":1}}],["且其值在函数执行前后的状态需要保持一致",{"2":{"187":1}}],["且在",{"2":{"88":1}}],["活动记录捕捉了命名空间的结构",{"2":{"187":1}}],["活动记录",{"2":{"187":2}}],["参见第8章",{"2":{"224":1}}],["参见第10章内容",{"2":{"212":1}}],["参数区存放了来自调用点的实际参数",{"2":{"187":1}}],["参考cutlass链接",{"2":{"29":1}}],["涉及控制和命名的关键结构是激活记录",{"2":{"187":1}}],["延迟执行",{"2":{"183":1}}],["延用往数组里填值的思路",{"2":{"43":1}}],["回顾总结",{"0":{"228":1}}],["回调函数",{"2":{"183":1}}],["回想一下我们最简单的表达式语法接受a",{"2":{"129":1}}],["捕获的变量生命周期与闭包对象绑定",{"2":{"183":1}}],["按顺序",{"2":{"201":1}}],["按值捕获base",{"2":{"183":1}}],["按值或按引用",{"2":{"183":1}}],["按照thompson",{"2":{"118":3}}],["按照下面的方式重排",{"2":{"29":1}}],["满足n",{"2":{"183":1}}],["满足以下条件",{"2":{"29":1}}],["统一的调用序列通过使库函数和系统调用的使用成为可能",{"2":{"183":1}}],["统称为符号表",{"2":{"172":1}}],["防止其他过程中出现的问题",{"2":{"183":1}}],["建模的是控制流",{"2":{"206":1}}],["建模类的继承结构",{"0":{"201":1}}],["建模词法作用域",{"0":{"190":1}}],["建立了被调用者的环境",{"2":{"183":1}}],["建议去力扣或者b站上去看灵茶山艾府",{"2":{"5":1}}],["跨组件的交互通常通过过程调用进行结构化",{"2":{"183":1}}],["过程在大型软件系统的各部分之间形成关键接口",{"2":{"183":1}}],["过程在独立编译中扮演着关键角色",{"2":{"183":1}}],["过程调用会为被调用者创建一个新的且受保护的命名空间",{"2":{"183":1}}],["过程之间的分离提供了一定程度的保护",{"2":{"183":1}}],["过程之间的接口让程序员能够独立地开发和测试程序的一部分",{"2":{"183":1}}],["过程创建了一个已知和受控的执行环境",{"2":{"183":1}}],["过程创建了一个受控的执行环境",{"2":{"183":1}}],["过程不仅在语言设计和编译器实现中起着至关重要的作用",{"2":{"183":1}}],["过程是大多数编译器的工作基本单位",{"2":{"183":1}}],["过程有助于定义系统组件之间的接口",{"2":{"183":1}}],["过程",{"2":{"183":1,"204":1}}],["过程或块",{"2":{"175":1}}],["临时的目的而构建的ir",{"2":{"182":1}}],["衍生ir可能会增强确定性ir",{"2":{"182":1}}],["衍生ir是指编译器为了特定的",{"2":{"182":1}}],["衍生ir",{"2":{"182":1}}],["反过来",{"2":{"181":1}}],["反问环节",{"2":{"39":1}}],["像c和bcpl这样的语言使用不同的语法来表示函数调用和数组元素引用",{"2":{"180":1}}],["声明为每个命名实体建立一个具体类型",{"2":{"233":1}}],["声明在代码中的位置根据语言的作用域规则直接影响到生命周期和可见性",{"2":{"201":1}}],["声明允许显式指定名称的属性",{"2":{"201":1}}],["声明是在使用发生之前被解析的",{"2":{"180":1}}],["声明作用域",{"2":{"175":1}}],["设置goto",{"2":{"179":1}}],["设置action",{"2":{"179":3}}],["设计一个辅助过程match",{"2":{"134":1}}],["设计一个算法来计算你所能获取的最大利润",{"2":{"104":1}}],["创建了模糊调用",{"2":{"224":1}}],["创建基本块",{"2":{"207":1}}],["创建闭包",{"2":{"183":1}}],["创建新项集j",{"2":{"179":1}}],["创建一个build目录",{"2":{"114":1}}],["创建一个双端队列",{"2":{"63":1}}],["创建一个二维数组visited",{"2":{"58":1,"68":1}}],["信息从叶节点向根节点沿着语法树流动",{"2":{"178":1}}],["见第8",{"2":{"197":1}}],["见第4",{"2":{"143":1}}],["见上一节内存中值的放置",{"2":{"177":1,"193":1}}],["└──",{"2":{"176":6}}],["├──",{"2":{"176":12}}],["验证代码是否符合语法规则",{"2":{"176":1}}],["介于解析树和ast之间",{"2":{"176":1}}],["介绍",{"0":{"159":1}}],["去除了所有不必要的语法细节",{"2":{"192":1}}],["去除了所有冗余信息",{"2":{"176":1}}],["去除了不必要的语法细节",{"2":{"176":1}}],["去哪都一样",{"2":{"43":1}}],["严格遵循语法规则",{"2":{"176":1,"192":1}}],["例子包括可执行文件中的局部数据区域和全局数据区域",{"2":{"175":1}}],["例如p",{"2":{"221":1}}],["例如连接",{"2":{"209":1}}],["例如过程",{"2":{"204":1}}],["例如整个结构的赋值",{"2":{"191":1}}],["例如变量和标签",{"2":{"183":1}}],["例如变量的类型和大小",{"2":{"159":1}}],["例如通过构建用于指令调度的依赖图",{"2":{"182":1}}],["例如值的不确定性",{"2":{"175":1}}],["例如c++中的虚函数",{"2":{"172":1}}],["例如max",{"2":{"169":1}}],["例如浮点乘加操作",{"2":{"169":1}}],["例如运算符优先级解析",{"2":{"130":1}}],["例如",{"2":{"29":1,"53":1,"114":1,"129":1,"131":1,"143":2,"145":1,"148":1,"152":1,"155":1,"159":1,"160":1,"162":1,"163":2,"165":1,"166":1,"167":1,"173":3,"175":2,"184":1,"187":1,"193":1,"198":1,"204":2,"212":1,"215":1,"218":1,"221":1,"233":1,"236":1}}],["动作",{"2":{"174":1,"178":1}}],["动态调度首先在方法缓存中查找",{"2":{"187":1}}],["动态调度首先检查缓存",{"2":{"187":1}}],["动态绑定",{"2":{"172":1}}],["动态规划代码",{"2":{"50":1}}],["允许整个结构或整个数组赋值的语言依赖于兼容性检查",{"2":{"173":1}}],["明确地或隐含地",{"2":{"172":1}}],["处",{"2":{"172":1}}],["处理不可达代码",{"2":{"219":1}}],["处理循环结构",{"2":{"219":1}}],["处理异常处理的控制流",{"2":{"219":1}}],["处理非本地计算",{"0":{"204":1}}],["处理上下文相关的歧义",{"0":{"180":1}}],["处理冲突是哈希表设计中的一个关键问题",{"2":{"139":1}}],["处理",{"2":{"115":2,"167":2}}],["修改并丢弃该模型的部分内容",{"2":{"172":1}}],["修改输入数组",{"2":{"87":1}}],["名称等价性断言两个类型只有在程序员用相同的名字称呼它们时才是等价的",{"2":{"230":1}}],["名称创建了不同的名称列表",{"2":{"204":1}}],["名称的定义出现位置创建其符号表条目",{"2":{"204":1}}],["名称的定义出现位置",{"2":{"204":1}}],["名称是隐式的",{"2":{"197":1}}],["名称空间",{"2":{"183":1}}],["名称",{"2":{"172":1}}],["名称在其作用域内可见",{"2":{"172":1}}],["名称通常由整数或表索引表示",{"2":{"169":1}}],["命名方案对优化如何改进代码有着强烈的影响",{"2":{"197":1}}],["命名环境建模",{"0":{"172":1},"1":{"190":1,"201":1}}],["命名空间的模型以及一种机制",{"2":{"159":1}}],["命名空间的选择与ir的选择相互影响",{"2":{"140":1}}],["命名空间",{"0":{"140":1,"197":1},"1":{"155":1}}],["三地址的中间表示类似于该构造的明显汇编码",{"2":{"223":1}}],["三地址中间表示",{"2":{"169":1}}],["三地址码则缺乏这种直接映射",{"2":{"194":1}}],["三地址码经常被实现为一组四元组",{"2":{"186":1}}],["三地址码特别适合于针对寄存器到寄存器",{"2":{"169":1}}],["三地址码引入了一套新的编译器生成的名称",{"2":{"169":1}}],["三地址码没有破坏性操作",{"2":{"169":1}}],["三地址码因其几个优点而受到青睐",{"2":{"169":1}}],["三地址码",{"0":{"169":1}}],["三地址码模拟了一种大多数操作接受两个操作数并产生一个结果的机器",{"2":{"136":1}}],["三地址码可以显式地模拟破坏性操作",{"2":{"136":1}}],["精心选择的命名空间可以揭示改进代码的新机会",{"2":{"169":1}}],["排序非终结符",{"2":{"167":1}}],["排列以转置向量",{"2":{"29":1}}],["间接左递归是指通过多个产生式间接形成的左递归",{"2":{"167":1}}],["间接左递归相比直接左递归不是十分明显",{"2":{"150":1}}],["抽象程度",{"2":{"176":1}}],["抽象层次很重要",{"2":{"166":1}}],["抽象层次与结构无关",{"2":{"166":1}}],["抽象语法树可以使用一个有三个子节点的节点来表示if语句",{"2":{"217":1}}],["抽象语法树与输入程序的语法结构有直接且明显的关系",{"2":{"194":1}}],["抽象语法树",{"0":{"185":1},"2":{"151":1,"176":1,"185":1,"192":1}}],["现代计算机系统通常以交错的方式执行许多程序",{"2":{"216":1}}],["现代多遍编译器使用某种形式的ir来建模被分析",{"2":{"165":1}}],["现在我们看到使用不同的括号来区分下标和调用也将解决这种歧义",{"2":{"180":1}}],["现在我们来讨论一个整数输入的例子",{"2":{"160":1}}],["现在要尝试着用了",{"2":{"106":1}}],["现在",{"2":{"63":1,"167":1}}],["现在业务主要是all",{"2":{"46":1}}],["现在看来纯纯kpi",{"2":{"43":1}}],["现在来看有些问题记不得了",{"2":{"41":1}}],["现在凭记忆记录一下",{"2":{"35":1}}],["匹配时直接使用",{"2":{"187":1}}],["匹配",{"2":{"164":1}}],["缺少明确的优先级和结合性规则",{"2":{"164":1}}],["缺点",{"2":{"67":1}}],["产生式的顺序安排不当",{"2":{"164":1}}],["产生二义性的主要原因包括",{"2":{"164":1}}],["产生了最终的",{"2":{"123":1}}],["文本上相同的表达式必须产生相同的值",{"2":{"198":1}}],["文本的处理和表示方式会有所不同呢",{"2":{"47":1}}],["文法的条件",{"2":{"188":1}}],["文法的二义性是指一个句子可以通过多种不同的方式推导出来",{"2":{"164":1}}],["文法的二义性",{"0":{"164":1}}],["文件静态变量的生命周期是整个执行期间",{"2":{"175":1}}],["新实例的名称会遮蔽旧的实例",{"2":{"187":1}}],["新增成员位于其后",{"2":{"187":1}}],["新的解析器没有解析表",{"2":{"163":1}}],["新人培养",{"2":{"46":1}}],["状态保持",{"2":{"183":1}}],["状态栈",{"2":{"179":1,"195":1}}],["状态",{"2":{"163":1}}],["状态转换图是代码实现的抽象表达",{"2":{"102":1}}],["状态转移方程也可以照搬",{"2":{"74":1}}],["合并连续基本块",{"2":{"207":1}}],["合并行和列的机制类似于上一节讨论的用于缩减dfa转换函数表的技术",{"2":{"163":1}}],["合并行或列",{"2":{"163":1}}],["合并区间",{"0":{"79":1,"84":1},"1":{"84":1}}],["必须包含从其超类继承的数据成员",{"2":{"236":1}}],["必须对num和name返回相同的句法类别或单词",{"2":{"163":1}}],["必须转换到属于划分中单一集合的状态",{"2":{"115":1}}],["替换为一个产生式",{"2":{"163":1}}],["较少的产生式通常会导致较小的表",{"2":{"163":1}}],["较慢",{"2":{"67":1}}],["缩减语法",{"2":{"163":1}}],["减少lr",{"0":{"163":1}}],["减去前缀和的最小值",{"2":{"106":2}}],["减去谁呢",{"2":{"106":1}}],["运算符替换为",{"2":{"162":1}}],["运行时系统通过方法缓存优化查找过程",{"2":{"187":1}}],["运行时命名支持",{"0":{"187":1}}],["运行更快",{"2":{"146":1}}],["运行样例结果也对了",{"2":{"8":1}}],["展示了一种替代布局",{"2":{"239":1}}],["展示了一个简单的树遍历以计算其值",{"2":{"178":1}}],["展示了如果编译器按字母顺序为它们分配偏移量所得到的布局",{"2":{"239":1}}],["展示了使用左递归语法的",{"2":{"178":1}}],["展示了字符串",{"2":{"162":1}}],["展示了同一段代码的ssa形式",{"2":{"155":1}}],["绝对值的优先级应该比加法或乘法高",{"2":{"162":1}}],["决定了何时进行归约操作",{"2":{"161":1}}],["决定移进",{"2":{"144":1}}],["句柄的重要性",{"2":{"161":1}}],["句柄的识别",{"2":{"161":1}}],["句柄的特征",{"2":{"161":1}}],["句柄是某个产生式右部的一个子串",{"2":{"161":1}}],["句柄是指一个产生式的右部",{"2":{"161":1}}],["句柄",{"0":{"161":1}}],["版本",{"2":{"159":1}}],["翻译控制流语句",{"0":{"211":1},"1":{"217":1,"223":1}}],["翻译表达式",{"0":{"194":1}}],["翻译",{"2":{"159":1}}],["传引用参数可以是含糊的",{"2":{"157":1}}],["含糊性可以以多种方式出现",{"2":{"157":1}}],["哪些不应该",{"2":{"157":1}}],["浮点变量",{"2":{"155":1}}],["外部接口",{"2":{"183":1}}],["外部链接",{"2":{"21":1}}],["外所有的通用寄存器",{"2":{"155":1}}],["阶段",{"2":{"155":2}}],["阶段占据着核心地位",{"2":{"130":1}}],["根本没有使用过",{"2":{"155":1}}],["根据情况分支到then子部分",{"2":{"223":1}}],["根据第255页第5",{"2":{"187":1}}],["根据第4章的定义",{"2":{"172":1}}],["根据这种绑定",{"2":{"159":1}}],["根据当前状态和输入符号查找action表",{"2":{"144":1}}],["根据堆栈模型展示了操作",{"2":{"143":1}}],["根据队首",{"2":{"64":1}}],["根据位置确定具体值",{"2":{"43":1}}],["根据nvidia",{"2":{"4":1}}],["安全放进只读的虚拟寄存器",{"2":{"155":1}}],["安装llvm",{"0":{"114":1}}],["被调方保存寄存器",{"2":{"187":1}}],["被调用者无法保持在寄存器中的变量",{"2":{"187":1}}],["被调用者可以向其调用者返回一个值",{"2":{"183":1}}],["被称为",{"2":{"155":1}}],["被一个block内的线程共享",{"2":{"7":1}}],["节点代表操作",{"2":{"218":1}}],["节点可以有多个父节点",{"2":{"198":1}}],["节点构建这样的数组",{"2":{"186":1}}],["节点内容",{"2":{"176":1}}],["节点",{"2":{"155":1}}],["节点序列expr→term→factor→",{"2":{"129":1}}],["循环示例",{"2":{"229":1}}],["循环优化等",{"2":{"206":1}}],["循环直到接受或报错",{"2":{"179":1,"195":1}}],["循环的",{"2":{"155":1}}],["循环终止时",{"2":{"127":1}}],["φ函数根据控制流选择x2或x3",{"2":{"214":1}}],["φ",{"2":{"155":8,"214":1}}],["低级虚拟机",{"2":{"154":1}}],["事实上",{"2":{"154":1}}],["∈",{"2":{"153":2,"170":1,"188":3,"206":2}}],["∈sa​",{"2":{"102":1}}],["∈sa",{"2":{"102":1}}],["α∈follow",{"2":{"188":2}}],["α∈first",{"2":{"188":2}}],["αa→α",{"2":{"188":3}}],["αaβ→αγβ",{"2":{"131":2}}],["αx",{"2":{"179":1}}],["αba→αb",{"2":{"170":1}}],["αbβa→αbβ",{"2":{"170":1}}],["ααα",{"2":{"153":2,"188":1}}],["α",{"2":{"153":3,"179":5,"188":20,"236":4}}],["经典的例子包括一周中的几天和一年中的几个月",{"2":{"215":1}}],["经典的表达式语法仅包含二元运算符",{"2":{"162":1}}],["经常作为在系统和环境之间传输代码的ir",{"2":{"152":1}}],["经历字符",{"2":{"115":2}}],["×",{"2":{"152":1,"221":5}}],["许多语言有一个",{"2":{"233":1}}],["许多语言允许程序员构建包含特定常量值集合的类型",{"2":{"215":1}}],["许多现代编译器在单次编译过程中使用多种ir",{"2":{"165":1}}],["许多编译器将数组元素值视为含糊的",{"2":{"157":1}}],["许多编译器使用将底层代码表示为图的ir",{"2":{"151":1}}],["许可证开发的开源软件",{"2":{"110":1}}],["原则上以及实际上",{"2":{"193":1}}],["原则上",{"2":{"178":1,"203":1}}],["原字符串的特定是",{"2":{"150":1}}],["原地",{"2":{"87":1}}],["混合ir结合了图形化和线性ir的元素",{"2":{"149":1}}],["混元大模型",{"2":{"46":1}}],["混元大模型相关的业务",{"2":{"26":1}}],["推导中的每个语法符号都有一个对应的节点",{"2":{"168":1}}],["推导出的所有可能的终结符串的第一个符号的集合",{"2":{"153":1}}],["推导完成",{"2":{"147":2}}],["推导过程",{"2":{"147":2}}],["非嵌套的过程",{"2":{"203":1}}],["非错误入口",{"2":{"145":1}}],["非递归ll",{"0":{"122":1},"1":{"137":1,"153":1,"170":1,"188":1}}],["非递归出现小问题",{"2":{"37":1}}],["恢复",{"2":{"145":1}}],["尤其是可以定位错误",{"2":{"144":1}}],["尤其是在它们生命周期的非平凡部分",{"2":{"143":1}}],["检测到",{"2":{"155":1}}],["检测语法错误",{"2":{"144":1}}],["检查所有长度为k的二进制子串",{"0":{"89":1,"101":1},"1":{"101":1}}],["检查队列",{"2":{"63":1}}],["执行适当的类型检查",{"2":{"201":1}}],["执行调用会实例化被调用者的命名空间",{"2":{"183":1}}],["执行移进或归约操作",{"2":{"144":1}}],["执行访存",{"2":{"29":1}}],["具有与源代码语法相对应的结构",{"2":{"151":1}}],["具有堆栈操作",{"2":{"143":1}}],["具体步骤",{"2":{"195":1}}],["具体来说",{"2":{"161":1}}],["具体信息将根据实体的类型而变化",{"2":{"139":1}}],["具体实现的细节会有当前指针input",{"2":{"124":1}}],["具体分析一下代码",{"2":{"50":1}}],["具体记不清了",{"2":{"39":1}}],["具体干什么我也忘了",{"2":{"39":1}}],["具体说来",{"2":{"29":1}}],["具体应该是搜索引擎相关",{"2":{"26":1}}],["具体可执行代码可参考github仓库code",{"2":{"24":1}}],["寄存器保存区包含足够的空间来保存过程中跨过程调用必须保留的寄存器值",{"2":{"187":1}}],["寄存器只定义",{"2":{"155":1}}],["寄存器被覆盖",{"2":{"155":1}}],["寄存器分配",{"2":{"155":1,"200":1}}],["寄存器分配更多地关注于名称映射",{"2":{"143":1}}],["寄存器的数量和序号是确定的",{"2":{"155":1}}],["寄存器到寄存器模型",{"2":{"143":1}}],["交换swap",{"2":{"143":1}}],["交易无法获得正利润",{"2":{"50":1}}],["压入状态栈",{"2":{"195":1}}],["压栈push和弹栈pop",{"2":{"143":1}}],["压缩状态表",{"2":{"124":1}}],["值的生命周期信息以及编译器编写者对目标机器系统架构的了解来决定这些位置",{"2":{"175":1}}],["值的主要存放位置在内存中",{"2":{"143":2}}],["值会与解析中使用的每个符号关联",{"2":{"160":1}}],["值就被保存在一个虚拟寄存器中",{"2":{"143":1}}],["值矩阵",{"2":{"75":1}}],["形式期间进行类型检查",{"2":{"233":1}}],["形式的三地址码表示",{"2":{"232":1}}],["形式的调用序列标准化",{"2":{"183":1}}],["形式之前",{"2":{"143":1}}],["形成了编译器关于程序知识库的关键部分",{"2":{"148":1}}],["形成一个",{"2":{"23":1}}],["项集族",{"2":{"144":1,"195":1}}],["项集",{"2":{"142":2}}],["项目最初被命名为低级虚拟机",{"2":{"110":1}}],["项目起源于",{"2":{"110":1}}],["常用于优化阶段",{"2":{"206":1}}],["常见的自底向上解析器包括",{"2":{"142":1}}],["常量值是一个特例",{"2":{"175":1}}],["常量",{"2":{"139":1}}],["策略",{"2":{"142":1}}],["归约冲突",{"2":{"180":1}}],["归约",{"2":{"142":1,"144":1,"163":1,"174":4,"179":1,"195":6}}],["显式内存操作",{"2":{"232":1}}],["显式控制流",{"2":{"232":1}}],["显式的数据依赖关系使得优化更容易实现",{"2":{"200":1}}],["显式表示数据依赖关系",{"2":{"189":1}}],["显示了一个简单四个变量例子的长度和约束条件",{"2":{"239":1}}],["显示了相应数据依赖图",{"2":{"218":1}}],["显示了相应的线性表示",{"2":{"166":1}}],["显示了同时实例化一个point和一个colorpoint后可能出现的运行时结构",{"2":{"187":1}}],["显示了接近源代码级别和接近机器级别的抽象语法树",{"2":{"166":1}}],["显示了在两种不同假设下的操作",{"2":{"143":1}}],["显示了最终的dfa",{"2":{"141":1}}],["显示了通过应用反转和子集构造转换后得到的dfa",{"2":{"141":1}}],["显示了原始的nfa",{"2":{"141":1}}],["显然它们都是",{"2":{"101":1}}],["构建目的是为了支持跨过程分析和优化",{"2":{"224":1}}],["构建三地址码",{"0":{"223":1}}],["构建这个抽象语法树的动作是直接了当的",{"2":{"217":1}}],["构建抽象语法树",{"0":{"217":1}}],["构建的cfg如下",{"2":{"213":1}}],["构建的nfa时所采取的步骤",{"2":{"141":1}}],["构建和使用这些注解所花费的时间和空间毫无疑问远远超过了构建cfg的成本",{"2":{"212":1}}],["构建ssa形式通常包括以下步骤",{"2":{"208":1}}],["构建控制流边",{"2":{"207":1}}],["构建控制流图的基本步骤",{"2":{"206":1}}],["构建步骤",{"0":{"207":1}}],["构建模型",{"2":{"201":1}}],["构建",{"2":{"198":1}}],["构建算法必须在操作数的值可能发生改变时使子树失效",{"2":{"198":1}}],["构建表的详细计算步骤如上",{"2":{"195":1}}],["构建action表和goto表",{"2":{"195":1}}],["构建action表的步骤",{"2":{"179":1}}],["构建过程",{"2":{"195":1}}],["构建括号列表文法的lr",{"0":{"195":1}}],["构建一个叶节点",{"2":{"194":1}}],["构建一个类型为",{"2":{"194":1}}],["构建新类型以表示复合或聚合对象的能力是许多语言的重要特性",{"2":{"191":1}}],["构建goto表的步骤",{"2":{"179":1}}],["构建其含义的表示",{"2":{"159":1}}],["构建解析表",{"2":{"144":1}}],["构建lr",{"2":{"144":1}}],["构造类型和类型等价的概念应该从大多数高级语言中熟悉",{"2":{"235":1}}],["构造类型使得语言可以表达更高层次的操作",{"2":{"191":1}}],["构造接受的语法类别又比规范的lr",{"2":{"181":1}}],["构造接受的语法类别比lalr",{"2":{"181":1}}],["构造是这些表构造算法中最通用的",{"2":{"181":1}}],["构造所生成的大小相似的规范集合",{"2":{"181":1}}],["构造要少",{"2":{"181":3}}],["构造lr",{"0":{"126":1},"1":{"144":1,"161":1,"179":1,"195":1}}],["构造",{"2":{"118":4,"181":2}}],["构造方法的循环证明了正则表达式和有限自动机具有等价的表达能力",{"2":{"112":1}}],["构造了一个",{"2":{"43":1}}],["静态分析的结果",{"2":{"205":1}}],["静态分配",{"2":{"187":1}}],["静态属性通常被实现为从执行开始一直持续到结束",{"2":{"203":1}}],["静态变量",{"0":{"203":1},"2":{"203":1}}],["静态变量存储在与声明作用域关联的预分配数据区域中",{"2":{"175":1}}],["静态变量的生命周期可能会跨越其声明作用域的多次激活",{"2":{"175":1}}],["静态绑定",{"2":{"172":1}}],["静态",{"2":{"155":1,"175":1,"177":1}}],["静态单赋值形式",{"0":{"171":1},"1":{"189":1,"200":1,"208":1,"214":1,"220":1,"225":1,"229":1,"232":1},"2":{"171":1}}],["静态单赋值形式的ir",{"2":{"140":1}}],["静态单赋值",{"2":{"155":1,"232":1}}],["静态大小的",{"2":{"155":1}}],["静态映射",{"2":{"139":1}}],["某些面向对象语言",{"2":{"201":1}}],["某些大小信息可能从聚合分配的位置推断出来",{"2":{"190":1}}],["某些后续步骤将会根据情况将引用重写为数组引用或函数调用",{"2":{"180":1}}],["某些操作符",{"2":{"169":1}}],["某些ir在命名上允许较大的自由度",{"2":{"140":1}}],["某一天",{"2":{"104":1}}],["元组",{"2":{"139":1}}],["元素的相对顺序应该保持一",{"2":{"80":1}}],["元素离开队首",{"2":{"64":1}}],["元素进入队尾",{"2":{"64":1}}],["哈希映射",{"2":{"139":1}}],["平衡树使用更复杂的插入和删除协议以维持大致相等大小的子树",{"2":{"139":1}}],["平台上的",{"2":{"114":1}}],["树",{"2":{"191":1}}],["树遍历的表述揭示了yacc风格的基于语法的计算的几个重要方面",{"2":{"178":1}}],["树形结构的ir自然而然地引导人们以某种形式的树遍历来组织遍次",{"2":{"149":1}}],["树结构具有列表的优点",{"2":{"139":1}}],["树实现",{"2":{"139":1}}],["扩展和搜索都很简单",{"2":{"139":1}}],["映射的实现从文本名称到索引的映射可以通过多种方式进行实现",{"2":{"139":1}}],["映射到下一个状态",{"2":{"102":1}}],["既包括映射函数也包括存储库",{"2":{"139":1}}],["两个操作数",{"2":{"169":1,"186":1}}],["两个有序数组求交集",{"2":{"46":1}}],["两种常见的表示方式是空终止字符串和带有长度字段的字符串",{"2":{"231":1}}],["两种命名风格都需要运行时结构来反映和实现命名层次",{"2":{"187":1}}],["两种算法之间的权衡并不是直截了当的",{"2":{"141":1}}],["两种最常见的命名空间层次结构是由词法作用域规则和继承规则创建的",{"2":{"139":1}}],["两者比较",{"0":{"141":1}}],["嵌套创建了命名空间的层次结构",{"2":{"139":1}}],["作为权威的中间表示",{"2":{"198":1}}],["作为替代方案",{"2":{"187":1}}],["作为代码的外部",{"2":{"152":1}}],["作为回报",{"2":{"139":1}}],["作为哈希的一种替代方案",{"2":{"139":1}}],["作为编译器输入的源代码是线性的",{"2":{"136":1}}],["作用域是程序中划定命名空间的一个区域",{"2":{"172":1}}],["作用域是一组连续的语句",{"2":{"139":1}}],["作用域可以嵌套",{"2":{"139":1}}],["作用域的界限由语言中的特定符号标记",{"2":{"139":1}}],["编译时解析与运行时解析",{"2":{"201":1}}],["编译器就必须构建带有抽象引用的ir",{"2":{"238":1}}],["编译器就无法更改它们",{"2":{"166":1}}],["编译器设计者在翻译过程中面临一个选择",{"2":{"238":1}}],["编译器设计者必须选择一个合适的实现策略",{"2":{"139":1}}],["编译器构建一个调用图",{"2":{"224":1}}],["编译器构建了一组与树",{"2":{"148":1}}],["编译器将枚举类型的每个元素映射到一个独特的值",{"2":{"215":1}}],["编译器应该标记a为可能存在歧义",{"2":{"204":1}}],["编译器开发者必须制定一种原理",{"2":{"203":1}}],["编译器为静态变量创建独立的数据区",{"2":{"203":1}}],["编译器为每个方法生成搜索键",{"2":{"187":1}}],["编译器从搜索路径的最内层级别开始",{"2":{"201":1}}],["编译器经常将名称的词素映射到特定实体",{"2":{"201":1}}],["编译器经常使用类似于汇编代码的线性ir",{"2":{"148":1}}],["编译器还必须为结构体和对象执行布局",{"2":{"234":1}}],["编译器还必须提供其他信息给被调用者",{"2":{"187":1}}],["编译器还会构建各种辅助的数据结构来表示推导出的信息",{"2":{"132":1}}],["编译器和运行时系统必须建立一组运行时数据结构",{"2":{"187":1}}],["编译器和操作系统之间的一种协议",{"2":{"183":1}}],["编译器以多种方式实现四元组",{"2":{"186":1}}],["编译器根据实体的生命期和可见性来做这个决定",{"2":{"240":1}}],["编译器根据其生命周期",{"2":{"177":1}}],["编译器根据编程语言",{"2":{"175":1}}],["编译器系统地将每个值分配给寄存器或数据区域",{"2":{"175":1}}],["编译器采用的内存模型",{"2":{"175":1}}],["编译器至少应该发出一个有见地的错误消息",{"2":{"173":1}}],["编译器使用两个基本工具",{"2":{"201":1}}],["编译器使用两种机制来构建ir及其辅助数据结构",{"2":{"159":1}}],["编译器使用它构建的表示词法和继承层次结构的符号表",{"2":{"201":1}}],["编译器使用相同的工具来建模继承层次结构和词法层次结构",{"2":{"201":1}}],["编译器使用其对命名空间的模型来决定这个绑定",{"2":{"172":1}}],["编译器衍生出的很多信息在源代码中没有表示",{"2":{"165":1}}],["编译器是一个程序",{"2":{"159":1}}],["编译器确切地知道x的值在何处变化",{"2":{"157":1}}],["编译器会发出代码以跟随从对象结构到类方法向量再到代码指针的路径",{"2":{"187":1}}],["编译器会发现许多不同实体的名称和属性",{"2":{"139":1}}],["编译器会生成代码来沿超类链向上追踪到正确的层级",{"2":{"187":1}}],["编译器会为该区域中的每个实体分配一个从数据区起点开始的偏移量",{"2":{"177":1}}],["编译器会将生命周期归类为以下三个类别之一",{"2":{"175":1}}],["编译器会根据其个别属性为其分配一个永久的存储位置",{"2":{"175":1}}],["编译器会创建",{"2":{"172":1}}],["编译器会决定哪些值它们认为是明确的",{"2":{"157":1}}],["编译器会尝试将尽可能多的值分配给虚拟寄存器",{"2":{"157":1}}],["编译器在作用域中首次遇到名称时会识别该实体",{"2":{"204":1}}],["编译器在初步翻译过程中构建这些表格",{"2":{"172":1}}],["编译器在不同控制流路径合并的点插入",{"2":{"155":1}}],["编译器在命名方面所做的选择在很大程度上决定了哪些计算可以被分析和优化",{"2":{"140":1}}],["编译器不会回溯到源代码",{"2":{"182":1}}],["编译器不能仅仅发出简单的操作符",{"2":{"173":1}}],["编译器不能在一个赋值操作过程中将一个含糊的值保持在寄存器中",{"2":{"157":1}}],["编译器不应该尝试为语法上无效的程序生成和优化代码",{"2":{"145":1}}],["编译器不必枚举所有的值及其位置",{"2":{"143":1}}],["编译器通常会将具有不可预测生命期的项放在运行时堆上",{"2":{"240":1}}],["编译器通常将控制流图",{"2":{"206":1}}],["编译器通常将",{"2":{"206":1}}],["编译器通常使用汇编语言结构来创建和初始化静态数据区",{"2":{"203":1}}],["编译器通常为它们创建一个单独的数据区域",{"2":{"175":1}}],["编译器通常被组织为一系列的遍历过程",{"2":{"132":1}}],["编译器通过显式的操作",{"2":{"143":1}}],["编译器必须决定每个运行时实体的存储位置及其存储何时被分配",{"2":{"240":1}}],["编译器必须采用稍微复杂的方案",{"2":{"237":1}}],["编译器必须检查每一个这样的调用",{"2":{"233":1}}],["编译器必须从值在代码中出现的上下文中推断类型",{"2":{"233":1}}],["编译器必须以允许系统链接器将所有对给定全局名称的引用映射到同一存储位置的方式来创建全局数据区",{"2":{"203":1}}],["编译器必须将控制转移编码为一组标签",{"2":{"223":1}}],["编译器必须将继承层次结构的一部分插入到搜索路径的适当位置",{"2":{"201":1}}],["编译器必须将每个实体分配到一个逻辑数据区",{"2":{"177":1}}],["编译器必须证明",{"2":{"198":1}}],["编译器必须发出指令来在每次调用时执行初始化",{"2":{"187":1}}],["编译器必须确定x的属性",{"2":{"204":1}}],["编译器必须确定程序计算的每个值在运行时将存储在哪里",{"2":{"175":1}}],["编译器必须确保每次调用",{"2":{"193":1}}],["编译器必须确保这些初始化操作得以执行",{"2":{"187":1}}],["编译器必须为每个字段在结构体的表示中分配一个偏移量",{"2":{"234":1}}],["编译器必须为每个驻留在内存中的值分配一个位置",{"2":{"175":1}}],["编译器必须为众多不同的值选择名称和存储位置",{"2":{"197":1}}],["编译器必须为在被调用者中声明的局部变量创建存储空间",{"2":{"187":1}}],["编译器必须生成代码",{"2":{"187":1}}],["编译器必须重写引用的ir",{"2":{"166":1}}],["编译器必须理解程序的名字空间",{"2":{"148":1}}],["编译器必须理解代码中计算的每个值将存放的位置",{"2":{"143":1}}],["编译器必须构建表来模拟每个这样的层次结构",{"2":{"139":1}}],["编译器的运行时支持库必须提供一种机制来分配和释放这些不规则实体",{"2":{"210":1}}],["编译器的许多部分都依赖于",{"2":{"206":1}}],["编译器的许多任务需要来自计算其他部分的信息",{"2":{"204":1}}],["编译器的符号表实例化了该模型",{"2":{"190":1}}],["编译器的符号表的一个用途正是提供对通过基于语法的计算得出的数据的非局部访问",{"2":{"178":1}}],["编译器的ir必须具有足够的表达力以记录编译器可能需要在各遍之间传输的所有有用信息",{"2":{"165":1}}],["编译器的中间表示",{"2":{"140":1}}],["编译器的设计与实现中",{"2":{"130":1}}],["编译器对集合进行线性扫描并处理每个子集",{"2":{"139":1}}],["编译器对集合进行字典排序",{"2":{"139":1}}],["编译器首先扫描整个程序",{"2":{"139":1}}],["编译器编写者必须为类型实现一个适当的表示形式和一个适当的等价性测试",{"2":{"230":1}}],["编译器编写者必须理解语法和解析器工程的基础知识",{"2":{"129":1}}],["编译器编写者还必须为ir选择一个命名空间",{"2":{"197":1}}],["编译器编写者需要确保编译器能够发现尽可能多的错误",{"2":{"196":1}}],["编译器编写者需要一种方法来告诉解析器生成器在哪里进行同步",{"2":{"145":1}}],["编译器编写者提供了高层次的函数以抽象掉值存储位置的细节",{"2":{"194":1}}],["编译器编写者在ar分配上有三种选择",{"2":{"187":1}}],["编译器编写者可以在一个收集所需信息的程序开发系统中嵌入编译器",{"2":{"233":1}}],["编译器编写者可以使用这些不同的产生式将类型直接编码到语法指导的动作中",{"2":{"204":1}}],["编译器编写者可以使用由语法驱动的动作来构建和填充表格",{"2":{"201":1}}],["编译器编写者可以通过调整语法规则",{"2":{"196":1}}],["编译器编写者可以通过在",{"2":{"178":1}}],["编译器编写者可以将函数调用和数组引用都合并到一个产生式规则中",{"2":{"180":1}}],["编译器编写者可以将下标",{"2":{"180":1}}],["编译器编写者倾向于使用更加简洁的替代方案",{"2":{"168":1}}],["编译器编写者应该尽量保持这种分配的成本尽可能低",{"2":{"187":1}}],["编译器编写者应将表达式语法的例程放在虚拟内存中的单一页上",{"2":{"163":1}}],["编译器编写者应当使用一个设计良好的哈希函数",{"2":{"139":1}}],["编译器编写者常常可以通过重新编码语法来减少产生式的数量",{"2":{"163":1}}],["编译器编写者使用这个机制来驱动基本的信息收集",{"2":{"159":1}}],["编译器编写者规定在解析器通过特定产生式简化时应采取的动作",{"2":{"159":1}}],["编译器编写者会做出一系列决定",{"2":{"143":1}}],["编译器可能会构建一个具有不完整类型信息的中间表示",{"2":{"233":1}}],["编译器可能会执行跨过程分析以限制此类调用在调用图中所引起的边集",{"2":{"224":1}}],["编译器可能会对数组下标值进行广泛分析",{"2":{"218":1}}],["编译器可能会保留其值而不是计算两次",{"2":{"210":1}}],["编译器可能会为每个控制流图",{"2":{"186":1}}],["编译器可能会将代码转换进出于衍生ir以启用特定的优化",{"2":{"182":1}}],["编译器可能会合并多个作用域的静态数据区域",{"2":{"175":1}}],["编译器可能需要生成一些代码",{"2":{"201":1}}],["编译器可能需要生成在运行时执行类型检查和代码选择的代码",{"2":{"173":1}}],["编译器可能需要生成使用更复杂评估方案的代码",{"2":{"173":1}}],["编译器可能需要数据类型",{"2":{"139":1}}],["编译器可以为给定的数据区域构建一个名称列表",{"2":{"239":1}}],["编译器可以要求为每个函数提供类型签名",{"2":{"233":1}}],["编译器可以要求整个程序在编译时都存在",{"2":{"233":1}}],["编译器可以将类型检查推迟到链接时或运行时",{"2":{"233":1}}],["编译器可以将其作为语法驱动翻译框架的一部分来分配类型",{"2":{"233":1}}],["编译器可以将这种混合ir作为其权威的ir",{"2":{"206":1}}],["编译器可以将这些表链接成一个继承层次结构的搜索路径",{"2":{"201":1}}],["编译器可以通过根节点来引用任何子树",{"2":{"197":1}}],["编译器可以选择将其存储在寄存器中",{"2":{"193":1}}],["编译器可以在解析期间建立符号表",{"2":{"238":1}}],["编译器可以在解析某个类的声明时为与每个类关联的作用域构建一个独立的表",{"2":{"201":1}}],["编译器可以在处理声明时收集所有的类型和符号信息",{"2":{"238":1}}],["编译器可以在遍历表达式树的过程中自底向上地分配类型",{"2":{"233":1}}],["编译器可以在",{"2":{"193":1}}],["编译器可以在编译时将方法名解析为特定的实现",{"2":{"187":1}}],["编译器可以在其类方法向量中仅表示colorpoint的本地方法",{"2":{"187":1}}],["编译器可以在被调方的ar或调用方的ar中保存它们",{"2":{"187":1}}],["编译器可以在执行前一次性分配这样的变量",{"2":{"175":1}}],["编译器可以根据它们的生命周期对需要存储的值进行分类",{"2":{"177":1}}],["编译器可以根据每个值的生命周期和作用域对其进行分类",{"2":{"175":1}}],["编译器可以执行存储布局",{"2":{"177":1}}],["编译器可以生成一系列乘法来评估",{"2":{"173":1}}],["编译器可以安全地生成将x保持在寄存器中的代码",{"2":{"157":1}}],["编译器可以使用这些工具来构建上下文特定的搜索空间",{"2":{"201":1}}],["编译器可以使用为词法层次结构设计的符号表构建块来表示继承层次结构",{"2":{"201":1}}],["编译器可以使用类型信息来确保操作符和操作数是兼容的",{"2":{"173":1}}],["编译器可以使用已排序的集合来修改标记流",{"2":{"139":1}}],["编译器可以使用一种称为哈希的数值计算",{"2":{"139":1}}],["编译器可以预先计算一个无冲突的静态映射",{"2":{"139":1}}],["编译器需要每个函数的类型签名",{"2":{"233":1}}],["编译器需要访问那些先前已确定的属性",{"2":{"204":1}}],["编译器需要从表示过程的简单线性ir来构建cfg",{"2":{"199":1}}],["编译器需要为每个方法名生成搜索键",{"2":{"187":1}}],["编译器需要为每个编程语言构造提供一个实现方案",{"2":{"159":1}}],["编译器需要将在调用处的实际参数映射到被调用者中可访问的形式参数",{"2":{"187":1}}],["编译器需要理解代码中每个名称的可见性",{"2":{"159":1}}],["编译器需要一个更复杂的继承层次结构模型",{"2":{"201":1}}],["编译器需要一个由类声明集定义的继承层次结构的模型",{"2":{"201":1}}],["编译器需要一个实现计划",{"2":{"159":1}}],["编译器需要一种机制来确定两个构造类型是否等价",{"2":{"230":1}}],["编译器需要一种机制来连接单个四元组",{"2":{"186":1}}],["编译器需要一种机制",{"2":{"159":1}}],["编译器需要一种表示所有关于程序的事实的方法",{"2":{"132":1}}],["编译器需要各种信息才能生成操作该实体的代码",{"2":{"139":1}}],["编译器中使用的线性ir通常类似于抽象机器的汇编码",{"2":{"136":1}}],["编译器中的一个非本地计算示例是将类型",{"2":{"204":1}}],["编译器中的大多数遍也产生ir",{"2":{"165":1}}],["编译器中的大多数遍都消费ir",{"2":{"165":1}}],["编译器中的大多数遍历过程读取并操作这种中间表示",{"2":{"132":1}}],["编译器中的核心数据结构是其所编译程序的表示形式",{"2":{"132":1}}],["编译器依赖ir来表示程序",{"2":{"132":1}}],["编译器两大原则",{"2":{"98":1}}],["编译器报错",{"2":{"33":1}}],["编程语言使用类型来定义合法和非法的行为",{"2":{"235":1}}],["编程语言对于结构体声明文本是否也定义了结构体的布局有不同的处理方式",{"2":{"234":1}}],["编程语言也在代码中声明必须出现的位置上有所不同",{"2":{"233":1}}],["编程语言在是否需要声明上有所不同",{"2":{"233":1}}],["编程语言通过各种可见性约束来支持静态变量",{"2":{"203":1}}],["编程语言提供了控制名称的生命周期和可见性的机制",{"2":{"201":1}}],["编程语言的基础类型为处理器实际支持的数据种类提供了一种抽象",{"2":{"191":1}}],["编程语言引入了规则来规定名称的特定声明在何处既有效又可见",{"2":{"139":1}}],["程序入口点",{"2":{"207":1}}],["程序可以为每个静态变量实现单独的数据区",{"2":{"203":1}}],["程序可能会有多种含义",{"2":{"139":1}}],["程序是由过程组成的",{"2":{"183":1}}],["程序员和编译器在每次过程调用时都需要理解被调用者的代码",{"2":{"183":1}}],["程序员可以使用任意名称作为字段名",{"2":{"234":1}}],["程序员可以使用形式参数在过程中将调用者的命名空间中的值和变量映射到被调用者的命名空间中",{"2":{"183":1}}],["程序员可以在过程内部声明新的名称",{"2":{"183":1}}],["程序员可以定义新的名称",{"2":{"172":1}}],["程序员使用字符串的哈希值对表大小取模的结果作为进入表的索引",{"2":{"139":1}}],["程序的命名空间可以包含多个子空间",{"2":{"172":1}}],["程序转换为ssa形式",{"2":{"155":1}}],["程序假如识别dfa的时候",{"2":{"112":1}}],["概念性路线图",{"0":{"148":1}}],["概念上",{"2":{"139":1}}],["概述",{"0":{"132":1,"165":1},"1":{"148":1,"165":1}}],["详细计算步骤",{"0":{"179":1}}],["详见第192页的题外话",{"2":{"139":1}}],["详情可看视频",{"2":{"53":1}}],["符号表和以层级方式链接表的搜索路径",{"2":{"201":1}}],["符号表和显式的搜索路径来构建适当的模型",{"2":{"201":1}}],["符号表通常使用哈希映射来实现",{"2":{"139":1}}],["符号表的主要作用是解析名称",{"2":{"139":1}}],["符号表有两个主要组成部分",{"2":{"139":1}}],["符号表",{"0":{"139":1}}],["符号串γ",{"2":{"131":1}}],["双地址码模拟了一种具有破坏性操作的机器",{"2":{"136":1}}],["条件分支",{"2":{"207":1}}],["条件分支指令",{"2":{"207":1}}],["条件分支后的第一条指令",{"2":{"207":1}}],["条件分支只使用一个标签",{"2":{"136":1}}],["条件赋值",{"2":{"155":1}}],["条件变量常用在什么方面",{"2":{"37":1}}],["块或结构声明",{"2":{"204":1}}],["块分隔符",{"2":{"190":1}}],["块在分支处",{"2":{"136":1}}],["块展开",{"2":{"37":1}}],["汇编语言程序是一种线性代码的形式",{"2":{"136":1}}],["成本是o",{"2":{"231":1}}],["成为衍生的",{"2":{"206":1}}],["成为了这些平台开发工具的一部分",{"2":{"110":1}}],["成员只能在定义它们的类内部访问",{"2":{"201":1}}],["成员只能在定义它们的类内部",{"2":{"201":1}}],["成员可以被任何其他类访问",{"2":{"201":1}}],["成员名称可以在继承层次结构中找到",{"2":{"201":1}}],["成的终结符进行匹配",{"2":{"134":1}}],["线性的操作序列",{"2":{"149":1}}],["线性列表可能是有意义的",{"2":{"139":1}}],["线性列表的主要缺点是每次查找所需的时间为",{"2":{"139":1}}],["线性列表构造",{"2":{"139":1}}],["线性列表",{"2":{"139":1}}],["线性代码通常既包括无条件跳转也包括条件分支",{"2":{"136":1}}],["线性ir则引导人们以顺序迭代操作的方式来自然地组织遍次",{"2":{"149":1}}],["线性ir类似于某些抽象机器的伪代码",{"2":{"149":1}}],["线性ir中的控制流通常模拟目标机上控制流的实现",{"2":{"136":1}}],["线性ir对操作序列施加了全序关系",{"2":{"136":1}}],["线性ir以有序的操作系列来表示程序",{"2":{"136":1}}],["线性ir",{"0":{"136":1},"1":{"152":1,"169":1,"186":1,"199":1,"207":1,"213":1,"219":1}}],["线性ir及这两种形式的混合体",{"2":{"132":1}}],["线程什么时候用栈",{"2":{"33":1}}],["线程会共享栈和堆吗",{"2":{"33":1}}],["线程块平铺的逻辑视图",{"2":{"29":1}}],["线程中",{"2":{"29":1}}],["线程重排",{"2":{"16":1}}],["控制权返回给调用者",{"2":{"183":1}}],["控制流",{"0":{"229":1}}],["控制流图与其他图形化ir的关系",{"2":{"206":1}}],["控制流图在编译器中有多种重要用途",{"2":{"206":1}}],["控制流图的主要特点包括",{"2":{"206":1}}],["控制流图由基本块",{"2":{"206":1}}],["控制流图",{"0":{"206":1},"2":{"206":1}}],["控制流图区分",{"2":{"131":1}}],["控制流要么流向该标签",{"2":{"136":1}}],["控制流在线性ir中划分了基本块",{"2":{"136":1}}],["控制方向",{"2":{"43":1}}],["∪",{"2":{"131":1,"221":1}}],["→β1​∣β2​∣",{"2":{"184":1}}],["→β1∣β2∣",{"2":{"184":1}}],["→b∣c",{"2":{"184":1}}],["→b∣ca",{"2":{"184":1}}],["→∗ft",{"2":{"153":2}}],["→+te",{"2":{"153":2}}],["→α1​a",{"2":{"150":1}}],["→α1a",{"2":{"150":1}}],["→αa",{"2":{"150":2}}],["→aab",{"2":{"167":4}}],["→aa",{"2":{"150":2}}],["→as",{"2":{"150":2}}],["→abc",{"2":{"147":5}}],["→ab",{"2":{"147":1}}],["→saaa",{"2":{"150":1}}],["→saa",{"2":{"150":1}}],["→",{"2":{"131":1,"146":6,"150":2,"153":2,"163":3,"170":2,"174":8,"179":9,"188":3,"195":12}}],["终端符号对应于扫描器返回的语法类别",{"2":{"131":1}}],["供编译器的其余部分使用",{"2":{"131":1}}],["恰好满足了绝大多数实际编程语言的需求",{"2":{"130":1}}],["鲜少出现介于两者之间的灰色地带",{"2":{"130":1}}],["已经采用了两种不同的方法",{"2":{"180":1}}],["已经把他覆盖了",{"2":{"155":1}}],["已经使用了许多种类的线性中间表示",{"2":{"136":1}}],["已经使得其他自底向上解析策略",{"2":{"130":1}}],["已经有序的情况下",{"2":{"46":1}}],["涵盖了所有可由上下文无关文法",{"2":{"130":1}}],["改变解析器",{"2":{"196":1}}],["改变语法使得表大小减少了48",{"2":{"163":1}}],["改变语法不能缩短输入程序",{"2":{"129":1}}],["改写后的文法消除了左公共因子",{"2":{"184":1}}],["改写后的文法消除了直接左递归",{"2":{"150":1}}],["改写后的文法为",{"2":{"150":1}}],["改写文法",{"2":{"150":1,"184":1}}],["改进模型",{"2":{"67":1}}],["利用运行时栈来分配新的活动记录",{"2":{"187":1}}],["利用现有的解析器生成工具",{"2":{"130":1}}],["利用",{"2":{"127":1,"188":1}}],["利润",{"2":{"106":1}}],["利润初始化为0",{"2":{"50":1}}],["算法依赖于这样的观察",{"2":{"181":1}}],["算法接受的语法类别比规范的lr",{"2":{"181":1}}],["算法要小",{"2":{"181":1}}],["算法迭代简单",{"2":{"149":1}}],["算法将所有从",{"2":{"127":1}}],["算法将子集构造应用于这个nfa",{"2":{"123":1}}],["算法假设dfa的状态编号从",{"2":{"127":1}}],["引言介绍",{"0":{"183":1}}],["引入新的非终结符",{"2":{"184":1}}],["引入新非终结符a",{"2":{"150":1,"184":1}}],["引入了一张图",{"2":{"127":1}}],["引用可能会创建一个具有该名称的本地实体",{"2":{"190":1}}],["引用会触发沿当前作用域的搜索路径进行查找",{"2":{"190":1}}],["引用visited数组中当前状态的结果",{"2":{"58":1,"68":1}}],["引用内容",{"2":{"21":2}}],["避免了大量的比较操作",{"2":{"124":1}}],["避免bank",{"0":{"19":1}}],["接受名称作为输入",{"2":{"194":1}}],["接受",{"2":{"174":1,"179":1,"195":2}}],["接受或报告错误等操作",{"2":{"163":1}}],["接受或报错",{"2":{"144":1}}],["接下来",{"2":{"123":1,"139":1,"155":1,"201":1}}],["接着它可以细化ir",{"2":{"238":1}}],["接着来讨论类的继承性的可见性",{"2":{"201":1}}],["接着他举了一个for循环的例子",{"2":{"46":1}}],["接着又问了简历上的了解tvm",{"2":{"46":1}}],["接着又反问我",{"2":{"43":1}}],["接着就是内存的访问速率",{"2":{"46":1}}],["接着就是手撕",{"2":{"41":1}}],["接着我就想到了分片",{"2":{"46":1}}],["接着问我和标准库比较过没有",{"2":{"46":1}}],["逐步归约到起始符号",{"2":{"142":1}}],["逐步构建语法树的解析方法",{"2":{"142":1}}],["逐步将输入串分解为更大的子串",{"2":{"121":1}}],["逐步将输入串分解为更小的子串",{"2":{"121":1}}],["逐步计算出每天的最小花费",{"2":{"63":1}}],["描述下列有限自动机接受的语言",{"2":{"119":1}}],["练习题答案",{"0":{"119":1}}],["∗rkjk−1​",{"2":{"127":1}}],["∗rkjk−1",{"2":{"127":1}}],["∗",{"2":{"118":4,"141":2,"188":2}}],["∗aα",{"2":{"188":2}}],["∗a",{"2":{"118":2}}],["∗suf",{"2":{"88":3}}],["称为thompson",{"2":{"118":1}}],["称为有限自动机",{"2":{"102":1}}],["扫描器的交互",{"2":{"196":1}}],["扫描器的实现",{"0":{"116":1,"124":1},"1":{"124":1}}],["扫描器在每种情况下返回一个独特的语法类别",{"2":{"180":1}}],["扫描器可以根据它们的声明类型而非微观语法对标识符进行分类",{"2":{"180":1}}],["扫描器无疑在这两种情况下都会将fee分类为一个名称",{"2":{"180":1}}],["扫描器",{"2":{"163":1}}],["扫描器会对每个字符进行一次测试",{"2":{"102":1}}],["属于",{"2":{"115":1}}],["规约动作发生在dfa到达一个终态时",{"2":{"195":1}}],["规范集合cc代表了文法的句柄查找有穷状态自动机",{"2":{"195":1}}],["规定任何一个单一集合要么包含接受状态",{"2":{"115":1}}],["规则很简单",{"2":{"194":1}}],["规则",{"2":{"155":1,"175":1}}],["规则二",{"2":{"115":1}}],["规则一规定",{"2":{"115":1}}],["∀c∈∑",{"2":{"115":1}}],["忙面试去了",{"2":{"114":1}}],["虚拟寄存器",{"2":{"218":1}}],["虚拟寄存器都是只读的",{"2":{"155":1}}],["虚拟内存布局",{"0":{"216":1}}],["虚拟架构",{"2":{"114":1}}],["虚函数",{"2":{"41":1}}],["虚函数说错了",{"2":{"39":1}}],["架构的",{"2":{"114":1}}],["域",{"2":{"113":1}}],["补充",{"2":{"113":1}}],["该变量在其值跨多次调用过程中保持不变",{"2":{"203":1}}],["该类的子类以及同一个包内的其他类中访问",{"2":{"201":1}}],["该状态位于栈中句柄左端之下",{"2":{"195":1}}],["该代码假定",{"2":{"194":1}}],["该过程被称为函数",{"2":{"183":1}}],["该过程可以调用其他非终结符的过程及match",{"2":{"134":1}}],["该调用会创建并初始化过程本地存储",{"2":{"183":1}}],["该方案会将问题推迟到后续的翻译阶段",{"2":{"180":1}}],["该值在作用域内定义和使用",{"2":{"175":1}}],["该值对应于控制进入该块时所沿的边",{"2":{"155":1}}],["该语法生成了一个更小的冲突集",{"2":{"163":1}}],["该语法规则防止程序员书写",{"2":{"162":1}}],["该子串出现在栈顶",{"2":{"161":1}}],["该子串与产生式右部完全匹配",{"2":{"161":1}}],["该寄存器可能不会被更新为新的值",{"2":{"157":1}}],["该文法是左递归的",{"2":{"150":1}}],["该图显示了该算法直接应用于thompson构造为表达式",{"2":{"141":1}}],["该构造逐步建立集合",{"2":{"113":1}}],["该集合对应于dfa中一个已有状态",{"2":{"113":1}}],["该例程返回连续的字符",{"2":{"102":1}}],["针对每个dfa状态",{"2":{"113":1}}],["针对上面的内存优化",{"2":{"11":1}}],["保存一部分也可能就足够了",{"2":{"187":1}}],["保存调用者的运行时环境并创建被调用者环境",{"2":{"183":1}}],["保留了较多语法细节",{"2":{"192":1}}],["保留了解析树的结构和含义",{"2":{"185":1}}],["保留较多语法细节",{"2":{"176":2}}],["保持了dfa明确的接受机制",{"2":{"112":1}}],["保证了语法分析的正确顺序",{"2":{"161":1}}],["保证",{"2":{"23":1,"88":1}}],["苹果公司雇用了克里斯",{"2":{"110":1}}],["旨在为所有静态和动态语言创建动态编译技术",{"2":{"110":1}}],["拉特纳及其团队为",{"2":{"110":1}}],["拉特纳",{"2":{"110":1}}],["艾夫",{"2":{"110":1}}],["香槟分校的维克拉姆",{"2":{"110":1}}],["年",{"2":{"110":1}}],["年伊利诺伊大学厄巴纳",{"2":{"110":1}}],["年提出",{"2":{"67":1}}],["取地址",{"2":{"162":1}}],["取分支",{"2":{"136":1}}],["取当前能到达的最远点",{"2":{"107":1}}],["取最大值",{"2":{"103":1}}],["思路其实很简单",{"2":{"107":1}}],["思路照搬",{"2":{"74":1}}],["步到达最后一个下标",{"2":{"107":1}}],["步",{"2":{"107":1}}],["本地变量通常默认是自动的",{"2":{"175":1}}],["本书使用的iloc代码是一种线性ir的形式",{"2":{"149":1}}],["本章将重点介绍编译器如何实现过程和方法",{"2":{"183":1}}],["本章将对编译器使用的ir进行综述",{"2":{"132":1}}],["本章前面介绍的规范lr",{"2":{"181":1}}],["本章专注于一种常用的机制",{"2":{"159":1}}],["本章关注于编译中ir设计和使用相关的问题",{"2":{"148":1}}],["本节将描述其中的三种方法",{"2":{"163":1}}],["本节将审视解析器构建中的两个具体问题",{"2":{"129":1}}],["本节介绍书中所描述的一些解析器的实用性主题",{"2":{"128":1}}],["本节介绍如何将nfa转换为dfa",{"2":{"113":1}}],["本节开发了将正则表达式转换为有限自动机的构造方法",{"2":{"112":1}}],["本质上是赌神",{"2":{"112":1}}],["本质上",{"2":{"112":1}}],["本题子数组不能为空",{"2":{"106":1}}],["本人从中受益良多",{"2":{"5":1}}],["注",{"2":{"106":1}}],["注意事项",{"0":{"219":1}}],["注意与后面的cfg",{"2":{"131":1}}],["注意代码第7行的判断",{"2":{"107":1}}],["注意利润不能是",{"2":{"104":1}}],["注意这题与上题的差异",{"2":{"87":1}}],["注意这里是引用",{"2":{"53":1}}],["注意这里考虑卖出并没有考虑买入的价格",{"2":{"50":1}}],["注意",{"2":{"50":1,"62":1,"73":1,"76":1,"78":1}}],["⋃i=0∞​ri",{"2":{"105":1}}],["⋃i=0∞rir^",{"2":{"105":1}}],["集合",{"2":{"105":1,"188":1}}],["集合字符前面",{"2":{"105":1}}],["闭包使得我们可以创建灵活的函数对象",{"2":{"183":1}}],["闭包的典型使用场景",{"2":{"183":1}}],["闭包的概念",{"2":{"33":1}}],["闭包是一个函数对象",{"2":{"183":1}}],["闭包并集",{"2":{"113":1}}],["闭包",{"2":{"113":1,"183":2}}],["闭包运算",{"2":{"105":1}}],["连同其衍生形式如slr",{"2":{"130":1}}],["连接运算",{"2":{"105":1}}],["连续的",{"2":{"182":1}}],["连续子数组",{"2":{"106":1}}],["连续minutes下的人数",{"2":{"103":1}}],["连续",{"2":{"93":1}}],["∣γ1​∣",{"2":{"184":1}}],["∣γ1∣",{"2":{"184":1}}],["∣γm​",{"2":{"184":2}}],["∣γma",{"2":{"184":2}}],["∣cb",{"2":{"167":4}}],["∣id",{"2":{"153":1}}],["∣idf",{"2":{"153":1}}],["∣ba",{"2":{"150":2}}],["∣d",{"2":{"184":1}}],["∣da",{"2":{"150":2,"184":1}}],["∣d∣−1|d|",{"2":{"127":1}}],["∣αβn​∣γ1​∣",{"2":{"184":1}}],["∣αβn∣γ1∣",{"2":{"184":1}}],["∣αn​a",{"2":{"150":1}}],["∣αna",{"2":{"150":1}}],["∣α2​a",{"2":{"150":1}}],["∣α2a",{"2":{"150":1}}],["∣",{"2":{"150":4}}],["∣βn​",{"2":{"184":1}}],["∣βna",{"2":{"184":1}}],["∣βk​是aia",{"2":{"167":1}}],["∣βk​α",{"2":{"167":1}}],["∣βka",{"2":{"167":1}}],["∣βkαa",{"2":{"167":1}}],["∣β2​a",{"2":{"150":1}}],["∣β2a",{"2":{"150":1}}],["∣βm​a",{"2":{"150":1}}],["∣βm​",{"2":{"150":1}}],["∣βma",{"2":{"150":2}}],["∣aαn​∣β1​∣β2​∣",{"2":{"150":1}}],["∣aαn∣β1∣β2∣",{"2":{"150":1}}],["∣ϵb",{"2":{"167":2}}],["∣ϵt",{"2":{"153":1}}],["∣ϵe",{"2":{"153":1}}],["∣ϵa",{"2":{"150":2}}],["∣ϵa^",{"2":{"150":1}}],["∣ϵ",{"2":{"150":4,"153":2,"167":2}}],["∣ϵs",{"2":{"150":1}}],["∣ε",{"2":{"131":1}}],["∣εs",{"2":{"131":1}}],["∣|∣",{"2":{"105":1}}],["∣v∣×d|v|",{"2":{"67":1}}],["∣v∣|v|∣v∣",{"2":{"67":1}}],["εβ=∗ε",{"2":{"188":1}}],["εβ→∗ε",{"2":{"188":1}}],["εεε",{"2":{"153":3}}],["ε∈first",{"2":{"153":4,"170":2,"188":2}}],["εx→ε",{"2":{"153":1}}],["ε−clousure",{"2":{"113":2}}],["ε−closure",{"2":{"113":4}}],["ε−",{"2":{"113":2}}],["ε",{"2":{"105":1,"112":3,"113":2,"123":1,"127":1,"153":6,"170":2,"188":2}}],["转成",{"2":{"155":1}}],["转移到一个可以继续进行解析的状态",{"2":{"145":1}}],["转移",{"2":{"123":1}}],["转换为ssa形式后",{"2":{"214":1}}],["转换权威的",{"2":{"198":1}}],["转换和计算字符串长度",{"2":{"209":1}}],["转换和翻译代码的一个或多个",{"2":{"182":1}}],["转换和优化的代码",{"2":{"165":1}}],["转换到达的任何状态",{"2":{"113":1}}],["转换图一般来说是复杂的和非直观的",{"2":{"105":1}}],["转化为外积计算",{"2":{"23":1}}],["正确处理间接跳转",{"2":{"219":1}}],["正闭包代表",{"2":{"105":1}}],["正则表达式不能描述",{"2":{"131":1}}],["正则表达式只能描述有限的语法结构",{"2":{"131":1}}],["正则表达式可以表示任何可以用有限自动机识别的语言",{"2":{"112":1}}],["正则表达式",{"0":{"105":1}}],["正式的fa定义是一个五元组包含",{"2":{"102":1}}],["正式邮件offer",{"2":{"56":1}}],["正式拿下腾讯机器学习平台部的offer",{"2":{"26":1}}],["结合使用",{"2":{"206":2}}],["结果是规范项目集的集合状态更少",{"2":{"181":1}}],["结果就可以了",{"2":{"104":1}}],["结构等价性断言两个类型只有在它们具有相同的结构时才是等价的",{"2":{"230":1}}],["结构体声明中的每个字段都在结构体内分配空间",{"2":{"234":1}}],["结构体与对象",{"0":{"234":1}}],["结构体与聚合",{"0":{"221":1}}],["结构体的类型是其包含元素类型的有序乘积",{"2":{"221":1}}],["结构体的元素通常被赋予明确的名称",{"2":{"221":1}}],["结构体",{"2":{"221":1}}],["结构",{"2":{"75":1,"139":1,"206":1}}],["进行注解时",{"2":{"212":1}}],["进行展开",{"2":{"188":1}}],["进行归约",{"2":{"142":1}}],["进行迭代",{"2":{"127":1}}],["进行相减",{"2":{"104":1}}],["进入build目录",{"2":{"114":1}}],["进入llvm",{"2":{"114":1}}],["进程线程的区别",{"2":{"33":1}}],["获得最小值和最大值",{"2":{"104":1}}],["获取词向量",{"2":{"67":1,"75":1}}],["获取硬币数组的长度",{"2":{"58":1,"68":1}}],["获取并打印",{"2":{"41":1}}],["获取线程的唯一id",{"2":{"4":1,"7":1}}],["卖出价格",{"2":{"106":1}}],["卖出该股票",{"2":{"104":1}}],["卖出股票或者什么都不做",{"2":{"50":1}}],["卖出股票利润为",{"2":{"50":1}}],["未限定名称则可以在词法层次结构中找到",{"2":{"201":1}}],["未命中时",{"2":{"187":1}}],["未命中时沿类层次结构向上搜索",{"2":{"187":1}}],["未显示",{"2":{"187":1}}],["未优化的代码可能会使用比目标机器提供的多得多的虚拟寄存器",{"2":{"143":1}}],["未优化的代码形式可能只会使用少数几个寄存器",{"2":{"143":1}}],["未完待续",{"2":{"114":1}}],["未来的某一个不同的日子",{"2":{"104":1}}],["未登录词无向量表示",{"2":{"67":1}}],["感到满意的最大客户数量",{"2":{"103":1}}],["感觉他挺满意的",{"2":{"46":1}}],["感觉还挺好的",{"2":{"41":1}}],["感觉面试官很想让我去的",{"2":{"22":1}}],["感觉面试手撕题也就从中出了",{"2":{"8":1}}],["能够处理更广泛的语法形式",{"2":{"142":1}}],["能表示给定结构的固定次数的重复或者没有指定次数的重复",{"2":{"131":1}}],["能抑制自己的情绪",{"2":{"103":1}}],["能接受该字符串",{"2":{"102":1}}],["书店老板在最后",{"2":{"103":1}}],["书店老板知道一个秘密技巧",{"2":{"103":1}}],["书店老板会生气",{"2":{"103":1}}],["更重要的是",{"2":{"212":1}}],["更微妙的问题也可能出现",{"2":{"204":1}}],["更复杂的情况",{"2":{"201":1}}],["更复杂的形式可以通过调用支持库来实现",{"2":{"173":1}}],["更糟糕的是",{"2":{"157":1}}],["更新状态栈和符号栈",{"2":{"144":1}}],["更新窗口大小",{"2":{"100":1}}],["更强大",{"2":{"142":1}}],["更正式地来描述",{"2":{"115":1}}],["更正式的说",{"2":{"102":1}}],["δ",{"2":{"102":13,"113":4}}],["∑j=leftrightnums",{"2":{"106":1}}],["∑",{"2":{"102":3,"105":1}}],["长度为",{"2":{"101":3}}],["长时间不约二面等于挂了",{"2":{"39":1}}],["起始索引等于",{"2":{"99":5}}],["包级私有",{"2":{"201":1}}],["包括嵌套的作用域",{"2":{"203":1}}],["包括fortran",{"2":{"180":1}}],["包括变量的地址或传递给定参数的寄存器编号",{"2":{"165":1}}],["包括自增",{"2":{"162":1}}],["包括简单且高效的扩展",{"2":{"139":1}}],["包括命名值",{"2":{"139":1}}],["包括图形ir",{"2":{"132":1}}],["包括前缀",{"2":{"106":1}}],["包括相同的字符串",{"2":{"99":1}}],["包含由对象的类指定的数据成员",{"2":{"236":1}}],["包含一个与局部数据区起始位置固定距离的地址",{"2":{"218":1}}],["包含一个操作符",{"2":{"169":1}}],["包含了iloc代码",{"2":{"218":1}}],["包含所有细节",{"2":{"176":1}}],["包含所有语法细节",{"2":{"176":1,"192":1}}],["包含所有非终结符和终结符",{"2":{"176":1}}],["包含非终结符和终结符",{"2":{"176":1}}],["包含错误状态",{"2":{"102":1}}],["包含两种主要结构",{"2":{"67":1}}],["异位词",{"2":{"99":2}}],["异步io我知道",{"2":{"39":1}}],["异步io",{"2":{"39":1}}],["发现没有得到新的状态",{"2":{"113":1}}],["发现在没有生词的情况下阅读并不会产生困难",{"2":{"97":1}}],["发生",{"2":{"19":1}}],["跳转到if",{"2":{"223":1}}],["跳转指令",{"2":{"207":1}}],["跳转目标",{"2":{"207":1}}],["跳转处或标记操作之前结束",{"2":{"136":1}}],["跳",{"2":{"107":1}}],["跳跃游戏",{"0":{"95":1,"107":1},"1":{"107":1}}],["跳表我印象中就是一个高效的数据结构",{"2":{"39":1}}],["尽管这是一个隐式的",{"2":{"202":1}}],["尽管细节不同",{"2":{"181":1}}],["尽管其结构使得人类几乎无法阅读",{"2":{"163":1}}],["尽管可能性不大但确实存在",{"2":{"139":1}}],["尽管有更复杂的解析选项可用",{"2":{"130":1}}],["尽管有很多看过听过",{"2":{"39":1}}],["尽量不要在业务代码中使用",{"2":{"93":1}}],["码为",{"2":{"93":2}}],["码二进制最低位的值",{"2":{"93":1}}],["次操作得到",{"2":{"93":1}}],["黑色块",{"2":{"93":1}}],["黑色块的数目",{"2":{"93":1}}],["涂成",{"2":{"93":1}}],["爱生气的书店老板",{"0":{"91":1,"103":1},"1":{"103":1}}],["移进动作模拟了句柄查找dfa中的步骤",{"2":{"195":1}}],["移进",{"2":{"174":3,"179":2,"195":6}}],["移交g",{"2":{"157":1}}],["移交到内存可以让寻址硬件决定哪些赋值应该改变x",{"2":{"157":1}}],["移出窗口",{"2":{"90":1}}],["移动完之后",{"2":{"41":1}}],["移动语义",{"2":{"41":1}}],["来创建文件级别的可见性",{"2":{"203":1}}],["来改变其类结构",{"2":{"201":1}}],["来揭示冗余",{"2":{"198":1}}],["来对",{"2":{"188":1}}],["来对声明为",{"2":{"162":1}}],["来自超类链中祖先的数据成员保留一致的偏移量",{"2":{"236":1}}],["来自先前执行的轮廓数据以及让调试器理解代码及其数据的地图",{"2":{"205":1}}],["来自colorpoint类",{"2":{"187":1}}],["来自point类",{"2":{"187":1}}],["来保存状态",{"2":{"187":1}}],["来保存其类型信息",{"2":{"173":1}}],["来决定进行规约还是移进",{"2":{"174":1}}],["来处理控制流合并点处的变量赋值",{"2":{"171":1}}],["来说",{"2":{"155":1}}],["来减少冲突",{"2":{"142":2}}],["来描述编程语言的语法结构",{"2":{"131":1}}],["来计算",{"2":{"127":1}}],["来编译运行",{"2":{"114":1}}],["来表示描述所有从",{"2":{"127":1}}],["来表示这个并集",{"2":{"113":1}}],["来表示",{"2":{"105":1}}],["来判断是否符合单词",{"2":{"102":1}}],["来实现这样的目的",{"2":{"210":1}}],["来实现",{"2":{"90":1,"101":1}}],["来代表当前完成第几笔交易",{"2":{"62":1}}],["判断你是否能够到达最后一个下标",{"2":{"107":1}}],["判断几乎唯一这个条件可以使用",{"2":{"90":1}}],["判断数字是否在",{"2":{"66":1}}],["于是",{"2":{"88":1}}],["换句话说",{"2":{"88":1}}],["所暴露的细节",{"2":{"166":1}}],["所产生的解析器可以在缓存和虚拟内存中表现出强大的局部性",{"2":{"163":1}}],["所产生的语法仍然是lr",{"2":{"162":1}}],["所有这些信息都应该以一种能够清晰表达它们与ir中特定点关系的方式来呈现",{"2":{"205":1}}],["所有这些顾客在第i分钟结束后离开",{"2":{"103":1}}],["所有未定义的条目标记为error",{"2":{"188":1}}],["所有变量生命周期重叠的最多的数量是多少",{"2":{"155":1}}],["所有的项集如下",{"2":{"195":1}}],["所有的point",{"2":{"187":1}}],["所有的",{"2":{"155":1}}],["所有的虚拟寄存器只能在定义的地方赋值",{"2":{"155":1}}],["所有寄存器只能赋值一次",{"2":{"155":1}}],["所有能优化成的",{"2":{"155":1}}],["所提供的解析能力已经足够强大",{"2":{"130":1}}],["所示的简化表达式语法",{"2":{"163":1}}],["所示",{"2":{"123":1,"129":4}}],["所对应的数据和",{"2":{"87":1}}],["所以遇到",{"2":{"188":1}}],["所以表的列也较少",{"2":{"163":1}}],["所以永远不可能到达最后一个下标",{"2":{"107":1}}],["所以求出",{"2":{"106":1}}],["所以最大利润为",{"2":{"104":1}}],["所以最近准备复习一下",{"2":{"8":1}}],["所以其长度为",{"2":{"100":3}}],["所以我们返回",{"2":{"90":1,"93":2}}],["所以我们可以把共享内存的大小设为blockdim对应的大小",{"2":{"7":1}}],["所以前两个数肯定没有问题的",{"2":{"87":1}}],["所以要注意的是",{"2":{"78":1}}],["所以这个题目要注意的是",{"2":{"69":1}}],["所以以",{"2":{"66":1}}],["所以不存在几乎唯一子数组",{"2":{"90":1}}],["所以不参与交易可以获得最大利润",{"2":{"50":1}}],["所以不能对他缓存进行编程",{"2":{"46":1}}],["所以也是没有",{"2":{"29":1}}],["所以",{"2":{"29":1}}],["所以把数据先搬运到更高速的存储上",{"2":{"23":1}}],["所以是",{"2":{"19":1}}],["所以应该等待所有的线程都完成了共享内存读取",{"2":{"7":1}}],["所以进行了分块",{"2":{"7":1}}],["所以塌的访问速度要大于全局内存的访问速度",{"2":{"7":1}}],["所以通过上述代码中计算的row",{"2":{"4":1}}],["仔细想想最多只出现两次",{"2":{"87":1}}],["代数符号还包括一元运算符",{"2":{"162":1}}],["代表一个状态的集合中的核心项目是关键的",{"2":{"181":1}}],["代表一个nfa",{"2":{"123":1}}],["代表了r的从0到正无穷的重复操作",{"2":{"105":1}}],["代表了可接受的状态",{"2":{"102":1}}],["代表了设计的初始状态",{"2":{"102":1}}],["代表了识别器的状态转移函数",{"2":{"102":1}}],["代表了识别器的有限集合",{"2":{"102":1}}],["代表了识别的有限的字母表",{"2":{"102":1}}],["代表遍历的位置",{"2":{"87":1}}],["代表写入的位置",{"2":{"87":1}}],["代码显式地为它们分配空间",{"2":{"210":1}}],["代码使用两个构造函数来构建节点",{"2":{"194":1}}],["代码优化和代码生成",{"2":{"176":1}}],["代码可以读取或写入该值",{"2":{"175":1}}],["代码可以直接丢弃词直到它找到一个分号",{"2":{"145":1}}],["代码生成器中的遍可能是例外",{"2":{"165":1}}],["代码的形式以及优化器和后端的优先事项有着强烈的影响",{"2":{"143":1}}],["代码的输出我私下也跑过了",{"2":{"39":1}}],["代码会拒绝该字符串并尝试其他操作",{"2":{"102":1}}],["代码依次测试字符",{"2":{"102":1}}],["代码中的标签",{"2":{"139":1}}],["代码中的注释部分是计算前缀的方法",{"2":{"88":1}}],["代码中已经进一步优化了计算",{"2":{"7":1}}],["代码示例",{"2":{"75":1}}],["代码我放在下面",{"2":{"43":1}}],["代码分组",{"2":{"21":1}}],["代码",{"2":{"21":1,"194":1}}],["此翻译方案将构建如边栏所示的简单",{"2":{"194":1}}],["此参数信息会放入被调用者的ar中",{"2":{"187":1}}],["此技术接受了众多具有实际兴趣的语法",{"2":{"181":1}}],["此外",{"2":{"130":1,"141":1,"187":1}}],["此时",{"2":{"173":1,"195":1}}],["此时从所有路径中",{"2":{"127":1}}],["此时应当初始化",{"2":{"87":1}}],["此切片在代码中称为",{"2":{"29":1}}],["额外空间的条件下完成",{"2":{"87":1}}],["额外步骤会增加预处理复杂度",{"2":{"47":1}}],["看成",{"2":{"93":2}}],["看两个区间是否有重叠",{"2":{"84":1}}],["看未来远不如看过去",{"2":{"63":1}}],["几乎不会限制语言的表达能力",{"2":{"162":1}}],["几乎唯一",{"2":{"90":1}}],["几乎唯一子数组的最大和",{"0":{"82":1,"90":1},"1":{"90":1}}],["几千g",{"2":{"46":1}}],["除非方法被声明为虚方法",{"2":{"187":1}}],["除非代码明确地将它们移至内存",{"2":{"152":1}}],["除自身以外数组的乘积",{"0":{"81":1,"88":1},"1":{"88":1}}],["除了new",{"2":{"33":1}}],["开发工具",{"2":{"110":1}}],["开始如果下一个字符是",{"2":{"112":1}}],["开始",{"2":{"106":1,"203":1}}],["开始的长度为",{"2":{"101":1}}],["开始枚举",{"2":{"78":2}}],["开头的网络",{"2":{"33":1}}],["选择哪一种方法是由语言设计者决定的",{"2":{"230":1}}],["选择作为其参数的那个值",{"2":{"155":1}}],["选或者不选",{"2":{"76":1}}],["选址过程",{"2":{"33":1}}],["考虑边栏中显示的c结构声明",{"2":{"230":1}}],["考虑函数调用和返回",{"2":{"219":1}}],["考虑使用图5",{"2":{"217":1}}],["考虑一种源语言",{"2":{"204":1}}],["考虑一个简单文法s→sa∣bs",{"2":{"150":1}}],["考虑两个类",{"2":{"236":1}}],["考虑两个不同的场景",{"2":{"201":1}}],["考虑两种情况",{"2":{"76":1}}],["考虑以下代码",{"2":{"214":1}}],["考虑以下线性代码",{"2":{"213":1}}],["考虑以下简单语法",{"2":{"174":1}}],["考虑以下文法",{"2":{"164":1}}],["考虑以i为结尾的最长递增子序列长度",{"2":{"53":1}}],["考虑向经典的表达式语法中添加一个一元绝对值运算符",{"2":{"162":1}}],["考虑图",{"2":{"155":1}}],["考虑经典的左递归表达式语法",{"2":{"146":1}}],["考虑问题",{"2":{"87":1}}],["β=∗εβ=",{"2":{"188":1}}],["β→∗εβ→",{"2":{"188":1}}],["βa",{"2":{"179":1}}],["β",{"2":{"75":2,"131":2,"170":6,"179":1,"188":3,"195":1,"236":5}}],["γ",{"2":{"75":1,"179":2}}],["μ",{"2":{"75":1}}],["σ",{"2":{"75":3}}],["​=cos",{"2":{"75":1}}],["​=sin",{"2":{"75":1}}],["​",{"2":{"75":2}}],["随着节点和边的增多",{"2":{"212":1}}],["随着节点和边数量的增加",{"2":{"212":1}}],["随着解析器将输入流中的每个单词移进解析栈",{"2":{"195":1}}],["随着解析的进行",{"2":{"172":1}}],["随着编译器构建程序的ir形式",{"2":{"148":1}}],["随着编译器对其翻译的代码获取更多的知识",{"2":{"132":1}}],["随着破坏性操作和对ir大小的内存限制变得不再那么重要",{"2":{"136":1}}],["随机遮盖",{"2":{"75":1}}],["随后的ir遍历以执行更复杂的计算",{"2":{"159":1}}],["随后",{"2":{"50":1,"183":1}}],["随后拷打简历上的项目",{"2":{"41":1}}],["预测两个句子是否连续",{"2":{"75":1}}],["预训练任务",{"2":{"75":1}}],["预计记录学习编译器之间的笔记",{"0":{"12":1}}],["键",{"2":{"75":1,"187":3}}],["基本算术运算",{"0":{"220":1}}],["基本块的长度",{"0":{"212":1}}],["基本块识别",{"2":{"207":1}}],["基本块是连续执行的指令序列",{"2":{"206":1}}],["基本上意味着程序员希望根据接收者的类来定位实现",{"2":{"187":1}}],["基本上从简历入手",{"2":{"46":1}}],["基础类型通常不足以表示程序员所需的信息领域",{"2":{"191":1}}],["基于堆的实体是显式分配的",{"2":{"240":1}}],["基于堆栈的中间表示",{"2":{"143":1}}],["基于单语句块构建的",{"2":{"212":1}}],["基于栈的处理器已经被制造出来",{"2":{"152":1}}],["基于多头自注意力机制",{"2":{"75":1}}],["层归一化",{"2":{"75":1}}],["层",{"2":{"75":1}}],["层次结构形成一个有向无环图",{"2":{"201":1}}],["层次",{"2":{"67":1}}],["区分这两种情况需要了解fee声明的类型",{"2":{"180":1}}],["区分句子",{"2":{"75":1}}],["区间重叠了",{"2":{"84":1}}],["区间",{"2":{"84":2}}],["区别",{"2":{"37":1}}],["采用寄存器到寄存器的内存模型时",{"2":{"157":1}}],["采用从左到右扫描输入",{"2":{"156":1}}],["采用自顶向下的递归下降方法往往被视为一种合理且明智的选择",{"2":{"130":1}}],["采用双向",{"2":{"75":1}}],["采取共享内存的优化",{"2":{"7":1}}],["枚举类型的元素是有序的",{"2":{"215":1}}],["枚举类型让程序员可以为小集合的常量使用自文档化的名称",{"2":{"215":1}}],["枚举类型",{"0":{"215":1}}],["枚举类型以及结构体或记录",{"2":{"191":1}}],["枚举右边界",{"2":{"100":1}}],["枚举当前选哪个",{"2":{"73":1}}],["枚举选哪个的时候",{"2":{"78":1}}],["枚举选哪个元素",{"2":{"76":1}}],["枚举选哪个",{"2":{"69":1}}],["与使用最大长度块构建的",{"2":{"212":1}}],["与另一种中间表示",{"2":{"206":2}}],["与数据流图配合使用",{"2":{"206":1}}],["与算法语言类似",{"2":{"187":1}}],["与一个产生式关联的动作仅拥有在该产生式中命名的语法符号所关联的值的名字",{"2":{"178":1}}],["与最近的",{"2":{"164":1}}],["与原始语法的表及其384个条目相比",{"2":{"163":1}}],["与",{"2":{"75":1,"127":1}}],["与电话按键相同",{"2":{"73":1}}],["与此相关的还有float4优化",{"2":{"16":1}}],["电话号码的字母组合",{"0":{"73":1}}],["电话号码字母组合",{"0":{"61":1},"1":{"73":1}}],["左公共因子提取的通用形式",{"2":{"184":1}}],["左公共因子会导致预测分析时出现不确定性",{"2":{"184":1}}],["左公共因子是指多个产生式具有相同的前缀",{"2":{"184":1}}],["左公共因子",{"0":{"184":1}}],["左列假设加法采用内存操作数",{"2":{"143":1}}],["左边指针",{"2":{"103":1}}],["左边所有数的乘积",{"2":{"88":1}}],["左括号数量小于n",{"2":{"72":1}}],["左括号数量+右括号数量等于2n",{"2":{"72":1}}],["左括号的数量小于n",{"2":{"72":1}}],["左括号的数量大于右括号的数量",{"2":{"72":2}}],["左侧列",{"2":{"43":1}}],["每种方法都有其支持者和反对者",{"2":{"230":1}}],["每种方式都有其自身的优缺点",{"2":{"139":1}}],["每条边对应一个调用点",{"2":{"224":1}}],["每条边显示单个值的流动",{"2":{"218":1}}],["每条边",{"2":{"206":1}}],["每一次这样的替换都会移除一个终结符符号和一个产生式",{"2":{"163":1}}],["每一次操作中",{"2":{"93":1}}],["每次引用出现位置都会查询表以确定名称的属性",{"2":{"204":1}}],["每次调用都会为被调用者创建一个活动记录",{"2":{"187":1}}],["每次调用一个过程都有自己的局部数据区域",{"2":{"175":1}}],["每次过程调用都会产生一个新的激活记录或者称为调用记录",{"2":{"187":1}}],["每次通过添加通过",{"2":{"127":1}}],["每次迭代都会构建更长的路径",{"2":{"127":1}}],["每次nfa必须做出非确定性选择时",{"2":{"112":2}}],["每次更新最大和",{"2":{"106":1}}],["每次都要从0开始枚举",{"2":{"69":1}}],["每分钟都有一些顾客进入这家商店",{"2":{"103":1}}],["每个对象都有其自己的对象记录",{"2":{"236":1}}],["每个对象需要自己的对象记录",{"2":{"187":1}}],["每个不同的过程调用点有一条边",{"2":{"224":1}}],["每个程序都可以表现得好像它有自己的机器一样",{"2":{"216":1}}],["每个程序在其自己的虚拟地址空间中被隔离",{"2":{"216":1}}],["每个基本块结束于",{"2":{"207":1}}],["每个节点代表一个基本块",{"2":{"206":1}}],["每个节点",{"2":{"206":1}}],["每个实体都有自己的类型",{"2":{"191":1}}],["每个变量只被赋值一次",{"2":{"189":1}}],["每个方法调用都需要通过接收者的对象结构",{"2":{"187":1}}],["每个方块",{"2":{"29":1}}],["每个类的or包含一个类指针",{"2":{"187":1}}],["每个四元组用四个字段表示",{"2":{"186":1}}],["每个过程都有其私有的存储空间",{"2":{"183":1}}],["每个数据区域都与某个特定的作用域相关联",{"2":{"175":1}}],["每个未知类型的实体都需要一个运行时标签",{"2":{"173":1}}],["每个状态变成一个小的case语句或一系列if",{"2":{"163":1}}],["每个终结符符号都有其自己的列",{"2":{"163":1}}],["每个使用都指向单一的定义",{"2":{"155":1}}],["每个定义都有一个不同的名称",{"2":{"155":1}}],["每个子集保存其标识符的所有出现的元组",{"2":{"139":1}}],["每个代码块定义一个新的作用域",{"2":{"139":1}}],["每个补给站的食物每份的价格可能不同",{"2":{"63":1}}],["每个颜色的方块在每一列",{"2":{"29":1}}],["每个线程都有自己独立的栈",{"2":{"33":1}}],["每个线程",{"2":{"29":1}}],["每个线程访问不同的",{"2":{"19":1}}],["每个线程计算c中的tm",{"2":{"11":1}}],["每个",{"2":{"19":1,"29":1,"164":1}}],["题目数据",{"2":{"88":1}}],["题目数据保证结果符合",{"2":{"68":1}}],["题解多多少少都参考了灵神思路代码和题解",{"2":{"5":1}}],["仍影响深远",{"2":{"67":1}}],["等价树遍历",{"0":{"178":1}}],["等于",{"2":{"88":2}}],["等取代",{"2":{"67":1}}],["等后面有时间总结一下",{"2":{"34":1}}],["虽然实际实体的存储可能位于堆上",{"2":{"210":1}}],["虽然抽象语法树",{"2":{"198":1}}],["虽然这种方法提供了更大的灵活性",{"2":{"187":1}}],["虽然这些选择在很大程度上是独立的",{"2":{"139":1}}],["虽然这些在之前nlp的相关学习中也都了解过",{"2":{"42":1}}],["虽然所有的图形化ir都由节点和边组成",{"2":{"151":1}}],["虽然存在更为通用的解析算法",{"2":{"130":1}}],["虽然已被",{"2":{"67":1}}],["快速训练",{"2":{"67":1}}],["适用场景",{"2":{"67":1}}],["🐢",{"2":{"67":1}}],["⚡",{"2":{"67":1}}],["支持多种优化",{"2":{"232":1}}],["支持的操作符集合和抽象级别可以有很大差异",{"2":{"169":1}}],["支持内存到内存的操作",{"2":{"143":1}}],["支持",{"2":{"67":1,"114":1}}],["支持全球所有语言",{"2":{"47":1}}],["✅",{"2":{"67":1,"75":1}}],["❌",{"2":{"67":1,"75":1}}],["局部数据区存放了在被调用者的局部作用域中声明的",{"2":{"187":1}}],["局部窗口",{"2":{"67":1,"75":1}}],["局部变量这个答错了",{"2":{"33":1}}],["局部变量生命周期是否会延长",{"2":{"33":1}}],["深度",{"2":{"67":1}}],["深度学习框架",{"2":{"46":1}}],["深度学习推理",{"0":{"37":1}}],["深度学习训练框架优化工程师",{"0":{"34":1}}],["浅层神经网络",{"2":{"67":1}}],["特别是那些重新排序循环以暴露并行性和改善内存行为的转换",{"2":{"218":1}}],["特定的命名规范可以揭示优化的机会或使这些机会变得模糊",{"2":{"140":1}}],["特性",{"2":{"67":1,"75":1,"176":1}}],["特此声明",{"2":{"5":1}}],["余弦相似度",{"2":{"67":1}}],["|term",{"2":{"146":1}}],["|",{"2":{"67":5,"75":1,"119":1,"131":1,"141":1,"146":9,"150":22,"153":3,"160":1,"164":5,"167":18,"184":18,"204":3,"206":9,"213":4}}],["||",{"2":{"16":2,"162":10}}],["核心思想",{"2":{"75":1}}],["核心思路",{"2":{"66":1}}],["核心公式总结",{"2":{"67":1}}],["忽略低频词",{"2":{"67":1}}],["应将该表标记为最终状态",{"2":{"190":1}}],["应用第一个产生式",{"2":{"150":1}}],["应用反转操作得到图",{"2":{"123":1}}],["应用示例",{"2":{"67":1}}],["应该产生一个类型错误",{"2":{"215":1}}],["应该是假设5分钟有车经过的概率是",{"2":{"41":1}}],["应该已经发offer了",{"2":{"22":1}}],["应该实际上采用二维来处理",{"2":{"4":1}}],["银行",{"2":{"67":3}}],["河岸",{"2":{"67":3}}],["降低计算量",{"2":{"67":1}}],["高级主题",{"0":{"129":1},"1":{"146":1,"163":1,"181":1}}],["高效",{"2":{"67":1}}],["高效训练",{"2":{"67":1}}],["高性能计算实习生",{"0":{"31":1}}],["语言采用了两种方法之一",{"2":{"230":1}}],["语言和运行时之间需要一种机制来消除引用的歧义",{"2":{"221":1}}],["语言和实现定义了一套标准的动作来调用一个过程",{"2":{"183":1}}],["语言使用",{"2":{"203":1}}],["语言规则规定了通过这些表的搜索路径",{"2":{"201":1}}],["语言设计者可以避免这种歧义",{"2":{"180":1}}],["语言定义可能会禁止这样的转换",{"2":{"173":1}}],["语言可能要求编译器插入代码以将不兼容的参数转换为兼容的类型",{"2":{"173":1}}],["语言l",{"2":{"131":1}}],["语句等",{"2":{"176":1}}],["语句是否引用了未声明的标识符",{"2":{"159":1}}],["语句的语法结构",{"2":{"131":1}}],["语义相似性",{"2":{"67":1}}],["语法的不同部分将操作符号表表示",{"2":{"204":1}}],["语法的语言也同时拥有slr",{"2":{"181":1}}],["语法驱动框架可以轻松地为表达式和赋值语句发出三地址码",{"2":{"194":1}}],["语法驱动翻译",{"2":{"159":1}}],["语法驱动翻译的目的在于开始组装编译后续阶段所需的知識",{"2":{"159":1}}],["语法受到限制",{"2":{"181":1}}],["语法上有两种推导",{"2":{"180":1}}],["语法细节",{"2":{"176":1}}],["语法仍然是lr",{"2":{"162":1}}],["语法制导翻译",{"0":{"160":1},"1":{"178":1,"194":1,"204":1,"211":1,"217":1,"223":1}}],["语法树是解析树的简化版本",{"2":{"192":1}}],["语法树的进一步简化",{"2":{"176":1}}],["语法树和抽象语法树的对比",{"0":{"176":1}}],["语法树",{"2":{"158":1,"176":1,"192":1}}],["语法是明确的",{"2":{"180":1}}],["语法是一种自底向上的语法分析方法",{"2":{"156":1}}],["语法是指",{"2":{"137":1,"156":1}}],["语法来描述",{"2":{"131":1}}],["语法主要取决于现有工具的支持情况",{"2":{"130":1}}],["语法族因其确定性解析能力和强大的错误检测机制而脱颖而出",{"2":{"130":1}}],["语法",{"0":{"121":1,"122":1,"125":1,"137":1,"156":1},"1":{"134":1,"137":1,"142":1,"150":1,"153":2,"156":1,"167":1,"170":2,"174":1,"184":1,"188":1},"2":{"46":1,"121":1,"125":1,"162":1,"181":1}}],["语法分析那说了递归下降语法分析和ll",{"2":{"46":1}}],["语法分析",{"2":{"46":1}}],["优点",{"2":{"67":1}}],["优化可以延长临时值的生命周期",{"2":{"210":1}}],["优化cfg",{"2":{"207":1}}],["优化和简化控制流图",{"2":{"206":1}}],["优化和代码生成",{"2":{"192":1}}],["优化和代码生成需要对输入程序有深入的理解",{"2":{"159":1}}],["优化",{"2":{"206":1}}],["优化机会",{"2":{"200":1}}],["优化应该识别出相同的引用并重用已计算的值",{"2":{"197":1}}],["优化器知道多少",{"2":{"37":1}}],["优化从全局内存加载到共享内存的过程",{"2":{"16":1}}],["词法上最近的作用域中创建",{"2":{"172":1}}],["词法作用域规则背后的一般原则很简单",{"2":{"172":1}}],["词法作用域和继承规则",{"2":{"140":1}}],["词法分析那里说了一下nfa",{"2":{"46":1}}],["词法分析",{"2":{"46":1}}],["词预测",{"2":{"75":1}}],["词向量",{"2":{"75":1}}],["词向量计算",{"2":{"67":1}}],["词嵌入",{"2":{"67":1}}],["词",{"2":{"67":1}}],["⋅vn",{"2":{"67":2}}],["通常位于堆上",{"2":{"236":1}}],["通常通过强制性的函数原型来完成",{"2":{"233":1}}],["通常包含一个入口节点和一个出口节点",{"2":{"206":1}}],["通常包括用于重新排序堆栈的操作",{"2":{"143":1}}],["通常对应条件跳转",{"2":{"206":1}}],["通常情况下",{"2":{"199":1}}],["通常使用栈来保存中间状态",{"2":{"142":1}}],["通常是最为实际的做法",{"2":{"130":1}}],["通常有办法可以提升其性能",{"2":{"129":1}}],["通常",{"2":{"67":1,"139":2,"143":1,"169":1,"240":1}}],["通过复制传播消除不必要的φ函数",{"2":{"208":1}}],["通过共享单一的",{"2":{"198":1}}],["通过捕获的变量在多次调用间保持状态",{"2":{"183":1}}],["通过lambda表达式创建匿名函数对象",{"2":{"183":1}}],["通过适当的表简化技术",{"2":{"181":1}}],["通过解析表的状态转移和归约动作来识别",{"2":{"161":1}}],["通过重命名和使用称为",{"2":{"155":1}}],["通过这种方式",{"2":{"163":1}}],["通过这种合并",{"2":{"146":1}}],["通过这些添加",{"2":{"162":1}}],["通过这个",{"2":{"19":1}}],["通过",{"2":{"127":1,"155":1}}],["通过以上的描述",{"2":{"123":1}}],["通过应用子集构造所确定的dfa",{"2":{"123":1}}],["通过向前看一些记号来预测需要用到的产生式",{"2":{"122":1}}],["通过定义",{"2":{"106":1}}],["通过预训练学习上下文相关的词表示",{"2":{"75":1}}],["通过滑动窗口的方式",{"2":{"63":1}}],["通过遍历内部循环",{"2":{"1":1}}],["负载",{"2":{"169":1}}],["负号",{"2":{"162":2}}],["负样本数量",{"2":{"67":1}}],["负采样损失",{"2":{"67":1}}],["负采样和层次",{"2":{"67":1}}],["负采样",{"2":{"67":1}}],["训练目标",{"2":{"75":1}}],["训练方式",{"2":{"67":1}}],["训练模型",{"2":{"67":1}}],["训练优化",{"2":{"67":1}}],["训练引擎实习生",{"0":{"37":1}}],["变成了",{"2":{"155":1}}],["变量声明如果存在变量声明",{"2":{"190":1}}],["变量的生命周期和可见性取决于声明它的作用域",{"2":{"175":1}}],["变量名称包含了下标以确保每个定义都有独特的名称",{"2":{"155":1}}],["变量说明",{"2":{"67":4}}],["变长编码",{"2":{"47":1}}],["使引用更加具体化",{"2":{"238":2}}],["使cfg成为衍生的ir",{"2":{"206":1}}],["使",{"2":{"206":1}}],["使编译器能够以高效的方式实现这些构造",{"2":{"173":1}}],["使得旧的调用图变得不准确",{"2":{"224":1}}],["使得部分名称解析发生在运行时",{"2":{"201":1}}],["使得调用者将返回地址存储在被调用者的激活记录",{"2":{"187":1}}],["使得预测分析更加明确",{"2":{"184":1}}],["使得程序员可以在不同的时间调用由其他人编写的代码",{"2":{"183":1}}],["使得填表算法能够通过follow集合区分移进条目和归约条目",{"2":{"181":1}}],["使得goto",{"2":{"145":1}}],["使得很少有字符串会产生相同的哈希值",{"2":{"139":1}}],["使得出现次数超过两次的元素只出现两次",{"2":{"87":1}}],["使得语义相似的词在向量空间中距离相近",{"2":{"67":1}}],["使剩余区间互不重叠",{"2":{"84":1}}],["使每个元素只出现一次",{"2":{"80":1}}],["使用十个字节而没有填充",{"2":{"239":1}}],["使用数据区域布局的技术",{"2":{"234":1}}],["使用一个元素的向量",{"2":{"231":1}}],["使用一个词来表示两种不同的含义可以造成语法歧义",{"2":{"180":1}}],["使用更多的内存",{"2":{"212":1}}],["使用单语句块构建的",{"2":{"212":1}}],["使用过多的名称则可能会膨胀一些编译时的数据结构",{"2":{"197":1}}],["使用过少的名称可能会削弱优化的效果",{"2":{"197":1}}],["使用φ函数处理控制流合并",{"2":{"189":1}}],["使用结构体数组",{"2":{"186":1}}],["使用闭包作为参数",{"2":{"183":1}}],["使用其他构造方法",{"0":{"181":1}}],["使用三地址码的编译器通常将其部署为确定性的中间表示",{"2":{"169":1}}],["使用较少的参数",{"2":{"169":1}}],["使用适当的代码布局技术",{"2":{"163":1}}],["使用由解析生成器yacc和bison推广的表示法",{"2":{"160":1}}],["使用栈意味着所有的结果和参数都是临时的",{"2":{"152":1}}],["使用线性ir来表示代码块",{"2":{"149":1}}],["使用线性形式背后的逻辑很简单",{"2":{"136":1}}],["使用这样的编译器找到代码文件中的所有语法错误可能是一个漫长且痛苦的过程",{"2":{"145":1}}],["使用移进",{"2":{"142":1}}],["使用ir使得编译器可以对代码进行多次遍历",{"2":{"132":1}}],["使用了四个节点来表示输入流中的一个单词",{"2":{"129":1}}],["使用ninja构建llvm",{"2":{"114":1}}],["使用的是",{"2":{"114":1}}],["使用cmake配置llvm",{"2":{"114":1}}],["使用浅克隆",{"2":{"114":1}}],["使用gcc前端的llvm环境中",{"2":{"154":1}}],["使用git拉取llvm源代码",{"2":{"114":1}}],["使用grep从文件中读取某一行信息",{"2":{"39":1}}],["使用a的",{"2":{"1":1}}],["团队在",{"2":{"67":1}}],["由这些单独编译所产生的代码必须能够与其他时间编译的代码正确链接和执行",{"2":{"183":1}}],["由扫描器产生的分类词流可以被视为一种设计用于在扫描器和解析器之间通信的ir",{"2":{"165":1}}],["由此产生的解析器避免了直接表示action和goto表中的所有",{"2":{"163":1}}],["由此产生的action和goto",{"2":{"163":1}}],["由此产生的中间表示可以非常紧凑",{"2":{"136":1}}],["由此产生的dfa不会有重复的前缀",{"2":{"123":1}}],["由于它们是私有的",{"2":{"236":1}}],["由于它们是图",{"2":{"228":1}}],["由于对象的生命周期是不规则的",{"2":{"236":1}}],["由于对象的生命周期独立于方法调用",{"2":{"187":1}}],["由于编译器通常会访问它分配的所有空间",{"2":{"205":1}}],["由于编译器必须为每个节点和每条边分配内存",{"2":{"168":1}}],["由于类的内容及其继承上下文都是通过语法指定的",{"2":{"201":1}}],["由于每个变量只被赋值一次",{"2":{"200":1}}],["由于每个元组通过其位置值指向特定的标记",{"2":{"139":1}}],["由于赋值或程序调用可以改变与名称关联的值",{"2":{"198":1}}],["由于调用方在调用前保存并在调用后恢复寄存器值",{"2":{"187":1}}],["由于过程拥有已知且独立的命名空间",{"2":{"183":1}}],["由于规则14和15扩展到相同的右部",{"2":{"180":1}}],["由于具有显式的命名空间和负载",{"2":{"169":1}}],["由于许多现代处理器实现了三地址操作",{"2":{"169":1}}],["由于大多数处理器依赖于线性的汇编语言",{"2":{"148":1}}],["由于brzozowski算法产生的是dfa",{"2":{"141":1}}],["由于",{"2":{"113":1,"155":1,"188":1}}],["由于子数组的元素和等于两个前缀和的差",{"2":{"106":1}}],["由他们的字符形式表示",{"2":{"105":1}}],["由",{"2":{"67":1}}],["提取左公共因子α",{"2":{"184":1}}],["提取左公共因子的步骤如下",{"2":{"184":1}}],["提取公共前缀",{"2":{"184":2}}],["提取非左递归产生式",{"2":{"150":1}}],["提供了读取或写入这些私有成员的公共方法",{"2":{"236":1}}],["提供对向量或simd数据和操作的支持",{"2":{"154":1}}],["提供错误恢复机制",{"2":{"144":1}}],["提供枚举选哪个的思路",{"2":{"72":1}}],["提高了解析效率",{"2":{"146":1}}],["提高了性能",{"2":{"103":1}}],["提高算法的效率",{"2":{"66":1}}],["提示",{"2":{"7":1,"50":1,"103":1,"131":1,"155":1,"187":1,"193":1}}],["⋯",{"2":{"66":1}}],["$",{"2":{"170":5,"174":8}}],["$2是digit的值",{"2":{"160":1}}],["$2等则代表右侧各符号的值",{"2":{"160":1}}],["$2",{"2":{"160":1,"204":2}}],["$$",{"2":{"67":4,"160":2}}],["$是否在",{"2":{"66":1}}],["$x+1",{"2":{"66":1}}],["$1是integer的值",{"2":{"160":1}}],["$1",{"2":{"21":1,"160":2,"204":2}}],["$12",{"2":{"21":1}}],["$1600",{"2":{"21":1}}],["它具有以下特点",{"2":{"232":1}}],["它具有简单的声明语法",{"2":{"204":1}}],["它包含指向列表第一个元素的指针",{"2":{"210":1}}],["它包含一个指向acolorpoint类的指针",{"2":{"187":1}}],["它包含一个指向apoint类的指针",{"2":{"187":1}}],["它为",{"2":{"204":1}}],["它为每个值分配一个从数据区域开始的具体偏移量",{"2":{"175":1}}],["它为每个唯一的标识符分配一个符号表索引",{"2":{"139":1}}],["它对路径中的每个表执行查找",{"2":{"201":1}}],["它要么找到m",{"2":{"201":1}}],["它要求每个变量在整个程序中只被赋值一次",{"2":{"171":1}}],["它在范围检查中也起着关键作用",{"2":{"231":1}}],["它在类c的表中搜索m",{"2":{"201":1}}],["它在优化中被广泛应用",{"2":{"155":1}}],["它首先在词法层次结构中解析o为某个类c的一个实例",{"2":{"201":1}}],["它创建表格来模拟每个作用域",{"2":{"201":1}}],["它避免了这种重复",{"2":{"198":1}}],["它交错进行两种类型的动作",{"2":{"195":1}}],["它可能需要在值之间插入空的空间",{"2":{"239":1}}],["它可能指的是周围作用域中的名称",{"2":{"190":1}}],["它可以用来自列表末尾的小边界名称填充那个空间",{"2":{"239":1}}],["它可以按照排序后的顺序为名称分配偏移量",{"2":{"239":1}}],["它可以细化ir",{"2":{"238":1}}],["它可以执行类型推断",{"2":{"238":1}}],["它可以执行存储布局",{"2":{"238":1}}],["它可以通过几种方式获得这些信息",{"2":{"233":1}}],["它可以通过消除冗余来进一步减小解析表的尺寸",{"2":{"163":1}}],["它可以从相同的构建模块",{"2":{"201":1}}],["它可以从左到右累积值",{"2":{"160":1}}],["它可以",{"2":{"201":1}}],["它可以避免重新发现它们的成本",{"2":{"198":1}}],["它可以存储在作用域的局部数据区中",{"2":{"193":1}}],["它可以生成一个直接调用",{"2":{"187":1}}],["它可以在每次调用时重复使用相同的调用方保存寄存器的空间",{"2":{"187":1}}],["它可以捕获并保存其定义时的上下文环境中的变量",{"2":{"183":1}}],["它可以正确且一致地运行",{"2":{"183":1}}],["它可以被显式或隐式地释放",{"2":{"175":1}}],["它可以被直接应用于thompson构造的输出",{"2":{"141":1}}],["它可以将控制返回到解析语句的例程报告成功的那个点",{"2":{"145":1}}],["它可以为输入的程序生成更高效的代码",{"2":{"132":1}}],["它也根据单词的语法类别改变dfa中的状态",{"2":{"195":1}}],["它也会将其值保存到自己的ar中",{"2":{"187":1}}],["它也确保了编译器每次编译最多只能找到一个语法错误",{"2":{"145":1}}],["它去掉了表示推导细节的非终结符号节点",{"2":{"185":1}}],["它捕获了外部变量base",{"2":{"183":1}}],["它保护了调用者的环境",{"2":{"183":1}}],["它生成的表最大",{"2":{"181":1}}],["它生成的目标机代码也是线性的",{"2":{"136":1}}],["它产生了一个与slr",{"2":{"181":1}}],["它遍历数据区域",{"2":{"175":1}}],["它只在其声明的文件内部可见",{"2":{"175":1}}],["它还必须确定返回值的类型以用于进一步的推断",{"2":{"233":1}}],["它还给模糊调用增加了显著的运行时开销",{"2":{"224":1}}],["它还允许编译器生成比没有类型信息时更为高效的代码",{"2":{"173":1}}],["它还有潜力显著减少每次查找所需的时间",{"2":{"139":1}}],["它相对紧凑",{"2":{"169":1}}],["它表示加载",{"2":{"166":1}}],["它表示存储",{"2":{"166":1}}],["它允许",{"2":{"162":1}}],["它允许程序员对任何因子取绝对值",{"2":{"162":1}}],["它正确地显示了代码必须先评估",{"2":{"162":1}}],["它出现在栈顶并且可以被归约",{"2":{"161":1}}],["它用具体的符号表引用注解名称的引用",{"2":{"172":1}}],["它用发现的事实来注释这个ir",{"2":{"159":1}}],["它用一个或多个语法符号的字符串替换单一的非终端符号",{"2":{"131":1}}],["它构建代码的中间表示",{"2":{"159":1}}],["它构建一个具有最少数量集合的划分",{"2":{"115":1}}],["它读取另一个程序",{"2":{"159":1}}],["它充当复制操作",{"2":{"155":1}}],["它需满足两个约束条件",{"2":{"155":1}}],["它需要比因子",{"2":{"162":1}}],["它需要有关x的完整类型信息和访问方法",{"2":{"159":1}}],["它需要通过名称高效访问所有派生的信息",{"2":{"148":1}}],["它需要一种机制将n映射回其在p处有效的命名环境中所做的声明",{"2":{"139":1}}],["它",{"2":{"154":1}}],["它易于生成和理解",{"2":{"152":1}}],["它假定存在一个操作数栈",{"2":{"152":1}}],["它假设变量的主要存放位置在内存中",{"2":{"143":1}}],["它假设a",{"2":{"143":1}}],["它必须满足所有的对齐限制",{"2":{"239":1}}],["它必须对来自不同超类的方法使用不同的对象记录指针",{"2":{"237":1}}],["它必须确保每个实际参数与相应的形式参数之间的类型兼容性",{"2":{"233":1}}],["它必须构建并维护命名环境的模型",{"2":{"190":1}}],["它必须做出安排以在运行时解析该绑定",{"2":{"172":1}}],["它必须知道x所绑定的实体",{"2":{"159":1}}],["它必须创建存储布局计划",{"2":{"148":1}}],["它必须记录这些知识并将它们传递给后续的遍历过程",{"2":{"132":1}}],["它消除了14个过程调用中的3个",{"2":{"146":1}}],["它向后扫描解析堆栈",{"2":{"145":1}}],["它使用了十六个字节",{"2":{"239":1}}],["它使用",{"2":{"178":1}}],["它使用lr",{"2":{"142":2}}],["它使用递归函数来解析输入串",{"2":{"134":1}}],["它完全避免了哈希可能带来的最坏情况",{"2":{"139":1}}],["它将名称分类为存储类",{"2":{"240":1}}],["它将这些表格链接起来创建搜索路径",{"2":{"201":1}}],["它将所有元组输入到一个大集合中",{"2":{"139":1}}],["它将每个离散属性的每个类别创建一个新的二进制特征",{"2":{"57":1}}],["它通过在扫描器中离线构建索引来避免最坏情况的发生",{"2":{"139":1}}],["它通过神经网络将单词映射到低维稠密向量空间",{"2":{"67":1}}],["它由有序的指令序列组成",{"2":{"136":1}}],["它不会回溯参考源文本",{"2":{"132":1}}],["它们等价吗",{"2":{"230":1}}],["它们用虚线表示",{"2":{"218":1}}],["它们会设置各种属性和绑定",{"2":{"204":1}}],["它们需要句法树遥远部分的数据",{"2":{"204":1}}],["它们还提高了编译器检测不良形成程序",{"2":{"191":1}}],["它们的代码指针",{"2":{"187":1}}],["它们始终存在",{"2":{"175":1}}],["它们都可以减少表的大小",{"2":{"163":1}}],["它们在指令调度中扮演着核心角色",{"2":{"218":1}}],["它们在表示源代码语法结构时有不同的侧重点和用途",{"2":{"158":1}}],["它们在确定编译器必须解决哪些问题以及需要多少空间和时间来解决问题方面起着关键作用",{"2":{"143":1}}],["它们也并行地定义它们的目标ssa名称",{"2":{"155":1}}],["它们报告问题并停止",{"2":{"145":1}}],["它们无法处理语法错误",{"2":{"145":1}}],["它们是程序的构建模块",{"2":{"183":1}}],["它们是可以通过汇编级别的指令初始化的静态值",{"2":{"175":1}}],["它们是上一节所述的图形ir的替代形式",{"2":{"136":1}}],["它们是为在g的产生式中提供抽象和结构而引入的语法变量",{"2":{"131":1}}],["它们分别是",{"2":{"101":1}}],["它看到的是标注了其语法类别的单词流",{"2":{"131":1}}],["它会根据该节点的操作符类型及其子节点来设置该节点的类型",{"2":{"233":1}}],["它会在词法层次结构中搜索n",{"2":{"201":1}}],["它会将子表达式的抽象语法树",{"2":{"194":1}}],["它会将值保存到自己的ar中",{"2":{"187":1}}],["它会分析",{"2":{"182":1}}],["它会执行大括号内的动作来计算新值",{"2":{"160":1}}],["它会发现并衍生出可能不适合简单地放入树",{"2":{"148":1}}],["它会丢弃输入符号",{"2":{"145":1}}],["它会对标记流进行额外的一次遍历以及字典排序",{"2":{"139":1}}],["它会向用户报告问题及其位置",{"2":{"131":1}}],["它会构建程序的具体模型",{"2":{"131":1}}],["它会消除14个过程调用中的3个",{"2":{"129":1}}],["它会遵循导致接受状态的转换来处理输入字符串",{"2":{"112":1}}],["它从输入串的底部开始",{"2":{"121":1}}],["它从开始符号开始",{"2":{"121":1}}],["它没有向外的转换",{"2":{"118":1}}],["它的可见性跨越多个",{"2":{"203":1}}],["它的可见区域简单来说就是它可以被访问的代码部分",{"2":{"175":1}}],["它的主要特点包括",{"2":{"142":1}}],["它的lr",{"2":{"129":1}}],["它的设计目标是可以在不同的平台上运行",{"2":{"110":1}}],["它的目标是为了开发新的编译器和优化器",{"2":{"110":1}}],["它的和就可以表示为",{"2":{"106":1}}],["它的第",{"2":{"104":1}}],["它的长度为",{"2":{"66":1}}],["它是n1类型或n2类型结构体",{"2":{"221":1}}],["它是point的一个子类",{"2":{"201":1}}],["它是未定义的",{"2":{"175":1}}],["它是",{"2":{"99":5}}],["找出左公共因子",{"2":{"184":1}}],["找出具有相同前缀的产生式",{"2":{"184":1}}],["找出",{"2":{"78":1}}],["找出数字连续的最长序列",{"2":{"66":1}}],["找到所有基本块的起始位置",{"2":{"207":1}}],["找到从起始状态",{"2":{"127":1}}],["找到一个具有最大和的连续子数组",{"2":{"106":1}}],["找到",{"2":{"99":1}}],["找到字符串中所有字母的异位词",{"0":{"85":1,"99":1},"1":{"99":1}}],["找到比i小的元素j",{"2":{"53":1}}],["找到其中最长严格递增子序列的长度",{"2":{"53":1}}],["请返回true",{"2":{"101":1}}],["请注意",{"2":{"100":1,"123":1}}],["请",{"2":{"88":1}}],["请你找出其中不含有重复字符的",{"2":{"100":1}}],["请你返回",{"2":{"103":1}}],["请你返回至少出现一次连续k个黑色块的",{"2":{"93":1}}],["请你返回0",{"2":{"90":1}}],["请你返回nums中长度为k的",{"2":{"90":1}}],["请你原地删除重复出现的元素",{"2":{"80":1,"87":1}}],["请你计算并返回可以凑成总金额的硬币组合数",{"2":{"68":1}}],["请你设计并实现时间复杂度为",{"2":{"66":1}}],["请你将",{"2":{"65":1}}],["请按照以下顺序使用",{"2":{"29":1}}],["出现",{"2":{"224":1}}],["出口",{"2":{"223":1}}],["出队",{"2":{"64":1}}],["出",{"2":{"64":1}}],["入队",{"2":{"64":1}}],["入",{"2":{"64":1}}],["遍历过程会变得更长",{"2":{"212":1}}],["遍历和处理",{"2":{"212":1}}],["遍历字符c得到",{"2":{"113":1}}],["遍历字符b边得到",{"2":{"113":1}}],["遍历字符a的",{"2":{"113":1}}],["遍历",{"2":{"66":1}}],["遍历结束后",{"2":{"63":1}}],["遍历每一天",{"2":{"63":2}}],["累加到",{"2":{"63":1}}],["滑动窗口的位置",{"2":{"64":1}}],["滑动窗口每次只向右移动一位",{"2":{"64":1}}],["滑动窗口",{"2":{"63":1}}],["滑动窗口最大值",{"0":{"52":1,"64":1},"1":{"64":1}}],["直通路径通常比取分支路径更快",{"2":{"136":1}}],["直通分支",{"2":{"136":1}}],["直观的错误处理机制以及在特定场景下的性能优势",{"2":{"130":1}}],["直到最后一次使用",{"2":{"203":1}}],["直到找到名称或是在最外层表中查找失败为止",{"2":{"201":1}}],["直到找到一个状态s",{"2":{"145":1}}],["直到找到一个同步词",{"2":{"145":1}}],["直到代码到达编译器的后端",{"2":{"154":1}}],["直到某个",{"2":{"153":1}}],["直到归约到起始符号",{"2":{"142":1}}],["直到整个输入串被解析为一个语法树",{"2":{"121":2}}],["直到队列为空或队列末尾元素的价格小于等于当前天的价格",{"2":{"63":1}}],["直觉就是遍历一遍",{"2":{"104":1}}],["直接将",{"2":{"236":1}}],["直接表示这些复杂操作可以简化分析和优化",{"2":{"169":1}}],["直接编码表",{"2":{"163":1}}],["直接编码扫描器",{"2":{"124":1}}],["直接返回false",{"2":{"107":1}}],["直接返回结果",{"2":{"58":1,"68":1}}],["直接给出代码即可",{"2":{"80":1}}],["直接用一个map来记录",{"2":{"65":1}}],["直接看思路",{"2":{"63":1}}],["直接输出他的螺旋矩阵",{"2":{"43":1}}],["维度",{"2":{"67":2}}],["维护前缀和的最小值",{"2":{"106":1}}],["维护一个",{"2":{"104":1}}],["维护答案",{"2":{"64":1}}],["维护单调性",{"2":{"64":1}}],["维护单调栈",{"2":{"63":1}}],["维护单调队列",{"2":{"63":1}}],["维上有一个循环",{"2":{"23":1}}],["维上有个循环",{"2":{"23":1}}],["样例3",{"2":{"63":1}}],["样例2",{"2":{"63":1}}],["样例1",{"2":{"63":1}}],["份食物",{"2":{"63":1}}],["然而",{"2":{"63":1,"129":1,"132":1,"139":1,"145":1,"152":1,"155":1,"157":1,"162":3,"163":1,"178":1,"181":1,"187":3,"191":1,"194":1,"201":1,"204":1,"212":1,"216":1,"226":1,"230":1}}],["然后编译器可以对ir执行更复杂的",{"2":{"238":1}}],["然后进行存储布局",{"2":{"238":1}}],["然后被丢弃",{"2":{"218":1}}],["然后检索代码指针",{"2":{"187":1}}],["然后才能执行减法操作",{"2":{"162":1}}],["然后算法在节点和边上进行操作",{"2":{"149":1}}],["然后继续正常的解析过程",{"2":{"145":1}}],["然后",{"2":{"145":1,"155":2,"239":1}}],["然后将其内部状态重置为与识别该词一致的状态",{"2":{"145":1}}],["然后将当前天的价格和天数加入队列",{"2":{"63":1}}],["然后重写标记以包含该索引",{"2":{"139":1}}],["然后每次更新这个点",{"2":{"107":1}}],["然后每次移动窗口时",{"2":{"90":1,"93":1,"103":1}}],["然后用一个数来记录最大和",{"2":{"106":1}}],["然后再从下标",{"2":{"107":1}}],["然后再计算老板生气时的客户数量",{"2":{"103":1}}],["然后再细分就能找到中位数了",{"2":{"41":1}}],["然后判断窗口中的字符串是否在",{"2":{"101":1}}],["然后就可以开始滑动窗口了",{"2":{"99":1}}],["然后看枚举数组的时候",{"2":{"84":1}}],["然后返回nums中唯一元素的个数",{"2":{"80":1}}],["然后是分解子问题",{"2":{"50":1}}],["然后在整个翻译过程中应用这些决定",{"2":{"143":1}}],["然后在同一天出售",{"2":{"50":1}}],["然后在他提示下说出来第7行那里可以用move",{"2":{"41":1}}],["然后问了简历上写的模型压缩方法",{"2":{"46":1}}],["然后问了模型量化的基本原理",{"2":{"41":1}}],["然后讲cpu一般实现的策略",{"2":{"46":1}}],["然后转变方向就可以了",{"2":{"43":1}}],["然后统计每个桶的大小",{"2":{"41":1}}],["然后细问",{"2":{"37":1}}],["然后调用",{"2":{"29":1}}],["幸运的是",{"2":{"63":1}}],["任何名称在出现在可执行代码之前都必须被声明",{"2":{"233":1}}],["任何包含构造类型的编程语言都需要有一个明确的规则来回答这个问题",{"2":{"230":1}}],["任何这样的联系都是隐含的",{"2":{"206":1}}],["任何拥有lr",{"2":{"181":1}}],["任何自顶向下的信息流问题都可以通过将所有信息传递给树中的共同祖先并在该点解决问题来用自底向上的框架解决",{"2":{"178":1}}],["任何具有单个符号右侧的产生式都可以被合并",{"2":{"129":1}}],["任何只有一个子节点的内部节点都是优化的候选对象",{"2":{"129":1}}],["任何状态的编号都小于等于",{"2":{"127":1}}],["任何清空下",{"2":{"62":1,"74":1}}],["任意子数组",{"2":{"106":1}}],["任意顺序",{"2":{"73":1}}],["任务列表4",{"2":{"21":1}}],["任务列表3",{"2":{"21":1}}],["任务列表2",{"2":{"21":1}}],["任务列表1",{"2":{"21":1}}],["关联",{"2":{"194":1}}],["关键的区别在于",{"2":{"210":1}}],["关键字",{"2":{"176":1}}],["关键公式",{"2":{"75":1}}],["关键是怎么样修改",{"2":{"62":1}}],["关于基本类型",{"2":{"235":1}}],["关于值放置位置的决策可能会影响编译代码的性能",{"2":{"175":1}}],["关于表示什么以及如何表示这些内容的决策在编译成本及其效果方面起着关键作用",{"2":{"132":1}}],["关于第二点的解释",{"2":{"66":1}}],["关于实习时长我也实话实话了",{"2":{"22":1}}],["括号生成",{"0":{"60":1,"72":1},"1":{"72":1}}],["全局",{"2":{"203":1}}],["全局变量是静态的",{"2":{"203":1}}],["全局值则存放在内存中",{"2":{"143":1}}],["全局双向上下文",{"2":{"75":1}}],["全局自注意力",{"2":{"67":1}}],["全局内存中的",{"2":{"29":1}}],["全排列",{"0":{"59":1,"69":1},"1":{"69":1}}],["否则编译器可以在编译时将任何方法解析为其具体的实现",{"2":{"187":1}}],["否则grumpy",{"2":{"103":1}}],["否则请返回false",{"2":{"101":1}}],["否则会丢失解",{"2":{"76":1}}],["否则程序会超出预期",{"2":{"72":1}}],["否则就是无效的括号组合",{"2":{"72":1}}],["否则返回",{"2":{"58":1}}],["否则",{"2":{"58":1,"68":1,"107":1,"139":1,"217":1}}],["递归调用开始逐层返回",{"2":{"183":1}}],["递归过程如下展开",{"2":{"183":1}}],["递归下降的解析器中",{"2":{"180":1}}],["递归下降的语法分析方法通常使用递归函数来实现",{"2":{"134":1}}],["递归下降的语法分析是一种自顶向下的语法分析方法",{"2":{"134":1}}],["递归下降的语法分析",{"0":{"134":1}}],["递归出口",{"2":{"69":1,"72":1}}],["递归计算前i",{"2":{"58":1,"68":1}}],["递归和非递归",{"2":{"37":1}}],["没人使用",{"2":{"155":1}}],["没有链接约定",{"2":{"183":1}}],["没有间接左递归",{"2":{"167":1}}],["没有交易完成",{"2":{"104":1}}],["没有出现在",{"2":{"101":1}}],["没有硬币可选的情况",{"2":{"58":1}}],["没被访问过",{"2":{"69":1}}],["没用过",{"2":{"33":1}}],["初始化和释放实际上没有运行时成本",{"2":{"203":1}}],["初始化状态栈和符号栈",{"2":{"144":1}}],["初始化分割状态",{"2":{"115":1}}],["初始化一个存储键值对的双端队列",{"2":{"63":1}}],["初始化结果",{"2":{"63":1}}],["初始化",{"2":{"63":1,"127":1,"179":1,"195":1}}],["初始化输出值",{"2":{"7":1}}],["初始值为",{"2":{"58":1,"68":1}}],["要执行准确的类型推断",{"2":{"233":1}}],["要优化数组引用的代码",{"2":{"166":1}}],["要解决这个问题",{"2":{"150":1}}],["要构建一个令人满意的解析器",{"2":{"129":1}}],["要么穷尽了层次结构",{"2":{"201":1}}],["要么在执行前被翻译成目标机器的本地代码",{"2":{"152":1}}],["要么代码将活跃值移动到寄存器中",{"2":{"143":1}}],["要么中间表示",{"2":{"143":1}}],["要么流向标签后面的指令",{"2":{"136":1}}],["要么包含非接受状态",{"2":{"115":1}}],["要么是w要么是b",{"2":{"93":1}}],["要从",{"2":{"78":1}}],["要保证左括号的数量大于右括号的数量",{"2":{"72":1}}],["要来的清楚",{"2":{"63":1}}],["要凑成的总金额",{"2":{"58":1,"68":1}}],["要前进到共享内存中的下一个",{"2":{"29":1}}],["凑成总金额的硬币组合数",{"2":{"68":1}}],["凑成总金额所需的最少硬币个数",{"2":{"58":1}}],["凑成j元",{"2":{"58":1}}],["凑成0元",{"2":{"58":1}}],["拿的话",{"2":{"58":1}}],["拿了offer",{"2":{"34":1}}],["返回指令",{"2":{"207":1}}],["返回错误信息",{"2":{"195":1}}],["返回持有来自词素的名称当前值的寄存器编号",{"2":{"194":1}}],["返回持有来自词素的常量值的寄存器编号",{"2":{"194":1}}],["返回一个新的寄存器编号",{"2":{"194":1}}],["返回一个较大的数表示不可能",{"2":{"58":1}}],["返回地址槽存放了当被调用者终止时控制权应返回的运行时地址",{"2":{"187":1}}],["返回值槽提供了在需要时从被调用者回传数据到调用者的空间",{"2":{"187":1}}],["返回值的类型和大小",{"2":{"139":1}}],["返回5",{"2":{"183":1}}],["返回4",{"2":{"183":1}}],["返回3",{"2":{"183":1}}],["返回2",{"2":{"183":1}}],["返回closure",{"2":{"179":1}}],["返回dfa初始状态开始可以到达的所有状态和转换的集合",{"2":{"123":1}}],["返回其最大和",{"2":{"106":1}}],["返回其所有可能的全排列",{"2":{"69":1}}],["返回你可以从这笔交易中获取的最大利润",{"2":{"104":1}}],["返回你能获得的最大利润",{"2":{"50":1}}],["返回这些子串的起始索引",{"2":{"99":1}}],["返回删除后数组的新长度",{"2":{"80":1,"87":1}}],["返回范围",{"2":{"76":1}}],["返回所有它能表示的字母组合",{"2":{"73":1}}],["返回最终结果",{"2":{"68":1}}],["返回1并终止递归",{"2":{"183":1}}],["返回1",{"2":{"68":1,"183":1}}],["返回滑动窗口中的最大值",{"2":{"64":1}}],["返回完成这次徒步旅行的最小花费",{"2":{"63":1}}],["返回结果",{"2":{"58":1,"63":1}}],["返回0",{"2":{"58":1,"68":1}}],["返回",{"2":{"58":1,"68":1,"73":1,"84":1,"88":1,"104":1,"107":2,"195":1}}],["猫以及狗",{"2":{"57":1}}],["流程走完之后加我个微信",{"2":{"56":1}}],["流程显示还在复试中",{"2":{"56":1}}],["晚上19",{"2":{"56":1}}],["晚上他们部门不会走的太早",{"2":{"46":1}}],["期待offer",{"2":{"56":1}}],["期待3",{"2":{"56":1}}],["期待后续更新优化",{"0":{"36":1}}],["定在3",{"2":{"56":1}}],["定义一个返回整数类型的函数",{"2":{"225":1}}],["定义一个递归函数dfs",{"2":{"58":1,"68":1}}],["定义了调用过程或函数时所采取的动作",{"2":{"183":1}}],["定义为在某些句型中紧跟在非终结符a后面的终结符的集合",{"2":{"170":1}}],["定义为可以从",{"2":{"153":1}}],["定义前缀和如下",{"2":{"106":1}}],["定义",{"2":{"21":1,"88":2,"161":1,"176":1}}],["机器学习平台部",{"2":{"56":1}}],["机制resolution",{"2":{"19":1}}],["字符串的实际长度可能与其分配的大小不同",{"2":{"209":1}}],["字符串",{"0":{"209":1,"231":1},"2":{"191":1}}],["字符串连接可能未被定义在实数上",{"2":{"173":1}}],["字符串和对象",{"2":{"139":1}}],["字符w和b分别表示白色和黑色",{"2":{"93":1}}],["字母异位词",{"2":{"65":2}}],["字母异位组分词",{"0":{"54":1,"65":1},"1":{"65":1}}],["字节跳动",{"0":{"33":1}}],["字节广告系统架构",{"0":{"27":1},"1":{"33":1}}],["字节",{"2":{"22":1}}],["删除数组中重复项",{"0":{"77":1,"80":1,"87":1},"1":{"80":1,"87":1}}],["删除",{"2":{"53":1}}],["删除文字",{"2":{"21":1}}],["子类对象布局使用超类对象布局作为前缀",{"2":{"236":1}}],["子类对象布局必须为来自超类的数据成员分配一致的偏移量",{"2":{"236":1}}],["子类对象记录按照前缀布局方案组织",{"2":{"187":1}}],["子集构造方法通过系统地消除",{"2":{"123":1}}],["子集构造是不动点计算的一个例子",{"2":{"113":1}}],["子串",{"2":{"100":1}}],["子数组最少包含一个元素",{"2":{"106":1}}],["子数组指的是一个数组中一段连续非空的元素序列",{"2":{"90":1}}],["子数组的最大和如果不存在几乎唯一子数组",{"2":{"90":1}}],["子序列",{"2":{"53":1}}],["子网的概念",{"2":{"33":1}}],["徒步旅行中补给问题",{"0":{"51":1,"63":1},"1":{"63":1}}],["另一个节点是使用",{"2":{"218":1}}],["另一个保存then子句中的语句",{"2":{"217":1}}],["另一个是colorpoint",{"2":{"201":1}}],["另一个是凑成j元需要的硬币数",{"2":{"58":1}}],["另一个是买入还是卖出还是什么都不做",{"2":{"50":1}}],["另一种选择是",{"2":{"180":1}}],["另一种是作为过程调用",{"2":{"180":1}}],["另一方面",{"2":{"130":1,"187":1,"212":1}}],["另外最后那个taget要根据自己的需求来配置native",{"2":{"114":1}}],["另外最后一天是必须要卖出的",{"2":{"50":1}}],["另给一个整数",{"2":{"68":1}}],["买入价格",{"2":{"106":1}}],["买入这只股票",{"2":{"104":1}}],["买入股票利润为",{"2":{"50":1}}],["买卖股票问题ⅲ",{"0":{"62":1}}],["买股票最佳时期i",{"0":{"104":1}}],["买股票最佳时期ⅱ",{"0":{"50":1}}],["买股票最近时期ⅰ",{"0":{"92":1},"1":{"104":1}}],["买股票最近时期ⅲ",{"0":{"74":1}}],["买股票动态规划问题",{"0":{"44":1},"1":{"50":1,"62":1,"74":1}}],["很像一个全局变量",{"2":{"203":1}}],["很容易就把",{"2":{"155":1}}],["很容易想到",{"2":{"50":1}}],["很困难",{"2":{"155":1}}],["很明显",{"2":{"155":1}}],["很高",{"2":{"23":1}}],["天产生的利润",{"2":{"50":1}}],["天的价格",{"2":{"104":1}}],["天的利润最大值",{"2":{"50":1}}],["天的利润如何计算",{"2":{"50":1}}],["天的利润",{"2":{"50":1}}],["天的结束时的利润怎么来",{"2":{"50":1}}],["天",{"2":{"50":8,"63":1,"104":2}}],["股票价格",{"2":{"50":6,"104":2}}],["股票",{"2":{"50":1}}],["你最初位于数组的",{"2":{"107":1}}],["你要用",{"2":{"106":1}}],["你不能在买入前卖出股票",{"2":{"104":1}}],["你不能同时参与多笔交易",{"2":{"62":1}}],["你只能选择",{"2":{"104":1}}],["你只可以看到在滑动窗口内的k个数字",{"2":{"64":1}}],["你的答案必须是",{"2":{"100":1}}],["你必须在",{"2":{"87":1}}],["你必须在再次购买前出售掉之前的股票",{"2":{"62":1}}],["你能帮助小r计算出最低的花费是多少吗",{"2":{"63":1}}],["你可以自己数一下",{"2":{"155":1}}],["你可以选择一个白色块将它",{"2":{"93":1}}],["你可以按任何顺序返回答案",{"2":{"76":1}}],["你可以按任意顺序返回答案",{"2":{"69":1}}],["你可以完成两笔交易",{"2":{"62":1}}],["你可以认为每种硬币的数量是无限的",{"2":{"58":1}}],["你可以决定是否购买和",{"2":{"50":1}}],["你也可以先购买",{"2":{"50":1}}],["你在任何时候最多只能持有",{"2":{"50":1}}],["你举的例子中",{"2":{"37":1}}],["表",{"2":{"191":1}}],["表中行是非终结符",{"2":{"188":1}}],["表可以接近那些由较为有限的技术所产生的表的大小",{"2":{"181":1}}],["表构造使用核心项目来计算规范集合",{"2":{"181":1}}],["表构建器将会报告这两个产生式之间的归约",{"2":{"180":1}}],["表生成器也可以使用其他技术来表示稀疏矩阵",{"2":{"163":1}}],["表也可能很大",{"2":{"163":1}}],["表的大小",{"0":{"163":1}}],["表的转换",{"2":{"129":1}}],["表达式中也包含函数调用",{"2":{"233":1}}],["表达式的结果类型取决于操作符及其操作数的类型",{"2":{"233":1}}],["表达式的类型推断本质上依赖于构成可执行程序的其他过程",{"2":{"233":1}}],["表达式的类型推断",{"0":{"233":1}}],["表达式的副本",{"2":{"198":1}}],["表达式",{"2":{"152":1,"169":1,"176":1,"198":1}}],["表达式如何捕获外部变量",{"2":{"33":1}}],["表少了一列",{"2":{"146":1}}],["表出现在图3",{"2":{"129":1}}],["表驱动扫描器",{"2":{"124":1}}],["表面上",{"2":{"112":1}}],["表示各块之间的关系",{"2":{"206":1}}],["表示ir",{"0":{"186":1}}],["表示为符号标签",{"2":{"143":1}}],["表示通过逆转所有转换的方向",{"2":{"123":1}}],["表示一个空数组的元素和",{"2":{"106":1}}],["表示一支给定股票第",{"2":{"104":1}}],["表示将",{"2":{"105":1}}],["表示",{"2":{"105":1,"206":1}}],["表示想要",{"2":{"93":1}}],["表示第i块的颜色",{"2":{"93":1}}],["表示从基本块",{"2":{"206":1}}],["表示从",{"2":{"88":2}}],["表示总金额",{"2":{"58":1,"68":1}}],["表示不同面额的硬币",{"2":{"58":1,"68":1}}],["表示它属于对应的类别",{"2":{"57":1}}],["表示某支股票第",{"2":{"50":1}}],["表现在前面计算的",{"2":{"50":1}}],["总计198个条目",{"2":{"163":1}}],["总是出现在栈顶",{"2":{"161":1}}],["总之",{"2":{"155":1}}],["总会到达下标为",{"2":{"107":1}}],["总共有",{"2":{"90":2}}],["总共耗时1个半小时",{"2":{"49":1}}],["总路程需要的天数",{"2":{"63":1}}],["总路程需要",{"2":{"63":1}}],["总结",{"0":{"49":1,"56":1,"130":1,"192":1,"196":1},"2":{"67":1}}],["差一点做出来了",{"2":{"49":1}}],["又做了一道",{"2":{"49":1}}],["又问了gemm是访存密集型还是计算机密集型",{"2":{"46":1}}],["纯聊天加做题",{"2":{"49":1}}],["怀疑kpi",{"2":{"49":1}}],["约束条件",{"2":{"63":1}}],["约3",{"2":{"56":1}}],["约",{"2":{"49":2}}],["零钱兑换2",{"0":{"68":1}}],["零钱兑换",{"0":{"48":1,"58":1},"1":{"58":1,"68":1}}],["导致维度灾难和模型效率低下",{"2":{"47":1}}],["导致向量中99",{"2":{"47":1}}],["导致文本向量化结果长度不一致",{"2":{"47":1}}],["需使相关缓存条目失效并更新缓存",{"2":{"187":1}}],["需通过词嵌入",{"2":{"47":1}}],["需要唯一选择",{"2":{"188":1}}],["需要使相关缓存条目失效",{"2":{"187":1}}],["需要使用更多的技巧",{"2":{"11":1}}],["需要特定的运行时结构来支持其词法层次结构和类层次结构",{"2":{"187":1}}],["需要用",{"2":{"155":1}}],["需要更新窗口中生气的顾客数量",{"2":{"103":1}}],["需要更新窗口中需要涂黑的白色块的数量",{"2":{"93":1}}],["需要更新窗口中互不相同的元素数量",{"2":{"90":1}}],["需要记录窗口中生气的顾客数量",{"2":{"103":1}}],["需要记录窗口中白色块的数量",{"2":{"93":1}}],["需要记录窗口中互不相同的元素数量",{"2":{"90":1}}],["需要移除区间的最小数量",{"2":{"84":1}}],["需要引入参数",{"2":{"62":1}}],["需要∞",{"2":{"58":1}}],["需要0个硬币",{"2":{"58":1}}],["需要重新根据一维线程索引排布为二维索引",{"2":{"16":1}}],["难以直接输入模型",{"2":{"47":1}}],["网页使用",{"2":{"47":1}}],["兼容ascii",{"2":{"47":1}}],["让计算机理解文本",{"0":{"47":1}}],["让我挑一个熟的讲",{"2":{"46":1}}],["让我做题",{"2":{"43":1}}],["让我设计一个全局计数器",{"2":{"39":1}}],["窃喜",{"2":{"46":1}}],["轻松",{"2":{"46":1}}],["部门氛围",{"2":{"46":1}}],["少的数组在多的数组里面二分查找左边界",{"2":{"46":1}}],["毕竟有序",{"2":{"46":1}}],["之一",{"2":{"206":1}}],["之一被执行",{"2":{"206":1}}],["之后会被丢弃",{"2":{"224":1}}],["之后会有一些自动调优的过程",{"2":{"46":1}}],["之后不得修改",{"2":{"155":1}}],["之外其余各元素的乘积",{"2":{"88":2}}],["之前的元素也一定存在",{"2":{"66":1}}],["之前计算过",{"2":{"53":1}}],["之间的权衡涉及到空间和时间",{"2":{"212":1}}],["之间的路径上",{"2":{"127":1}}],["之间的计算是互不影响的",{"2":{"23":1}}],["之间的线程不会发生",{"2":{"19":1}}],["之间可以并行访问",{"2":{"19":1}}],["生命周期和可见性信息与命名实体关联起来",{"2":{"204":1}}],["生命周期",{"2":{"175":1}}],["生命周期互不重叠",{"2":{"155":1}}],["生成测试用例覆盖不同路径",{"2":{"206":1}}],["生成和操作中间表示",{"2":{"205":1}}],["生成与输入程序的结构和语法联系起来",{"2":{"159":1}}],["生成有意义的错误信息",{"2":{"144":1}}],["生成所有可能的项集",{"2":{"144":1}}],["生成所有由",{"2":{"72":1}}],["生成的表格会按字母顺序排列以便进行二分查找",{"2":{"139":1}}],["生成代码",{"2":{"114":1}}],["生成中间件relay",{"2":{"46":1}}],["生产者消费者",{"2":{"37":1}}],["记为||",{"2":{"162":1}}],["记作",{"2":{"113":2,"127":1}}],["记作l",{"2":{"105":1}}],["记录每个基本块的起始和结束位置",{"2":{"207":1}}],["记录状态转移",{"2":{"144":1}}],["记录答案",{"2":{"64":1}}],["记录",{"2":{"64":1,"139":1,"191":1}}],["记录一下一些问题和八股",{"0":{"24":1}}],["记得修改状态",{"2":{"50":1}}],["记不清了",{"2":{"46":1}}],["多遍方法可能会简化编译器本身的代码",{"2":{"238":1}}],["多继承使对象记录",{"2":{"237":1}}],["多重继承的内存布局",{"0":{"237":1}}],["多重集判别提供了一种有趣的替代方案",{"2":{"139":1}}],["多重集判别解决了这个问题",{"2":{"139":1}}],["多重判别集",{"2":{"139":1}}],["多义词处理",{"2":{"67":1,"75":1}}],["多义词问题",{"2":{"67":1}}],["多少",{"2":{"46":1}}],["多线程中问题",{"2":{"41":1}}],["多线程中常用什么库",{"2":{"37":1}}],["会产生如边栏所示的",{"2":{"194":1}}],["会指向类中的方法向量",{"2":{"187":1}}],["会主要包含低级操作",{"2":{"169":1}}],["会检测到所有只有一次性赋值的常量变量的",{"2":{"155":1}}],["会先把所有局部变量都定义为",{"2":{"155":1}}],["会先把答案记录进path之后",{"2":{"76":1}}],["会分配这些整数",{"2":{"139":1}}],["会采取如下的措施",{"2":{"112":1}}],["会议消失",{"2":{"56":1}}],["会生成高维稀疏向量",{"2":{"47":1}}],["会造成缓存低下的问题",{"2":{"46":1}}],["会在前面计算",{"2":{"50":1}}],["会在",{"2":{"29":1}}],["得重新来编译",{"2":{"114":1}}],["得知我的实现是使用了共享内存",{"2":{"46":1}}],["得到的最小dfa如下",{"2":{"115":1}}],["得到的状态分别是",{"2":{"115":2}}],["得到的dfa如下",{"2":{"113":1}}],["得到k个黑块的最少涂色次数",{"0":{"83":1,"93":1},"1":{"93":1}}],["得到",{"2":{"1":1,"93":1}}],["性能差多少",{"2":{"46":1}}],["讲道理双指针跳起来应该很快的时间复杂度应该o",{"2":{"46":1}}],["讲道理这个应该最先想到的",{"2":{"46":1}}],["讲到矩阵乘的时候打断提问",{"2":{"46":1}}],["讲完了bank的基本知识",{"2":{"19":1}}],["先声明后使用",{"2":{"233":1}}],["先讲贪心",{"2":{"106":1}}],["先记录",{"2":{"97":1}}],["先添加k",{"2":{"90":1}}],["先聊项目",{"2":{"46":1}}],["先读取sa",{"2":{"11":1}}],["做混元大模型的",{"2":{"46":1}}],["整数变量",{"2":{"155":1}}],["整数范围内",{"2":{"88":1}}],["整个代码就差一点点就可以通过了",{"2":{"43":1}}],["整体思路没问题",{"2":{"43":1}}],["底部行",{"2":{"43":1}}],["右侧所示的显式长度表示方式",{"2":{"231":1}}],["右侧列",{"2":{"43":1}}],["右列假设加法是寄存器到寄存器的操作",{"2":{"143":1}}],["右边指针",{"2":{"103":1}}],["右边所有数的乘积",{"2":{"88":1}}],["右值",{"2":{"33":1}}],["顶部行",{"2":{"43":1}}],["二者取最大值",{"2":{"50":1}}],["二面",{"0":{"43":1,"46":1},"2":{"49":1}}],["二叉树深度遍历",{"2":{"37":1}}],["求输入每个字符",{"2":{"113":1}}],["求5分钟有车经过的概率",{"2":{"41":1}}],["求size",{"2":{"33":1}}],["还将包含作为参数传递给",{"2":{"193":1}}],["还可能简化了解析过程",{"2":{"163":1}}],["还剩下从dfa到re之间的kleen",{"2":{"127":1}}],["还是lr",{"2":{"145":1}}],["还是选择通过空边",{"2":{"112":1}}],["还是需要cpu的",{"2":{"46":1}}],["还是下一次适配",{"2":{"33":1}}],["还问我一面写的什么题",{"2":{"43":1}}],["还出了一道智力题",{"2":{"41":1}}],["手写智能指针",{"2":{"41":1}}],["手撕完之后就是正常面试环节",{"2":{"39":1}}],["手撕leetcode",{"2":{"33":1}}],["其值在整个执行期间都是活跃的",{"2":{"203":1}}],["其子节点为",{"2":{"194":1}}],["其顺序由它们在调用点出现的顺序决定",{"2":{"187":1}}],["其存储空间会被放入被调用者的ar中",{"2":{"187":1}}],["其语法驱动的翻译规则必须将该名称映射到特定实体",{"2":{"172":1}}],["其会返回一个指针",{"2":{"155":1}}],["其余按默认配置即可",{"2":{"114":1}}],["其次",{"2":{"129":1,"169":1,"177":1}}],["其次还有个灵神前缀和的思路",{"2":{"106":1}}],["其次缺少了语义信息缺失",{"2":{"47":1}}],["其核心创新是",{"2":{"75":1}}],["其他系统使用",{"2":{"198":1}}],["其他一元运算符出现在编程语言中",{"2":{"162":1}}],["其他特征为0",{"2":{"57":1}}],["其他问题想起来再更新",{"2":{"41":1}}],["其实现还需要一个对象记录的层次结构来捕捉基于继承的命名空间",{"2":{"187":1}}],["其实当时想过一秒钟的二分法",{"2":{"46":1}}],["其实就是写了个kernel",{"2":{"46":1}}],["其实是概率题",{"2":{"41":1}}],["其中n是字符串的长度",{"2":{"231":1}}],["其中n是键的数量",{"2":{"139":1}}],["其中包括被调用者的本地数据区",{"2":{"187":1}}],["其中命名空间被正确嵌套",{"2":{"187":1}}],["其中一个必须保存p在调用之后需要的寄存器值",{"2":{"187":1}}],["其中b是非终结符",{"2":{"179":1}}],["其中s是开始符号",{"2":{"170":1}}],["其中aaa是左公共因子",{"2":{"184":1}}],["其中a是终结符",{"2":{"179":1}}],["其中ai→β1∣β2∣",{"2":{"167":1}}],["其中acm模式问题也不大",{"2":{"8":1}}],["其中五个节点是无法消除的叶节点",{"2":{"129":1}}],["其中可以使用基数排序的思想",{"2":{"124":1}}],["其中可以优化的点",{"2":{"93":1}}],["其中如果后续要学习mlir的话这个examples要记得开",{"2":{"114":1}}],["其中每个",{"2":{"113":1,"115":1}}],["其中每个注意力头",{"2":{"75":1}}],["其中空字符需要",{"2":{"105":1}}],["其中customers",{"2":{"103":1}}],["其中八列表示",{"2":{"29":1}}],["其中26行的是为了同步",{"2":{"7":1}}],["其中代码",{"2":{"7":1}}],["其中",{"2":{"1":1,"50":1,"75":1,"84":1,"88":1,"90":1,"93":1,"102":1,"123":1,"139":3,"141":1,"153":1,"206":2}}],["类的对象记录中的公共成员有正确的偏移量",{"2":{"236":1}}],["类的对象就需要从",{"2":{"236":1}}],["类的对象不能直接访问它们",{"2":{"236":1}}],["类的or会包含额外的类特定成员",{"2":{"187":1}}],["类的or展示了方法向量和超类指针",{"2":{"187":1}}],["类的or具有类似的结构",{"2":{"187":1}}],["类的or不在本页范围内",{"2":{"187":1}}],["类层次结构分析可以消除许多这些调用的歧义",{"2":{"224":1}}],["类层次结构变化时",{"2":{"187":1}}],["类是它们超类的孩子",{"2":{"201":1}}],["类和代码指针",{"2":{"187":1}}],["类",{"2":{"187":3,"191":1}}],["类型推断",{"2":{"238":1}}],["类型系统由一组基本类型",{"2":{"235":1}}],["类型系统为程序中的每个值分配一个类型",{"2":{"235":1}}],["类型表示所有该类型的值共有的属性集合",{"2":{"235":1}}],["类型等价",{"0":{"230":1}}],["类型会有预期的效果",{"2":{"221":1}}],["类型在翻译过程中扮演着关键角色",{"2":{"173":1}}],["类型信息可以引导编译器进行高效执行的翻译",{"2":{"173":1}}],["类型信息",{"0":{"173":1},"1":{"191":1,"202":1,"209":1,"215":1,"221":1,"226":1,"230":1,"233":1,"235":1}}],["类型模板",{"2":{"33":1}}],["类似的论点也适用于将乘法和除法运算符合并为一个终结符muldiv",{"2":{"163":1}}],["类似于algol的语言通常使用词法作用域",{"2":{"187":1}}],["类似于它们的词性",{"2":{"131":1}}],["类似于这样",{"2":{"41":1}}],["类定义了对象的内容和形式",{"2":{"226":1}}],["类定义",{"2":{"139":1}}],["说实话感觉不明显",{"2":{"124":1}}],["说明找到了一种组合",{"2":{"68":1}}],["说明可以凑成总金额",{"2":{"58":1}}],["说思路就可以了",{"2":{"46":1}}],["说了一下编译原理的步骤",{"2":{"46":1}}],["说一个最大堆和一个最小堆",{"2":{"41":1}}],["说的越细越好",{"2":{"39":1}}],["场景题",{"2":{"41":1}}],["up",{"2":{"142":1}}],["u",{"2":{"106":4}}],["uncased",{"2":{"75":2}}],["unordered",{"2":{"65":1,"66":1,"90":1,"100":1,"101":2}}],["union",{"2":{"221":4}}],["unicode的编码空间是21位",{"2":{"47":1}}],["unicode",{"2":{"47":1}}],["unique",{"2":{"33":2}}],["utf",{"2":{"47":3}}],["uint32",{"2":{"41":1}}],["问题似乎更为严重",{"2":{"162":1}}],["问题就变成买卖股票的最佳时机",{"2":{"106":1}}],["问题就出现在这",{"2":{"43":1}}],["问题",{"2":{"67":1}}],["问题会出按列读取b的时候",{"2":{"46":1}}],["问了一下研究生期间的方向",{"2":{"46":1}}],["问我怎么解析",{"2":{"46":1}}],["问我哪人",{"2":{"43":1}}],["问我知道哪一个",{"2":{"41":1}}],["问我那里有问题",{"2":{"41":1}}],["问你输出",{"2":{"39":1}}],["锁与条件变量",{"2":{"41":1}}],["搜索引擎",{"0":{"40":1}}],["祝我好运吧",{"2":{"39":1}}],["简化控制流结构",{"2":{"207":1}}],["简化数据流分析",{"2":{"200":1}}],["简化数据流分析和优化",{"2":{"189":1}}],["简化了部分细节",{"2":{"176":1}}],["简称cfg",{"2":{"131":1}}],["简而言之",{"2":{"112":1}}],["简历上项目和存储没有一点关系",{"2":{"39":1}}],["简单lr解析器",{"2":{"142":1}}],["简单的对应就是一个cuda",{"2":{"4":1}}],["简单并行化矩阵乘法",{"0":{"4":1}}],["听说过aio",{"2":{"39":1}}],["六个",{"2":{"39":1}}],["他们也应该为编译器设计一套命名规范",{"2":{"140":1}}],["他们是做存储的",{"2":{"39":1}}],["他将每个状态",{"2":{"102":1}}],["他的主要思路是将dfa的状态进行划分",{"2":{"115":1}}],["他的书店开了n分钟",{"2":{"103":1}}],["他的子问题那么可以递归到第",{"2":{"50":1}}],["他的思路我大概知道",{"2":{"43":1}}],["他反问我和分布式哪个好",{"2":{"46":1}}],["他从socket的recv引导我说了这些",{"2":{"46":1}}],["他问我解决策略",{"2":{"46":1}}],["他要无时无刻运行操作系统的指令",{"2":{"46":1}}],["他就直接进行反问环节了",{"2":{"43":1}}],["他那界面又不好debug",{"2":{"43":1}}],["他说实习生早上有固定时间",{"2":{"46":1}}],["他说有开销",{"2":{"46":1}}],["他说还有没有什么高效的",{"2":{"46":1}}],["他说你直接说吞吐量",{"2":{"46":1}}],["他说应该如何分高效",{"2":{"46":1}}],["他说工作地点深圳怎么看的",{"2":{"43":1}}],["他说他们内部在讨论一下",{"2":{"41":1}}],["他说不要讲究语法",{"2":{"41":1}}],["他也提示了5分钟看成独立事件",{"2":{"41":1}}],["他也理解",{"2":{"39":1}}],["他给了模板",{"2":{"41":1}}],["他没追问了",{"2":{"39":1}}],["昨天这里说错了在他提醒下说对了",{"2":{"39":1}}],["报错",{"2":{"39":2,"195":1}}],[">clear",{"2":{"41":2}}],[">",{"2":{"39":5,"43":5,"53":2,"58":1,"63":1,"68":1,"69":1,"72":1,"73":1,"106":1,"204":3,"213":1}}],[">=len",{"2":{"107":1}}],[">=intervals",{"2":{"84":1}}],[">=x",{"2":{"53":1}}],[">=",{"2":{"16":4,"64":2,"90":1}}],["给程序员提供关于问题的洞察",{"2":{"173":1}}],["给定从值到数据区域的映射后",{"2":{"175":1}}],["给定文法",{"2":{"150":1,"153":1,"167":1,"184":1,"195":1}}],["给定两个字符串",{"2":{"99":1}}],["给定两个整数",{"2":{"76":1}}],["给定一个命名空间的模型和每个命名实体的类型信息",{"2":{"177":1}}],["给定一个名称x",{"2":{"159":1}}],["给定一个nfa",{"2":{"123":1}}],["给定一个长度为n的整数数组customers",{"2":{"103":1}}],["给定一个字符串",{"2":{"100":1}}],["给定一个区间的集合",{"2":{"84":1}}],["给定一个无重复元素的数组",{"2":{"78":1}}],["给定一个仅包含数字",{"2":{"73":1}}],["给定一个整数数组",{"2":{"106":1}}],["给定一个整数",{"2":{"72":1}}],["给定一个不含重复数字的数组",{"2":{"69":1}}],["给定一个未排序的整数数组nums",{"2":{"66":1}}],["给定一个数组",{"2":{"104":1}}],["给定一个数组nums",{"2":{"64":1}}],["给定一个数字",{"2":{"43":1}}],["给出一个常见的递归调用的例子",{"2":{"183":1}}],["给出一个文本引用",{"2":{"180":1}}],["给出的状态推入堆栈",{"2":{"145":1}}],["给出伪代码",{"2":{"134":1}}],["给出数字到字母的映射如下",{"2":{"73":1}}],["给出解题过程",{"2":{"63":1}}],["给出输出预期以及具体原因",{"2":{"39":1}}],["给你一个非负整数数组",{"2":{"107":1}}],["给你一个非严格递增排列的数组",{"2":{"80":1}}],["给你一个二进制字符串s和一个整数k",{"2":{"101":1}}],["给你一个整数k",{"2":{"93":1}}],["给你一个整数数组coins",{"2":{"58":1}}],["给你一个整数数组nums和两个正整数m和k",{"2":{"90":1}}],["给你一个整数数组nums",{"2":{"53":1}}],["给你一个整数数组",{"2":{"50":1,"68":1,"88":1}}],["给你一个长度为n下标从0开始的字符串blocks",{"2":{"93":1}}],["给你一个有序数组",{"2":{"87":1}}],["给你一个字符串数组",{"2":{"65":1}}],["给你10亿个数据如何寻找中位数",{"2":{"41":1}}],["给了一个多线程的代码",{"2":{"41":1}}],["给cuda",{"2":{"4":1}}],["e2",{"2":{"217":1}}],["e1",{"2":{"217":1}}],["eof",{"2":{"179":3,"195":2}}],["e→te",{"2":{"153":2}}],["err",{"2":{"204":4}}],["error",{"2":{"134":1}}],["erase",{"2":{"90":1,"100":1}}],["example",{"2":{"232":1}}],["examples=on",{"2":{"114":1}}],["exit",{"2":{"206":1,"229":2}}],["external",{"2":{"183":1}}],["expression",{"2":{"176":4}}],["expression的符号来描述拼写规则",{"2":{"105":1}}],["expr2",{"2":{"164":1}}],["expri",{"2":{"164":1}}],["expr",{"2":{"146":6,"163":1,"164":10}}],["execution",{"2":{"114":1}}],["ese​",{"2":{"102":1}}],["e",{"2":{"102":2,"106":3,"123":1,"153":7,"164":27,"170":3,"174":12,"206":4}}],["eac",{"0":{"97":1}}],["eat",{"2":{"65":2}}],["enum",{"2":{"215":2}}],["entry",{"2":{"206":1,"229":1}}],["enable",{"2":{"114":3}}],["encoding",{"2":{"75":1}}],["endi",{"2":{"84":1}}],["end",{"2":{"53":1,"65":1,"66":1,"84":1,"88":3,"164":2,"183":1,"190":1}}],["endl",{"2":{"39":5,"43":2}}],["epsilonb",{"2":{"167":2}}],["epsilont",{"2":{"153":1}}],["epsilone",{"2":{"153":1}}],["epsilona",{"2":{"150":1}}],["epsilons",{"2":{"150":1}}],["epsilon",{"2":{"75":1,"150":2}}],["emplace",{"2":{"69":1,"72":1}}],["emptysetfirst",{"2":{"188":3}}],["empty",{"2":{"63":1,"64":1}}],["embedding+position",{"2":{"75":2}}],["embedding+segment",{"2":{"75":2}}],["embedding",{"2":{"67":1,"75":8}}],["else部分和出口设置标签",{"2":{"223":1}}],["else构造之后的语句开始处",{"2":{"223":1}}],["else构造翻译成三地址码",{"2":{"223":1}}],["else构造",{"2":{"217":1}}],["elseelseelse",{"2":{"164":1}}],["else语句为例",{"2":{"164":1}}],["else语句",{"2":{"163":1}}],["else",{"2":{"7":2,"11":2,"43":6,"53":1,"84":1,"102":6,"134":2,"164":7,"183":1,"206":1,"214":2,"229":1}}],["布尔取反以及类型转换",{"2":{"162":1}}],["布隆过滤器的印象在数据库中好像有",{"2":{"39":1}}],["布局在没有这些私有成员的情况下发生变化",{"2":{"236":1}}],["布局的末尾",{"2":{"236":1}}],["布局上的这种转换将有助于从共享内存读取数据切片",{"2":{"29":1}}],["布局重新映射了",{"2":{"29":1}}],["想一想",{"2":{"106":1}}],["想起来好像是动态规划",{"2":{"39":1}}],["想象一下",{"2":{"4":1,"183":1}}],["尝试写了一会之后",{"2":{"39":1}}],["但这种类比可能并不成立",{"2":{"209":1}}],["但保持多种形式的一致性的复杂性使得这种做法并不常见",{"2":{"206":1}}],["但对代码实际执行方式提供的直接直觉很少",{"2":{"206":1}}],["但对于多数应用来说",{"2":{"130":1}}],["但仅对定义在同一文件内的过程可见",{"2":{"203":1}}],["但如果子类在不同的包内",{"2":{"201":1}}],["但仍比解析树更简洁",{"2":{"192":1}}],["但仍保留语法结构",{"2":{"176":1}}],["但其分配和回收成本较高",{"2":{"187":1}}],["但其思想",{"2":{"67":1}}],["但消除了冗余的节点",{"2":{"185":1}}],["但消除起来也不是很困难",{"2":{"150":1}}],["但接受的语法类别也是最广的",{"2":{"181":1}}],["但表的大小相似",{"2":{"181":1}}],["但表更大了",{"2":{"146":1}}],["但比解析树更简洁",{"2":{"176":2}}],["但比lr",{"2":{"142":2}}],["但它忠实地保留了源代码的结构",{"2":{"198":1}}],["但它的执行速度应该比对应的基于表的解析器更快",{"2":{"163":1}}],["但它们在抽象层次",{"2":{"151":1}}],["但它必须有一个机制",{"2":{"143":1}}],["但多了14行",{"2":{"146":1}}],["但合并它们可以带来性能上的提升",{"2":{"146":1}}],["但简化了解析树结构",{"2":{"146":1}}],["但通过查看下一个输入符号",{"2":{"142":1}}],["但编译器设计者可能希望在多个表中使用相同的基本策略",{"2":{"139":1}}],["但实践表明",{"2":{"130":1}}],["但实际上没有改变内存存放",{"2":{"46":1}}],["但却可以节省运行时间",{"2":{"187":1}}],["但却缩小了解析树的一层",{"2":{"129":1}}],["但却只能使用一次",{"2":{"103":1}}],["但该下标的最大跳跃长度是",{"2":{"107":1}}],["但由于扫描器很少只识别一个单词",{"2":{"102":1}}],["但被我否决了",{"2":{"46":1}}],["但不指定顺序",{"2":{"238":1}}],["但不会同时执行两者",{"2":{"206":1}}],["但不对兄弟子树的相对大小提供任何保证",{"2":{"139":1}}],["但不能同时包含两者",{"2":{"115":1}}],["但不完全一样大概如下",{"2":{"43":1}}],["但不多",{"2":{"39":1}}],["但感觉我最后答的还是有些问题",{"2":{"41":1}}],["但感觉也没说明白",{"2":{"41":1}}],["但我看牛客网上有人说",{"2":{"39":1}}],["但还是没深入了解过",{"2":{"39":1}}],["但都没深入了解过",{"2":{"39":1}}],["但是缺乏灵活性",{"2":{"187":1}}],["但是",{"2":{"162":1,"236":1}}],["但是如何确定这一点",{"2":{"155":1}}],["但是term的额外产生式使cc的大小从32个集合增加到了46个集合",{"2":{"146":1}}],["但是他不会对若干产生式进行尝试",{"2":{"122":1}}],["但是dfa的状态数量可能会非常多",{"2":{"115":1}}],["但是要强调的是nfa和dfa是等价的",{"2":{"112":1}}],["但是要注意的是",{"2":{"69":1,"72":1,"78":1}}],["但是归类我也不知道算不算贪心",{"2":{"107":1}}],["但是这种优化方法往往会降低可读性",{"2":{"93":1}}],["但是需要注意的是",{"2":{"90":1,"93":1,"103":1}}],["但是是双休",{"2":{"46":1}}],["但是也有压力",{"2":{"46":1}}],["但是会缺少cpu参与数据复制的那个过程",{"2":{"46":1}}],["但是转置本身就会造成这样的问题",{"2":{"46":1}}],["但是我看过cutlass的gemm实现",{"2":{"46":1}}],["但是还是打算自己重新记录整理一下",{"2":{"42":1}}],["但是还是最后返回结果的时候",{"2":{"39":1}}],["但是时至3",{"2":{"39":1}}],["但是真的忘了",{"2":{"39":1}}],["但是都忘了",{"2":{"39":1}}],["但是没咋总结",{"2":{"34":1}}],["但是应该共享进程中的栈",{"2":{"33":1}}],["但是一面挂",{"2":{"31":1}}],["但是物理位置上",{"2":{"29":1}}],["但是老师不会不喊我回去",{"2":{"22":1}}],["但是唯一的问题",{"2":{"22":1}}],["解除引用运算符",{"2":{"166":1}}],["解引用",{"2":{"162":1}}],["解析之后",{"2":{"238":1}}],["解析步骤",{"2":{"195":1}}],["解析成功",{"2":{"174":1,"195":1}}],["解析树通常作为语法分析的直接输出",{"2":{"192":1}}],["解析树的简化版本",{"2":{"176":1,"192":1}}],["解析树的节点由原来的14减少到现在的11个",{"2":{"129":1}}],["解析树主要用在关于解析的讨论中",{"2":{"168":1}}],["解析树相对于源文本来说较大",{"2":{"168":1}}],["解析树是输入程序推导过程或解析过程的图形化表示",{"2":{"168":1}}],["解析树",{"0":{"168":1,"176":1},"2":{"151":1,"158":1,"176":1,"192":1}}],["解析树可以轻松捕捉由解析器构建的推导",{"2":{"148":1}}],["解析过程示例",{"2":{"195":1}}],["解析过程的步骤",{"2":{"179":1}}],["解析过程",{"2":{"144":1,"174":1}}],["解析是编译器前端的第二个阶段",{"2":{"131":1}}],["解析",{"2":{"130":1}}],["解析器弹出句柄及其dfa状态",{"2":{"195":1}}],["解析器执行时",{"2":{"195":1}}],["解析器必须构造一种表示方式",{"2":{"180":1}}],["解析器生成器安排这些动作在解析过程中适当的点执行",{"2":{"159":1}}],["解析器生成器就可以实现预期的行为",{"2":{"145":1}}],["解析器就可以正常工作了",{"2":{"150":1}}],["解析器会丢弃输入直到它找到一个分号",{"2":{"145":1}}],["解析器可以以一种自然的方式构建一棵抽象语法树来表示控制流构造",{"2":{"217":1}}],["解析器可以在处理声明时为每个名称创建符号表条目并记录它们的属性",{"2":{"204":1}}],["解析器可以区分它们",{"2":{"180":1}}],["解析器可以提供其内部符号表给扫描器访问",{"2":{"180":1}}],["解析器可以通过一系列与产生式特定的任务来计算整数值",{"2":{"160":1}}],["解析器可以使用这些词来使输入与其内部状态同步",{"2":{"145":1}}],["解析器可以直接从标记读取符号表索引",{"2":{"139":1}}],["解析器需要一种可以从错误中",{"2":{"145":1}}],["解析器复杂",{"2":{"142":1}}],["解析器更强大",{"2":{"142":1}}],["解析器比slr",{"2":{"142":1}}],["解析器比lr",{"2":{"142":1}}],["解析器的效率来源于嵌入在action和goto表中的快速句柄查找机制",{"2":{"195":1}}],["解析器的扩展",{"2":{"142":1}}],["解析器的改进版本",{"2":{"142":1}}],["解析器是lr",{"2":{"142":1}}],["解析器简单",{"2":{"142":1}}],["解析器",{"2":{"142":3}}],["解析器为程序推导出一个句法结构",{"2":{"131":1}}],["解析器与由扫描器分词后的程序协同工作",{"2":{"131":1}}],["解析器负责将词法分析器生成的标记流转换为抽象语法树",{"2":{"131":1}}],["解析器中",{"2":{"129":1,"145":1,"146":2}}],["解析器主要分为自顶向下和自底向上两种",{"2":{"121":1}}],["解析表",{"0":{"126":1,"195":1},"1":{"144":1,"161":1,"179":1,"195":1},"2":{"174":1}}],["解释",{"2":{"50":3,"53":1,"58":1,"64":1,"66":1,"68":2,"78":1,"80":2,"84":2,"87":2,"90":3,"93":2,"99":2,"100":3,"101":3,"103":1,"104":2,"106":1,"107":2}}],["解决方案必须在工具提供的框架内工作",{"2":{"180":1}}],["解决方法",{"2":{"29":1}}],["解决这种歧义性需要额外的语义知识",{"2":{"180":1}}],["解决多语言同屏显示问题",{"2":{"47":1}}],["解码和编码",{"2":{"37":1}}],["写入初始值",{"2":{"155":1}}],["写的也很好",{"2":{"75":1}}],["写的很好",{"2":{"67":1}}],["写好之后",{"2":{"43":1}}],["写出来没有",{"2":{"43":1}}],["写出来了",{"2":{"39":1}}],["写个量化算法出来",{"2":{"37":1}}],["写到",{"2":{"29":1}}],["量化基本原理",{"2":{"37":1}}],["八股开始",{"2":{"37":1}}],["八个",{"2":{"29":1}}],["错误信息和错误恢复对于编译器用户的体验至关重要",{"2":{"196":1}}],["错误定位",{"2":{"196":1}}],["错误恢复例程随后会丢弃堆栈上的条目直至该状态",{"2":{"145":1}}],["错误恢复",{"0":{"145":1}}],["错误处理",{"2":{"144":1}}],["错",{"2":{"37":1}}],["互斥锁是用来干嘛的",{"2":{"37":1}}],["举例子",{"2":{"37":1}}],["至此先告一段落",{"0":{"36":1}}],["至于图中的shared",{"2":{"29":1}}],["录屏仅供事后复盘",{"2":{"35":1}}],["首先来几个要用的函数计算",{"2":{"179":1}}],["首先来探讨一下为什么扫描器中描述的正则表达式不能继续在解析器中使用",{"2":{"131":1}}],["首先",{"2":{"129":1,"169":1,"177":1}}],["首先可以计算老板不生气时的客户数量",{"2":{"103":1}}],["首先检查队列",{"2":{"63":1}}],["首先是计算效率的问题",{"2":{"47":1}}],["首先介绍了一下rdma的通信流程",{"2":{"46":1}}],["首先从矩阵最朴素的乘法开始写",{"0":{"1":1}}],["首尾逻辑没处理好",{"2":{"33":1}}],["怎么去学去了解用法",{"2":{"33":1}}],["了解跳表和布隆过滤器吗",{"2":{"39":1}}],["了解数据库吗",{"2":{"39":1}}],["了解raft选举过程吗",{"2":{"39":1}}],["了解awk命令吗",{"2":{"33":1}}],["了解过c++中new的实现",{"2":{"33":1}}],["只会产生更复杂的搜索路径",{"2":{"201":1}}],["只保留程序的逻辑结构",{"2":{"192":1}}],["只保留逻辑结构",{"2":{"176":2}}],["只包含对程序逻辑重要的节点",{"2":{"176":1}}],["只有一个入口点和一个出口点",{"2":{"206":1}}],["只有一个二进制特征为1",{"2":{"57":1}}],["只有",{"2":{"90":1}}],["只是要注意的是",{"2":{"73":1}}],["只是当时没想过",{"2":{"43":1}}],["只用面额",{"2":{"68":1}}],["只需要保留两个参数",{"2":{"50":1,"58":1}}],["只记得这些了",{"2":{"46":1}}],["只能答head",{"2":{"33":1}}],["只要被调函数遵循这一约定即可",{"2":{"187":1}}],["只要语言有一个定义前使用的规则",{"2":{"180":1}}],["只要可能",{"2":{"143":1}}],["只要对sa的load进行一个转置就可以了",{"2":{"19":1}}],["只要主要代码逻辑对了",{"2":{"8":1}}],["那就会放弃优化这个变量",{"2":{"155":1}}],["那一分钟的顾客就会不满意",{"2":{"103":1}}],["那为什么在机器学习中和深度学习中",{"2":{"47":1}}],["那两个io没听过",{"2":{"39":1}}],["那如何看文件",{"2":{"33":1}}],["那么n也可能是c的数据成员或是c的某个超类的数据成员",{"2":{"201":1}}],["那么该语言可能需要将一些名称解析和绑定推迟到运行时",{"2":{"201":1}}],["那么该值在控制权离开赋值发生的作用域后仍然保持",{"2":{"175":1}}],["那么使用",{"2":{"198":1}}],["那么使用c++",{"2":{"1":1}}],["那么编译器会按照声明给字段分配偏移量",{"2":{"234":1}}],["那么编译器必须构建一些混合搜索路径",{"2":{"201":1}}],["那么编译器可以从引用出现的作用域的表开始",{"2":{"201":1}}],["那么编译器可以从对象类的表开始",{"2":{"201":1}}],["那么编译器可以解析成员名称",{"2":{"201":1}}],["那么编译器应该生成代码来只计算一次",{"2":{"198":1}}],["那么编译器很可能会将堆栈机代码翻译成其他形式以用于代码生成",{"2":{"143":1}}],["那么b的计算地址将会丢失",{"2":{"197":1}}],["那么其or可以存储在为该方法创建的ar",{"2":{"187":1}}],["那么被调函数必须负责在函数开始时保存r的值",{"2":{"187":1}}],["那么大型软件系统将变得难以管理",{"2":{"183":1}}],["那么它可以看到并访问这些成员",{"2":{"201":1}}],["那么它是衍生的",{"2":{"182":1}}],["那么它应该被视为确定性的",{"2":{"182":1}}],["那么它必须包含一种机制来编码程序各点之间的控制转移",{"2":{"136":1}}],["那么这个证明就很容易完成",{"2":{"198":1}}],["那么这个值就是可见的",{"2":{"175":1}}],["那么这些列也可以合并",{"2":{"163":1}}],["那么优化的重点就放在改进堆栈计算上",{"2":{"143":1}}],["那么插入和查找可能会退化为每次查找o",{"2":{"139":1}}],["那么在哈希表中的插入和查找应该花费o",{"2":{"139":1}}],["那么在这种情况下它应该报告一个错误",{"2":{"102":1}}],["那么每项查找的预期时间应接近",{"2":{"139":1}}],["那么回到上面的例子",{"2":{"131":1}}],["那么最小化的等价dfa为",{"2":{"123":1}}],["那么最佳的方案nlogn复杂度的方案有些复杂",{"2":{"53":1}}],["那么对于子数组",{"2":{"106":1}}],["那么就只有非易失寄存器可用",{"2":{"155":1}}],["那么就说明到不了",{"2":{"107":2}}],["那么就扩大窗口",{"2":{"100":1}}],["那么就缩小窗口",{"2":{"100":1}}],["那么就有",{"2":{"11":1}}],["那么什么时候写入呢",{"2":{"87":1}}],["那么以",{"2":{"66":1}}],["那么递归边界和初始状态是什么呢",{"2":{"62":1,"74":1}}],["那么递归边界条件是什么呢",{"2":{"58":1}}],["那么递归边界条件是什么",{"2":{"50":1}}],["那么我们怎么样在获得最大利润",{"2":{"104":1}}],["那么我们以",{"2":{"66":1}}],["那么我们现在规定统一在买入股票的时候减",{"2":{"62":1}}],["那么我们可以得到状态方程",{"2":{"58":1}}],["那么我们可以选择",{"2":{"16":1}}],["那么和上体相比",{"2":{"62":1}}],["那么当",{"2":{"87":1}}],["那么当前的硬币数就是dp",{"2":{"58":2}}],["那么当天也是两种选择",{"2":{"50":1}}],["那么当天可以做出的选择是买出股票",{"2":{"50":1}}],["那么他们对应的编码应该如下图所示",{"2":{"57":1}}],["那么dp",{"2":{"53":1}}],["那么动态规划中",{"2":{"50":1,"58":1}}],["那么第",{"2":{"50":2}}],["那么五分钟没有车的概率是",{"2":{"41":1}}],["那么来进行优化",{"2":{"19":1}}],["那么如何实现这一点呢",{"2":{"7":1}}],["那么上面的代码存在的问题是什么呢",{"2":{"7":1}}],["那么griddim",{"2":{"4":1}}],["那么",{"2":{"1":1,"16":1,"19":1,"41":1,"66":1,"88":1,"103":1,"114":1,"115":1,"188":1,"236":1}}],["答案是显而易见的",{"2":{"230":1}}],["答案可以按",{"2":{"73":1}}],["答访存密集型",{"2":{"46":1}}],["答保护条件变量",{"2":{"37":1}}],["答重定向到文件",{"2":{"33":1}}],["答grep",{"2":{"33":1}}],["目标机器的结构变得至关重要",{"2":{"143":1}}],["目标函数",{"2":{"67":1}}],["目标词向量",{"2":{"67":1}}],["目标ip",{"2":{"33":1}}],["目的同样是为了避免溢出共享内存",{"2":{"11":1}}],["计网相关mac",{"2":{"33":1}}],["计算得出的名称",{"2":{"202":1}}],["计算得到形状为",{"2":{"16":1}}],["计算得到",{"2":{"16":1}}],["计算lr",{"2":{"195":1}}],["计算goto的步骤",{"2":{"179":1}}],["计算closure的步骤",{"2":{"179":1}}],["计算结果出现在树中的一个远离需要它的地方",{"2":{"178":1}}],["计算follow集合",{"2":{"170":1}}],["计算first集合",{"2":{"153":1}}],["计算规则",{"2":{"153":1,"170":1}}],["计算转移",{"2":{"144":1}}],["计算闭包",{"2":{"144":1}}],["计算了图中所有的路径",{"2":{"127":1}}],["计算w涂黑的操作",{"2":{"93":1}}],["计算复杂度",{"2":{"75":1}}],["计算使用和不使用第i个硬币的组合数之和",{"2":{"68":1}}],["计算凑成指定金额的硬币组合数",{"2":{"68":1}}],["计算凑成指定金额所需的最少硬币个数",{"2":{"58":1}}],["计算效率",{"2":{"67":1}}],["计算花费",{"2":{"63":1}}],["计算不使用第i个硬币和使用第i个硬币所需的最少硬币个数的最小值",{"2":{"58":1}}],["计算并返回可以凑成总金额所需的",{"2":{"58":1}}],["计算机中对文本的记录使用过编码来实现的",{"2":{"47":1}}],["计算当前层的起始值",{"2":{"43":1}}],["计算当前层的最小值",{"2":{"43":1}}],["计算",{"2":{"23":1,"29":1,"43":1}}],["计算的效率进一步提升",{"2":{"11":1}}],["计算部分积",{"2":{"7":1}}],["计算每个线程块需要迭代的次数",{"2":{"7":1}}],["用c语言的语法",{"2":{"215":1}}],["用作派生的中间表示",{"2":{"198":1}}],["用途",{"2":{"176":1}}],["用来将模型操作和中间表示",{"2":{"159":1}}],["用来查找存储数据",{"2":{"39":1}}],["用",{"2":{"155":1}}],["用哈希映射来避免逐个扫描带来的开销",{"2":{"139":1}}],["用它来更新答案的最大值",{"2":{"106":1}}],["用当前的前缀和",{"2":{"106":1}}],["用一个数来记录累积和",{"2":{"106":1}}],["用双圈进行表示",{"2":{"102":1}}],["用两个数组代替哈希表来记录",{"2":{"99":1}}],["用于变量定义和使用分析",{"2":{"206":1}}],["用于语义分析",{"2":{"176":1,"192":1}}],["用于语法分析",{"2":{"176":2,"192":1}}],["用于将变量放置到寄存器和数据区域中",{"2":{"175":1}}],["用于存储自动变量",{"2":{"175":1}}],["用于存储当前窗口内的最小价格及其对应的天数",{"2":{"63":1}}],["用于保存控制信息和过程调用的局部数据区",{"2":{"193":1}}],["用于保存数据值",{"2":{"175":1}}],["用于保存有关名称和值的信息",{"2":{"139":1}}],["用于建模命名环境的主要机制是一组表格",{"2":{"172":1}}],["用于测试下一个符号的类型并执行移进",{"2":{"163":1}}],["用于指定语法驱动的计算",{"2":{"159":1}}],["用于为",{"2":{"114":1}}],["用于计算从第i个硬币开始凑成金额c的组合数",{"2":{"68":1}}],["用于计算从第i个硬币开始凑成金额c所需的最少硬币个数",{"2":{"58":1}}],["用于记录已经计算过的状态",{"2":{"58":1,"68":1}}],["用在什么方面",{"2":{"37":1}}],["用过什么",{"2":{"37":1}}],["用分页器",{"2":{"33":1}}],["用户级本身相对于线程有什么性能上的好处",{"2":{"33":1}}],["用计算掩盖数据访问的耗时",{"2":{"23":1}}],["协程了解过吗",{"2":{"33":1}}],["9n5​",{"2":{"113":1}}],["9n1​",{"2":{"113":1}}],["98",{"2":{"47":1}}],["9=1",{"2":{"41":1}}],["9=1−",{"2":{"41":2}}],["9",{"2":{"33":1,"37":1,"43":2,"53":1,"63":2,"66":1,"73":1,"88":1,"90":9,"113":2}}],["别的malloc的实现",{"2":{"33":1}}],["堆的控制可以通过像linux中的malloc和free这样的调用显式进行",{"2":{"210":1}}],["堆分配",{"2":{"187":1}}],["堆分配和静态分配",{"2":{"187":1}}],["堆栈上的第一个这样的状态代表包含错误的语句",{"2":{"145":1}}],["堆栈模型",{"2":{"143":1}}],["堆上内存分配方案",{"2":{"33":1}}],["堆是共享的",{"2":{"33":1}}],["地址空间还有什么",{"2":{"33":1}}],["地址和",{"2":{"19":1}}],["栈和映射等这些抽象概念",{"2":{"191":1}}],["栈和堆可以相遇吗",{"2":{"33":1}}],["栈和堆的地址空间",{"2":{"33":1}}],["栈分配",{"2":{"187":2}}],["栈机制有效地管理了所有返回地址",{"2":{"183":1}}],["栈机代码通常用作定义性的中间表示",{"2":{"152":1}}],["栈机代码非常紧凑",{"2":{"152":1}}],["栈机代码是一种单地址码的形式",{"2":{"152":1}}],["栈机代码",{"0":{"152":1}}],["栈",{"2":{"174":1}}],["栈创建了一个隐式的命名空间",{"2":{"152":1}}],["栈的操作规则创建了一些新操作的需求",{"2":{"152":1}}],["栈是隔离的",{"2":{"33":1}}],["71",{"2":{"220":1}}],["7中的语法的嵌套if",{"2":{"217":1}}],["768",{"2":{"75":1}}],["7",{"2":{"33":1,"37":1,"43":2,"50":4,"53":4,"64":9,"66":1,"78":7,"87":2,"90":9,"93":3,"103":2,"104":3,"106":1,"113":1,"143":1,"213":3}}],["函数定义",{"0":{"225":1}}],["函数组合",{"2":{"183":1}}],["函数并行地读取它们适当参数的值",{"2":{"155":1}}],["函数的顺序",{"2":{"155":1}}],["函数的执行语义与其他操作不同",{"2":{"155":1}}],["函数的伪操作创建",{"2":{"155":1}}],["函数则选择它们的其他参数",{"2":{"155":1}}],["函数分别将xo和yo的值复制到x1和y1中",{"2":{"155":1}}],["函数具有不寻常的语义",{"2":{"155":1}}],["函数应返回新长度",{"2":{"87":2}}],["函数应该返回新的长度",{"2":{"80":2}}],["函数",{"2":{"75":1,"155":1}}],["函数里lambda捕获了局部变量",{"2":{"33":1}}],["函数返回值可以是lambda函数吗",{"2":{"33":1}}],["智能指针",{"2":{"33":1,"39":1}}],["拷打项目",{"2":{"33":1,"37":1,"39":1}}],["广告系统架构实习生",{"0":{"33":1}}],["什么时候用堆",{"2":{"33":1}}],["什么都没问",{"2":{"31":1}}],["什么是",{"2":{"19":1}}],["什么是bank",{"2":{"19":1}}],["前缀布局表现良好",{"2":{"236":1}}],["前缀布局策略实现了这个目标",{"2":{"236":1}}],["前缀和之前没咋用过",{"2":{"106":1}}],["前面的思路是类似的",{"2":{"62":1}}],["前进到",{"2":{"29":3}}],["前言",{"0":{"5":1,"9":1,"22":1},"1":{"8":1,"12":1,"26":1}}],["组成",{"2":{"102":1}}],["组合总和",{"0":{"71":1,"78":1},"1":{"78":1}}],["组合",{"0":{"70":1,"76":1},"1":{"76":1}}],["组合在一起",{"2":{"65":1}}],["组",{"2":{"29":1}}],["图遍历是程序中逻辑连接点之间高效移动的方式",{"2":{"228":1}}],["图形ir可以作为权威的ir",{"2":{"228":1}}],["图形ir中的抽象级别",{"2":{"228":1}}],["图形ir提供了正在编译的代码的抽象视图",{"2":{"228":1}}],["图形化的中间表示",{"0":{"151":1},"1":{"168":1,"185":1,"198":1,"206":1,"212":1,"218":1,"224":1,"228":1}}],["图形化ir将编译器的知识编码成图",{"2":{"149":1}}],["图5",{"2":{"216":1}}],["图展示了两个类定义",{"2":{"201":1}}],["图4",{"2":{"197":1}}],["图中无法被命名的值",{"2":{"197":1}}],["图中ars所示的部分信息可能会保存在专用寄存器中",{"2":{"187":1}}],["图中黑色菱形块",{"2":{"166":1}}],["图中的代码则创建了九个这样的值",{"2":{"197":1}}],["图中的代码仅创建了两个其他操作可以使用的值",{"2":{"197":1}}],["图中的树命名了许多在",{"2":{"197":1}}],["图中的例子展示了每个类都有一个完整的方法向量",{"2":{"187":1}}],["图中的tompson",{"2":{"127":1}}],["图中的",{"2":{"29":1}}],["图与底层代码之间的关系以及图的结构上有所不同",{"2":{"151":1}}],["图所示的表示形式也是",{"2":{"149":1}}],["图所示的树也是",{"2":{"149":1}}],["图或线性ir共存的辅助结构",{"2":{"148":1}}],["图或线性ir中的信息",{"2":{"148":1}}],["图",{"2":{"141":3,"155":1,"162":1,"178":2,"187":2,"218":2,"239":3}}],["图ir",{"0":{"135":1},"1":{"151":1,"168":1,"185":1,"198":1,"206":1,"212":1,"218":1,"224":1,"228":1}}],["图标",{"2":{"21":1}}],["存储类指导这些决定",{"2":{"240":1}}],["存储类别和可见性将特定变量名映射到存储区",{"2":{"177":1}}],["存储类别和数据区",{"2":{"177":1}}],["存储布局的时机直接关系到这个选择",{"2":{"238":1}}],["存储布局可以改变程序的局部性行为",{"2":{"175":1}}],["存储分配",{"0":{"222":1},"1":{"227":1,"231":1,"234":1,"236":1,"237":1}}],["存储分配决策可以编码有关底层代码属性的微妙知识",{"2":{"175":1}}],["存储上次调用的类和代码指针",{"2":{"187":1}}],["存储在",{"2":{"193":1}}],["存储在ar",{"2":{"187":1}}],["存储在基于指针的变量中的值通常是含糊的",{"2":{"157":1}}],["存储架构的优化",{"2":{"169":1}}],["存储内存模型",{"2":{"169":1}}],["存储加载到共享",{"2":{"29":1}}],["存在几种其他的用于构造lr风格解析器的算法",{"2":{"181":1}}],["存在多个产生式可以推导同一个非终结符",{"2":{"164":1}}],["存在于哈希集合中",{"2":{"66":1}}],["存在",{"2":{"66":2,"90":1}}],["存在一种共享内存",{"2":{"7":1}}],["切片",{"2":{"29":1}}],["级矩阵乘法的相同",{"2":{"29":1}}],["级矩阵乘法",{"2":{"29":1}}],["操作系统将多个虚拟地址空间映射到处理器支持的单一物理地址空间中",{"2":{"216":1}}],["操作系统会干什么",{"2":{"39":1}}],["操作符等",{"2":{"176":1}}],["操作符在其操作数的类型上被良好定义",{"2":{"173":1}}],["操作数和结果的独立命名给予编译器指定和控制名称及值的重用的自由",{"2":{"169":1}}],["操作码通常需要一到两个字节",{"2":{"169":1}}],["操作码和名称都来自有限的集合",{"2":{"169":1}}],["操作码和三个名称",{"2":{"169":1}}],["操作不变",{"2":{"129":1}}],["操作结束",{"2":{"113":1}}],["操作次数",{"2":{"93":1}}],["操作更新指针",{"2":{"29":1}}],["操作",{"2":{"29":1}}],["则意味着",{"2":{"233":1}}],["则调用图会有三条从p到q的边",{"2":{"224":1}}],["则不能访问",{"2":{"201":1}}],["则不以",{"2":{"66":1}}],["则它可以分配偏移量以消除浪费的空间",{"2":{"234":1}}],["则它们具有默认的可见性",{"2":{"201":1}}],["则它构建一个叶节点并记录词素",{"2":{"194":1}}],["则它构建一个内部节点来表示该操作符",{"2":{"194":1}}],["则沿c的超类链",{"2":{"201":1}}],["则沿类的继承链向上搜索",{"2":{"187":1}}],["则编译器可以将",{"2":{"193":1}}],["则必须从引用中推断出诸如类型之类的属性",{"2":{"190":1}}],["则必须直接权衡这些内存操作的成本与内存节省",{"2":{"163":1}}],["则对",{"2":{"188":1}}],["则对共享内存的访问将是无冲突的",{"2":{"29":1}}],["则应当使用point的方法向量并调用point",{"2":{"187":1}}],["则会搜索整个搜索路径",{"2":{"190":1}}],["则会在本地表中为声明的名称创建条目并用声明的属性填充它们",{"2":{"190":1}}],["则会存在两棵语法推导树",{"2":{"164":1}}],["则会利用",{"2":{"155":1}}],["则栈顶的相应符号序列就是句柄",{"2":{"161":1}}],["则将",{"2":{"153":2,"170":2}}],["则将其弹出",{"2":{"63":2}}],["则",{"2":{"153":2,"217":2}}],["则可能需要每个参数的类型和大小",{"2":{"139":1}}],["则是一个cpu核心计算了所有工作",{"2":{"4":1}}],["位于循环体顶部的",{"2":{"155":1}}],["位置编码",{"2":{"75":2}}],["位置的值",{"2":{"43":1}}],["位带符号整数",{"2":{"68":1}}],["位bank",{"2":{"29":4}}],["位",{"2":{"29":1,"88":1}}],["位向量",{"2":{"29":1}}],["或else子部分",{"2":{"223":1}}],["或线性的ir之一",{"2":{"206":1}}],["或线性",{"2":{"206":1}}],["或编辑类定义",{"2":{"201":1}}],["或源",{"2":{"186":1}}],["或称记录",{"2":{"221":1}}],["或称作用域",{"2":{"172":1}}],["或称为单词",{"2":{"131":1}}],["或有向无环图",{"2":{"168":1}}],["或ll",{"2":{"130":1}}],["或迫使推导呈现出特定的形式",{"2":{"129":1}}],["或许更易读",{"2":{"129":1}}],["或运算",{"2":{"105":1}}],["或不删除",{"2":{"53":1}}],["或出售股票",{"2":{"50":1}}],["或者设计它在翻译期间构建初始中间表示",{"2":{"238":1}}],["或者",{"2":{"203":1,"210":1,"233":1}}],["或者同时采用这两种方法来处理这些问题",{"2":{"196":1}}],["或者同一个",{"2":{"19":1}}],["或者是一个要新加的是dfa状态",{"2":{"113":1}}],["或者叫集合",{"2":{"105":1}}],["或者什么都不做",{"2":{"50":1}}],["或者用awk",{"2":{"33":1}}],["或",{"2":{"29":1,"206":1}}],["单独编译限制了编译器构建调用图的能力",{"2":{"224":1}}],["单语句块允许懒代码移动以比最大长度块更细的粒度优化代码放置",{"2":{"212":1}}],["单语句块可以使得某些类型的分析和优化更加直观和容易实现",{"2":{"212":1}}],["单语句块可以简化分析和优化的算法",{"2":{"212":1}}],["单语句cfg相较于基本块cfg会有更多的注解",{"2":{"212":1}}],["单语句",{"2":{"212":1}}],["单赋值",{"2":{"155":1}}],["单地址码模拟了累加器机器和栈机器的行为",{"2":{"136":1}}],["单个规则只能命名同一产生式中的符号",{"2":{"204":1}}],["单个文档或句子仅使用极少数码点",{"2":{"47":1}}],["单个线程加载一个",{"2":{"29":1}}],["单指令多线程",{"2":{"4":1}}],["范围的内存访问以蓝色突出显示",{"2":{"29":1}}],["逻辑上还是读取前两行",{"2":{"29":1}}],["相同的操作成本为o",{"2":{"231":1}}],["相同颜色的方块",{"2":{"29":1}}],["相比之下",{"2":{"201":1}}],["相对于acolorpoint调用draw实际上是调用了colorpoint",{"2":{"187":1}}],["相反",{"2":{"173":1,"182":1}}],["相形见绌",{"2":{"130":1}}],["相当于股票最低价格",{"2":{"106":1}}],["相当于一定要交易一次",{"2":{"106":1}}],["相当于伪代码",{"2":{"41":1}}],["相当于只有",{"2":{"19":1}}],["相关的产生式规则变为",{"2":{"180":1}}],["相关",{"2":{"33":1}}],["到目前为止的例子仅展示了语法中的本地计算",{"2":{"204":1}}],["到目前为止的讨论表明",{"2":{"187":1}}],["到实现的映射",{"2":{"187":2}}],["到j",{"2":{"179":1}}],["到closure集合",{"2":{"179":1}}],["到内存中的存储",{"2":{"157":1}}],["到内存中去",{"2":{"155":1}}],["到接受状态",{"2":{"127":1}}],["到达状态",{"2":{"112":1}}],["到达下标",{"2":{"107":1}}],["到到达",{"2":{"112":1}}],["到",{"2":{"29":3,"50":1,"88":2,"127":6,"206":1}}],["大大方便了优化",{"2":{"155":1}}],["大致来说",{"2":{"149":1}}],["大致流程",{"2":{"23":1}}],["大小和存储位置",{"2":{"139":1}}],["大多数实现将方法向量存储在类的",{"2":{"236":1}}],["大多数语言将结构体声明的内部视为一个新的作用域",{"2":{"234":1}}],["大多数语言允许过程向调用者返回一个或多个值",{"2":{"183":1}}],["大多数线性ir缺乏这种跨操作的连通性",{"2":{"228":1}}],["大多数or都是在堆上分配的",{"2":{"187":1}}],["大多数操作既包含定义又包含使用",{"2":{"218":1}}],["大多数操作由四个部分组成",{"2":{"169":1}}],["大多数操作具有",{"2":{"169":1}}],["大多数操作从栈中读取它们的操作数",{"2":{"152":1}}],["大多数关于命名空间的讨论都集中在源程序的命名空间上",{"2":{"140":1}}],["大多数编程语言允许程序员在至少以下存储类别中创建值",{"2":{"177":1}}],["大多数编程语言结构可以很好地适应这两种解析策略之一",{"2":{"130":1}}],["大多数编译器编写者会增强ir",{"2":{"165":1}}],["大多数编译器将符号表作为持久化的辅助数据结构来维护",{"2":{"139":1}}],["大多数系统会使用一种叫正则表达式regular",{"2":{"105":1}}],["大规模预训练",{"2":{"67":1}}],["大概十分钟",{"2":{"56":1}}],["大概就是从pytorch或者onnx模型导入tvm",{"2":{"46":1}}],["大概就是0",{"2":{"41":1}}],["大概的意思就是",{"2":{"29":1}}],["自底向上的信息流在这个范式中工作得很好",{"2":{"178":1}}],["自底向上解析器的工作过程",{"2":{"142":1}}],["自底向上解析器与lr",{"0":{"125":1},"1":{"142":1,"156":1,"174":1}}],["自底向上解析器通常使用自底向上的语法分析方法来实现",{"2":{"121":1}}],["自底向上解析器",{"0":{"142":1},"2":{"121":1,"125":1,"142":1}}],["自动变量",{"0":{"193":1},"2":{"193":1}}],["自动",{"2":{"175":2,"177":1}}],["自减",{"2":{"162":1}}],["自左向右扫描输入串",{"2":{"134":1}}],["自顶向下分析方法无法处理左递归",{"2":{"150":1}}],["自顶向下递归下降解析器以其相对简易的构造过程",{"2":{"130":1}}],["自顶向下解析器通常使用递归下降法来实现",{"2":{"121":1}}],["自顶向下解析器",{"2":{"121":1}}],["自顶向下解析器与ll",{"0":{"121":1},"1":{"134":1,"150":1,"167":1,"184":1}}],["自上而下的解析器执行一次展开操作",{"2":{"129":1}}],["自上而下和自下而上的解析器都会构建推导",{"2":{"129":1}}],["自注意力计算",{"2":{"75":1}}],["自己用就clone",{"2":{"33":1}}],["自己想的还不是特别明白",{"2":{"29":1}}],["自定义组件",{"0":{"2":1}}],["指向类的方法向量的指针",{"2":{"236":1}}],["指的是通过分析程序的dag表示来识别出程序中的重复计算或不必要的操作",{"2":{"198":1}}],["指的是主机架构",{"2":{"114":1}}],["指由相同字母重排列形成的字符串",{"2":{"99":1}}],["指针和目标寄存器的排列如上图右侧所示",{"2":{"29":1}}],["指令在函数栈上分配",{"2":{"155":1}}],["指令的前",{"2":{"29":1}}],["指令计算",{"2":{"29":1}}],["指令加载到",{"2":{"29":1}}],["读取下一个输入符号",{"2":{"195":1}}],["读取时",{"2":{"29":1}}],["读取数据到",{"2":{"23":2}}],["读两列",{"2":{"29":1}}],["因此它们是一种衍生的中间表示",{"2":{"218":1}}],["因此比较相同类型的元素是有意义的",{"2":{"215":1}}],["因此分配",{"2":{"203":1}}],["因此当从不同上下文中调用时",{"2":{"183":1}}],["因此表的行数也更少",{"2":{"181":1}}],["因此该语法是有歧义的的",{"2":{"180":1}}],["因此三地址码很好地模拟了它们的特性",{"2":{"169":1}}],["因此考虑缩小这棵解析树的方法是有价值的",{"2":{"168":1}}],["因此在解析器中",{"2":{"131":1}}],["因此在从",{"2":{"29":1}}],["因此处理完之后",{"2":{"115":1}}],["因此其幂集",{"2":{"113":1}}],["因此构从正则表达式构造识别器的下一步是将nfa转换为等价的dfa",{"2":{"113":1}}],["因此由状态图引入了形式化语言识别",{"2":{"102":1}}],["因此我们可以从nfa直接得到最小化dfa",{"2":{"123":1}}],["因此我们需要对dfa进行最小化",{"2":{"115":1}}],["因此我们很容易给出伪代码",{"2":{"102":1}}],["因此我们目前将这个错误路径故意模糊处理",{"2":{"102":1}}],["因此",{"2":{"66":1,"105":1,"112":1,"130":2,"132":3,"136":1,"139":1,"146":1,"155":1,"157":1,"159":1,"183":1,"187":5,"193":1,"197":1,"201":1,"210":1,"212":2,"221":2,"224":1}}],["因此长度为",{"2":{"53":1}}],["因我rdma达不到内存的速度",{"2":{"46":1}}],["因为每个节点只包含一个操作",{"2":{"212":1}}],["因为每次尝试解析s时都会再次调用解析s的过程",{"2":{"150":1}}],["因为其抽象层次较低",{"2":{"197":1}}],["因为对象的生命周期通常不与某个方法的一次激活相关联",{"2":{"187":1}}],["因为分配和释放仅涉及调整栈指针的位置",{"2":{"187":1}}],["因为分布式会多一个参与计算的节点",{"2":{"46":1}}],["因为过程调用是频繁发生的",{"2":{"187":1}}],["因为一个过程可能会被多次调用",{"2":{"187":1}}],["因为一开始也说了这是个有序数组",{"2":{"87":1}}],["因为无法确定选择哪个产生式",{"2":{"184":1}}],["因为无重复字符的最长子串是",{"2":{"100":3}}],["因为它限制了编译器能够看到的过程集合",{"2":{"224":1}}],["因为它将无法被命名",{"2":{"197":1}}],["因为它无法支持递归调用或是在编译期无法确定数量的过程调用",{"2":{"187":1}}],["因为它们的分配和释放可以作为进入和退出相应作用域的一部分来处理",{"2":{"175":1}}],["因为它们帮助编译器理解源代码的意义以及其实现",{"2":{"173":1}}],["因为它确定了名称的类型和访问方法",{"2":{"172":1}}],["因为它表示了完整的推导过程",{"2":{"168":1}}],["因为它对应于",{"2":{"29":1}}],["因为编译器以统一的方式处理隐含知识",{"2":{"166":1}}],["因为编译器通常只能优化中间表示",{"2":{"166":1}}],["因为编译器无法判断两个引用",{"2":{"157":1}}],["因为现在每个状态都需要代码",{"2":{"163":1}}],["因为语法拥有的终结符符号较少",{"2":{"163":1}}],["因为这些成本直接影响编译器的速度",{"2":{"205":1}}],["因为这在数学上几乎没有意义",{"2":{"162":1}}],["因为这将是在腾讯teg机器学习平台部实习的内容",{"2":{"40":1}}],["因为后面的",{"2":{"155":1}}],["因为他们以前用汇编语言编程",{"2":{"136":1}}],["因为有限自动机无法记录访问他同一状态的次数",{"2":{"131":1}}],["因为负数加上任何数都会变小",{"2":{"106":1}}],["因为卖出价格需要大于买入价格",{"2":{"104":1}}],["因为已经有",{"2":{"93":1}}],["因为允许只出现两次",{"2":{"87":1}}],["因为从后续递归来看",{"2":{"76":1}}],["因为以",{"2":{"66":1}}],["因为买入的价格产生的利润",{"2":{"50":1}}],["因为6月份有学校的中期",{"2":{"41":1}}],["因为是",{"2":{"29":1}}],["因为直接访问显存",{"2":{"23":1}}],["因为不同的",{"2":{"19":1}}],["因为实习没有统一的笔试题",{"2":{"8":1}}],["因为上面说了共享内存其实也就是被一个block里的线程所共享",{"2":{"7":1}}],["因为多线程",{"2":{"7":1}}],["因为",{"2":{"7":1,"167":1,"178":1}}],["共有",{"2":{"29":1}}],["共享内存",{"2":{"37":1}}],["共享内存可视化为",{"2":{"29":1}}],["共享内存可以理解为全局内存的缓存",{"2":{"7":1}}],["共享内存优化矩阵乘法v3",{"0":{"16":1}}],["共享内存优化矩阵乘法v2",{"0":{"11":1}}],["共享内存优化矩阵乘法",{"0":{"7":1}}],["最著名的跨过程变换",{"2":{"224":1}}],["最常见的替代块是单语句块",{"2":{"212":1}}],["最简洁的树结构",{"2":{"192":1}}],["最详细的树结构",{"2":{"192":1}}],["最接近程序的逻辑结构",{"2":{"176":1}}],["最接近语法规则",{"2":{"176":1}}],["最高",{"2":{"176":1}}],["最低",{"2":{"176":1}}],["最右推导的逆过程",{"2":{"156":1}}],["最右推导就是始终把最右边的非终结符替换掉",{"2":{"147":1}}],["最右非终结符a",{"2":{"147":1}}],["最右非终结符c",{"2":{"147":1}}],["最右非终结符b",{"2":{"147":1}}],["最左非终结符c",{"2":{"147":1}}],["最左非终结符b",{"2":{"147":1}}],["最左非终结符a",{"2":{"147":1}}],["最左推导就是始终把最左边的非终结符替换掉",{"2":{"147":1}}],["最左推导和最右推导很简单",{"2":{"147":1}}],["最左推导和最右推导",{"0":{"147":1}}],["最终消除间接左递归后的文法",{"2":{"167":1}}],["最终",{"2":{"155":1}}],["最终的解析器执行的归约更少",{"2":{"146":1}}],["最终得到总的最小花费",{"2":{"63":1}}],["最小化的dfa",{"2":{"123":1}}],["最小化的目的是减少dfa的状态数量",{"2":{"115":1}}],["最小化dfa采用的方法hopcroft",{"2":{"115":1}}],["最近收到两个面试通知",{"2":{"114":1}}],["最近准备阅读engineering",{"2":{"97":1}}],["最多包含一个产生式",{"2":{"188":1}}],["最多有多少客户能够感到满意",{"2":{"103":1}}],["最多出现两次的问题",{"2":{"87":1}}],["最少",{"2":{"93":1}}],["最少的硬币个数",{"2":{"58":1}}],["最长子串",{"2":{"100":1}}],["最长数字连续序列是",{"2":{"66":1}}],["最长连续序列",{"0":{"55":1,"66":1},"1":{"66":1}}],["最长递增子序列是",{"2":{"53":1}}],["最长递增子序列",{"0":{"45":1,"53":1},"1":{"53":1},"2":{"39":1}}],["最大利润",{"2":{"104":1,"106":1}}],["最大利润为",{"2":{"50":1}}],["最大子数组和",{"0":{"94":1,"106":1},"1":{"106":1}}],["最大和为",{"2":{"90":1}}],["最大长度",{"2":{"75":1}}],["最大值",{"2":{"64":1}}],["最大总利润为",{"2":{"50":2}}],["最大的问题是面我的面试官",{"2":{"39":1}}],["最后但同样重要的是",{"2":{"205":1}}],["最后把",{"2":{"188":1}}],["最后factorial",{"2":{"183":1}}],["最后",{"2":{"148":1,"155":2,"169":1,"183":1,"187":1,"233":1,"238":1}}],["最后如果这个点大于等于最后一个点",{"2":{"107":1}}],["最后判断",{"2":{"101":1}}],["最后是高纬稀疏醒的问题",{"2":{"47":1}}],["最后我好像听到他提了一句",{"2":{"46":1}}],["最后我和他说实在找不出来",{"2":{"43":1}}],["最后反问",{"2":{"46":1}}],["最后时间不够了他问了一道题",{"2":{"46":1}}],["最后一个数填进去的时候",{"2":{"43":1}}],["最后又问了我一下到岗时间",{"2":{"41":1}}],["最后面试官说应该用分桶来做",{"2":{"41":1}}],["最后用",{"2":{"29":1}}],["最佳适配",{"2":{"33":1}}],["最具重量级的优化cutlas源码实现",{"0":{"23":1},"1":{"29":1}}],["加载和存储",{"2":{"169":1}}],["加载到",{"2":{"29":1}}],["加入m",{"2":{"188":1}}],["加入",{"2":{"153":2,"170":2,"188":1}}],["加一提到循环外面",{"2":{"53":1}}],["加粗文字",{"2":{"21":1}}],["加粗",{"2":{"21":1}}],["暑期",{"0":{"26":1}}],["从现有类型构建新类型的规则",{"2":{"235":1}}],["从3到7的边反映了语句3中rb的定义及其在语句7中的后续使用",{"2":{"218":1}}],["从编译器的角度来看",{"2":{"216":1}}],["从编译代码质量的角度来看",{"2":{"140":1}}],["从当前块到下一个块",{"2":{"207":1}}],["从当前块到true和false目标块",{"2":{"207":1}}],["从当前块到目标块",{"2":{"207":1}}],["从数学上看",{"2":{"206":1}}],["从线性代码构建cfg",{"0":{"199":1},"1":{"207":1,"213":1,"219":1}}],["从栈中弹出|β|个符号",{"2":{"195":1}}],["从存储布局的角度来看",{"2":{"175":1}}],["从a1a",{"2":{"167":1}}],["从表中删除了行",{"2":{"163":1}}],["从过程调用到堆分配",{"2":{"159":1}}],["从变量引用到case语句",{"2":{"159":1}}],["从根本上说",{"2":{"159":1}}],["从根部开始",{"2":{"121":1}}],["从输入符号开始",{"2":{"142":1}}],["从字符串生成一个整数",{"2":{"139":1}}],["从符号表和继承表到结构布局表和常量表",{"2":{"139":1}}],["从名称到声明及其属性的映射必须明确定义",{"2":{"139":1}}],["从文本名称到仓库中索引的映射",{"2":{"139":1}}],["从dfa到正则表达式",{"0":{"127":1}}],["从而消除单独编译",{"2":{"233":1}}],["从而消除至少一层",{"2":{"129":1}}],["从而使调用图的构建成为迭代细化的过程",{"2":{"224":1}}],["从而使得构建大型软件系统成为可能",{"2":{"183":1}}],["从而简化了数据流分析",{"2":{"171":1}}],["从而产生多个不同的语法树",{"2":{"164":1}}],["从而产生更快的解析过程",{"2":{"129":1}}],["从而像c语言那样重载运算符",{"2":{"162":1}}],["从而缩小了ir的规模",{"2":{"152":1}}],["从而省去了额外的一次子集构造应用",{"2":{"141":1}}],["从而将nfa转换为dfa",{"2":{"123":1}}],["从而在每次购买食物时选择最便宜的选项",{"2":{"63":1}}],["从叶子开始",{"2":{"121":1}}],["从nfa转换为dfa的转换方法被称为subset",{"2":{"113":1}}],["从下标",{"2":{"107":1}}],["从1开始",{"2":{"105":1}}],["从题目看其实很简单",{"2":{"80":1}}],["从最后一个硬币开始计算凑成总金额的组合数",{"2":{"68":1}}],["从最后一个硬币开始计算凑成总金额所需的最少硬币个数",{"2":{"58":1}}],["从i向前来枚举",{"2":{"53":1}}],["从划分子问题开始",{"2":{"50":1}}],["从全局",{"2":{"29":1}}],["从",{"2":{"23":2,"29":4,"106":1,"127":2}}],["才会递归到到",{"2":{"76":1}}],["才会继续执行",{"2":{"23":1}}],["才能输出",{"2":{"72":1}}],["才能选左括号",{"2":{"72":2}}],["才能选右括号",{"2":{"72":2}}],["才能利用共享内存进行计算",{"2":{"7":1}}],["才说对",{"2":{"39":1}}],["都有充分的理由支持",{"2":{"234":1}}],["都有一个小的存储块来保存呼叫和返回过程所需控制信息",{"2":{"193":1}}],["都有一个共同的问题",{"2":{"145":1}}],["都将是无环的",{"2":{"206":1}}],["都将位于列",{"2":{"29":2}}],["都变成无限供应且只读的虚拟寄存器了",{"2":{"155":1}}],["都包含",{"2":{"153":1}}],["都包含了等价的dfa状态",{"2":{"115":1}}],["都是用来表示代码的图",{"2":{"151":1}}],["都可以表示为两个前缀和的差",{"2":{"106":1}}],["都不能为负",{"2":{"62":1,"74":1}}],["都没有对缓存编程",{"2":{"46":1}}],["都好久了事了",{"2":{"39":1}}],["都只有一个",{"2":{"29":1}}],["都达到",{"2":{"23":1}}],["都需要把",{"2":{"7":1}}],["如python或lisp",{"2":{"233":1}}],["如左所示",{"2":{"231":1}}],["如抽象语法树",{"2":{"228":1}}],["如下所示",{"2":{"206":1}}],["如下图",{"2":{"129":3}}],["如下图所示",{"2":{"23":1}}],["如上所示",{"2":{"204":1}}],["如smalltalk中",{"2":{"201":1}}],["如java中",{"2":{"201":1}}],["如java虚拟机那样",{"2":{"143":1}}],["如边栏所示",{"2":{"198":1}}],["如fee",{"2":{"180":1}}],["如括号",{"2":{"176":2}}],["如表达式",{"2":{"176":1}}],["如语法规则",{"2":{"176":1}}],["如跳转",{"2":{"169":1}}],["如立即加载和跳转",{"2":{"169":1}}],["如一元减",{"2":{"162":1}}],["如附录b",{"2":{"139":1}}],["如变量",{"2":{"139":1,"172":1,"201":1,"204":1}}],["如匹配",{"2":{"134":1}}],["如符号表",{"2":{"132":1}}],["如图2",{"2":{"129":1}}],["如图",{"2":{"123":1,"191":1}}],["如图所示",{"2":{"112":1}}],["如冒号分号",{"2":{"105":1}}],["如负采样",{"2":{"67":1}}],["如",{"2":{"67":1,"75":1,"190":1,"204":1}}],["如中文常用字约几千个",{"2":{"47":1}}],["如unicode包含百万级码点",{"2":{"47":1}}],["如u+4e25",{"2":{"47":1}}],["如word2vec",{"2":{"47":1}}],["如同义词",{"2":{"47":1}}],["如何用一个上下文无关",{"2":{"131":1}}],["如何来设计",{"2":{"39":1}}],["如何发给局域网机器",{"2":{"33":1}}],["如何发给机器",{"2":{"33":1}}],["如何解决",{"0":{"29":1}}],["如果它需要插入填充以达到下一个名称的对齐边界",{"2":{"239":1}}],["如果它被赋值",{"2":{"175":1}}],["如果对象记录",{"2":{"236":1}}],["如果由编译器控制结构体布局",{"2":{"234":1}}],["如果声明决定了布局",{"2":{"234":1}}],["如果代码从p中的三个文本上不同的位置调用q",{"2":{"224":1}}],["如果代码重新计算",{"2":{"210":1}}],["如果c程序取变量a的地址",{"2":{"204":1}}],["如果c++编译器能够证明某个虚方法调用有一个已知不变的接收者类",{"2":{"187":1}}],["如果语言不要求声明",{"2":{"238":1}}],["如果语言需要声明",{"2":{"238":1}}],["如果语言的语法无法区分对象的数据成员和普通变量",{"2":{"201":1}}],["如果语言允许正在运行的程序通过在运行时导入类定义",{"2":{"201":1}}],["如果名称的语法表明它是一个",{"2":{"201":1}}],["如果名称的语法表明它是一个对象相对引用",{"2":{"201":1}}],["如果子类也在同一个包内",{"2":{"201":1}}],["如果成员没有指定访问控制修饰符",{"2":{"201":1}}],["如果搜索失败",{"2":{"201":1}}],["如果p是定义在某个类c中的方法",{"2":{"201":1}}],["如果ool要求类定义必须在编译时存在且这些定义不能改变",{"2":{"201":1}}],["如果内存限制制约了编译器能够处理的程序大小",{"2":{"198":1}}],["如果表达式既不包含赋值也不包含对其他程序的调用",{"2":{"198":1}}],["如果a的值在这两个使用位置之间不会发生变化",{"2":{"198":1}}],["如果action",{"2":{"179":1,"195":4}}],["如果action表指示可以进行归约操作",{"2":{"161":1}}],["如果附近的代码引用了这些位置中的任何一个",{"2":{"197":1}}],["如果产生式存在是为了强制优先级",{"2":{"194":1}}],["如果作用域包含在",{"2":{"193":1}}],["如果未能在本地表中找到名称",{"2":{"190":1}}],["如果未能匹配到相应的字符",{"2":{"102":1}}],["如果不存在声明",{"2":{"190":1}}],["如果不是实习时长的问题",{"2":{"22":1}}],["如果将acolorpoint转换为point",{"2":{"187":1}}],["如果将每个unicode码点直接作为特征",{"2":{"47":1}}],["如果被调方有责任在其自身执行期间保持寄存器r的值不变",{"2":{"187":1}}],["如果被调方在开始执行之前保存了一个寄存器",{"2":{"187":1}}],["如果调用方有责任在一次调用前后保持寄存器r的值不变",{"2":{"187":1}}],["如果调用方在跳转到被调方之前保存了一个寄存器",{"2":{"187":1}}],["如果源语言允许程序员为变量指定初始值",{"2":{"187":1}}],["如果一个产生式推导出一个名称或数字",{"2":{"194":1}}],["如果一个产生式包含一个操作符",{"2":{"194":1}}],["如果一个对象的生命周期受限于某个方法的激活",{"2":{"187":1}}],["如果一个ir是从一个阶段传递到另一个阶段的",{"2":{"182":1}}],["如果一个值可以被命名",{"2":{"175":1}}],["如果在翻译期间没有类型信息",{"2":{"173":1}}],["如果在编译器中使用的权威ir是线性ir",{"2":{"136":1}}],["如果存在产生式",{"2":{"170":2}}],["如果存在这样的转换",{"2":{"112":1}}],["如果这种空间缩减为每次表访问添加了额外的间接层",{"2":{"163":1}}],["如果这个点小于当前的点",{"2":{"107":1}}],["如果goto",{"2":{"179":2}}],["如果goto表中有若干状态对于非终结符有着相同的转移状态",{"2":{"163":1}}],["如果grep输出的内容特别多",{"2":{"33":1}}],["如果该引用的细节是隐含的",{"2":{"166":1}}],["如果该函数中还调用了其他函数",{"2":{"155":1}}],["如果该状态已经计算过",{"2":{"58":1,"68":1}}],["如果实在避免不了",{"2":{"155":1}}],["如果需要能修改的变量",{"2":{"155":1}}],["如果遇到了一个语法错误",{"2":{"145":1}}],["如果ir是在某个阶段内部为特定目的而构建",{"2":{"182":1}}],["如果isa是cisc或risc处理器",{"2":{"143":1}}],["如果input回滚到fence就直接报错",{"2":{"124":1}}],["如果指令集架构",{"2":{"143":1}}],["如果所有",{"2":{"153":1}}],["如果所有的键都映射到相同的表索引上",{"2":{"139":1}}],["如果所有长度为k的二进制字符串都是s的子串",{"2":{"101":1}}],["如果键集不产生冲突",{"2":{"139":1}}],["如果编译器找到了对象o的成员m的引用",{"2":{"201":1}}],["如果编译器在某个过程p中找到对未限定名称n的引用",{"2":{"201":1}}],["如果编译器在中间表示",{"2":{"198":1}}],["如果编译器在程序的某个位置p发现了一个对名称n的引用",{"2":{"139":1}}],["如果编译器将名称to重新用于另一个值",{"2":{"197":1}}],["如果编译器每次编译都需要整个程序的文本",{"2":{"183":1}}],["如果编译器试图在对y进行赋值的过程中将x保持在一个寄存器中",{"2":{"157":1}}],["如果编译器需要文本查找功能",{"2":{"139":1}}],["如果编译器编写者担心哈希可能出现的最坏情况",{"2":{"139":1}}],["如果编译器能够在一次遍历中收集信息并在另一次遍历中使用这些信息",{"2":{"132":1}}],["如果是这样",{"2":{"136":1}}],["如果解析器发现错误",{"2":{"131":1}}],["如果解析器确定输入流是一个有效的程序",{"2":{"131":1}}],["如果我们对某个前缀从开始状态有多条路径的nfa应用子集构造方法",{"2":{"123":1}}],["如果你的电脑上是amd的gpu",{"2":{"114":1}}],["如果你是在",{"2":{"114":1}}],["如果你不能获取任何利润",{"2":{"104":1}}],["如果之前的点小于当前点",{"2":{"107":1}}],["如果可以",{"2":{"107":1}}],["如果要计算的子数组恰好是一个前缀",{"2":{"106":1}}],["如果书店老板在第i分钟生气",{"2":{"103":1}}],["如果字符串由",{"2":{"102":1}}],["如果程序的唯一目的是识别",{"2":{"102":1}}],["如果nums的一个子数组有至少m个互不相同的元素",{"2":{"90":1}}],["如果知道了",{"2":{"88":1}}],["如果数组长度小于等于2则直接返回",{"2":{"87":1}}],["如果有声明",{"2":{"204":1}}],["如果有重叠",{"2":{"84":1}}],["如果有gpu的前置知识的话这个也很容易理解并写出来",{"2":{"4":1}}],["如果任何硬币组合都无法凑出总金额",{"2":{"68":1}}],["如果",{"2":{"66":4,"115":2,"153":4,"170":1,"173":2,"188":1,"193":2,"217":2,"236":1}}],["如果双端队列头部元素的索引小于等于",{"2":{"63":1}}],["如果双端队列",{"2":{"63":1}}],["如果其对应的天数已经不在当前窗口内",{"2":{"63":1}}],["如果其价格大于当前天的价格",{"2":{"63":1}}],["如果结果小于",{"2":{"58":1}}],["如果当前字符在窗口中不存在",{"2":{"100":1}}],["如果当前字符在窗口中已经存在",{"2":{"100":1}}],["如果当前金额为0",{"2":{"68":1}}],["如果当前金额小于第i个硬币的面额",{"2":{"58":1,"68":1}}],["如果当天状态是可以卖出",{"2":{"50":1}}],["如果当天的状态是可以买入",{"2":{"50":1}}],["如果无法凑成则返回",{"2":{"58":1}}],["如果没有硬币可选",{"2":{"68":1}}],["如果没有任何一种硬币组合能组成总金额",{"2":{"58":1}}],["如果没有排列布局",{"2":{"29":1}}],["如果什么都不做利润为",{"2":{"50":1}}],["如果每个",{"2":{"29":1}}],["如果每个线程访问的",{"2":{"19":1}}],["如果多个线程访问了同一个4b",{"2":{"19":1}}],["主要讨论了如何描述并识别编程语言的语法结构",{"2":{"131":1}}],["主要递归边界和条件直接给出代码",{"2":{"68":1}}],["主要针对特定长度的矩阵",{"2":{"16":1}}],["主循环中",{"2":{"23":1}}],["主循环的一轮开始前",{"2":{"23":1}}],["主循环内加载数据和计算可以",{"2":{"23":1}}],["限于smem",{"2":{"23":1}}],["放到",{"2":{"23":1}}],["放在最快的寄存器",{"2":{"23":1}}],["矩阵乘法",{"2":{"37":1}}],["矩阵乘法从0开始优化到cutlas",{"0":{"0":1},"1":{"1":1,"4":1,"7":1,"11":1,"16":1,"19":1,"23":1,"29":1,"36":1}}],["矩阵",{"2":{"29":1}}],["矩阵一般一次只加载一部分到smem",{"2":{"23":1}}],["矩阵的数据因为需要被各线程共享",{"2":{"23":1}}],["输入符号",{"2":{"179":1,"195":1}}],["输入符号栈",{"2":{"179":1,"195":1}}],["输入字符串符合语法规则",{"2":{"174":1}}],["输入字符串",{"2":{"174":1}}],["输入数组中不存在长度为",{"2":{"90":1}}],["输入表示",{"2":{"75":1}}],["输入词向量",{"2":{"67":1}}],["输入层到隐藏层的权重矩阵",{"2":{"67":1}}],["输入",{"2":{"50":3,"53":1,"58":3,"63":4,"64":2,"65":3,"66":2,"68":3,"69":3,"72":2,"73":3,"76":2,"78":3,"80":2,"84":2,"87":2,"88":2,"90":3,"93":2,"99":2,"100":3,"101":3,"103":2,"104":2,"106":3,"107":2,"174":1,"195":1}}],["输入示例",{"2":{"43":2}}],["输入矩阵因为要做频繁的累加计算",{"2":{"23":1}}],["输出",{"2":{"50":3,"53":1,"58":3,"63":4,"64":2,"65":3,"66":2,"68":3,"69":3,"72":2,"73":3,"76":2,"78":3,"80":2,"84":2,"87":2,"88":2,"90":3,"93":2,"99":2,"100":3,"101":3,"103":2,"104":2,"106":3,"107":2,"183":1}}],["输出矩阵",{"2":{"43":1}}],["输出示例",{"2":{"43":2}}],["输出hello",{"2":{"39":1}}],["输出a=100",{"2":{"39":2}}],["输出的",{"2":{"23":1}}],["为字符数组实现类似的比较暗示了这一想法可以应用于数字或结构体数组",{"2":{"209":1}}],["为每个赋值创建新的变量名",{"2":{"208":1}}],["为每个识别出的基本块创建节点",{"2":{"207":1}}],["为每一个非终结符写一个分析过程",{"2":{"134":1}}],["为每一个",{"2":{"23":1}}],["为100",{"2":{"202":1}}],["为在类中定义的名称创建一个新的表",{"2":{"201":1}}],["为大多数值提供了必要的存储",{"2":{"187":1}}],["为数据区域分配值",{"0":{"175":1}}],["为编译器提供优化的机会",{"2":{"148":1}}],["为元素出现的次数",{"2":{"90":1}}],["为元素",{"2":{"90":1}}],["为什么要额外定义它",{"2":{"106":1}}],["为什么",{"2":{"66":1}}],["为起点的连续序列",{"2":{"66":2}}],["为起点的连续序列会包含以",{"2":{"66":1}}],["为起点的连续序列的长度",{"2":{"66":1}}],["为起点的连续序列的长度一定不会超过以",{"2":{"66":1}}],["为起点计算出的序列长度要长",{"2":{"66":1}}],["为起点计算出的序列长度",{"2":{"66":1}}],["为起点",{"2":{"66":3}}],["为0",{"2":{"63":1}}],["为",{"2":{"29":1,"106":1,"127":1}}],["为了创建图",{"2":{"239":1}}],["为了获得正确的对齐",{"2":{"239":1}}],["为了调和这些竞争的偏移量",{"2":{"237":1}}],["为了减少存储需求",{"2":{"236":1}}],["为了确保",{"2":{"236":1}}],["为了确保这种互操作性",{"2":{"236":1}}],["为了确定名称的身份",{"2":{"201":1}}],["为了表示过程之间的调用",{"2":{"224":1}}],["为了在过程边界之外优化代码",{"2":{"224":1}}],["为了在旅途中保持充足的能量",{"2":{"63":1}}],["为了将if",{"2":{"223":1}}],["为了将中间表示",{"2":{"155":1}}],["为了建模这些复杂的命名环境",{"2":{"201":1}}],["为了解析成员名称",{"2":{"201":1}}],["为了解决这个问题",{"2":{"180":1}}],["为了简化框架",{"2":{"194":1}}],["为了管理过程",{"2":{"193":1}}],["为了支持开放的类层次结构",{"2":{"187":2}}],["为了提高性能",{"2":{"187":1}}],["为了提高效率",{"2":{"187":1}}],["为了提高带宽",{"2":{"19":1}}],["为了形成块",{"2":{"186":1}}],["为了记录编译器必须编码的所有细节",{"2":{"165":1}}],["为了完成这些任务",{"2":{"159":1}}],["为了保证所有用到的变量都存到寄存器中",{"2":{"155":1}}],["为了保证正确性需要进行寄存器分配",{"2":{"143":1}}],["为了澄清这些规则的影响",{"2":{"155":1}}],["为了满足这些需求",{"2":{"148":1}}],["为了使用多重集判别",{"2":{"139":1}}],["为了避免这个问题",{"2":{"139":1}}],["为了构建哈希表",{"2":{"139":1}}],["为了实现过程调用和词法作用域名称空间的双重抽象",{"2":{"187":1}}],["为了实现不用回溯",{"2":{"137":1}}],["为了实现无冲突存储",{"2":{"29":1}}],["为了加载上图右侧的矩阵",{"2":{"29":1}}],["为了加速计算",{"2":{"4":1}}],["为了后续从share",{"2":{"29":1}}],["各种树之间的区别",{"0":{"158":1},"1":{"176":1,"192":1}}],["各种括号",{"2":{"105":1}}],["各",{"2":{"23":1}}],["把硬件寄存器数量容纳不下或无法变成单次静态赋值的部分变量",{"2":{"155":1}}],["把起始状态变为终止状态",{"2":{"123":1}}],["把gemm实现和他说一堆",{"2":{"46":1}}],["把数据加载到buffer",{"2":{"41":1}}],["把",{"2":{"23":1,"66":1,"93":1,"155":1}}],["寒假实际上能实习的时间就是一个月左右",{"2":{"22":1}}],["南京的后摩智能面试体验也很好",{"2":{"22":1}}],["面向对象语言则在命名空间中添加了一个基于继承的层次结构",{"2":{"187":1}}],["面向对象语言",{"2":{"187":1}}],["面壁智能未面",{"2":{"22":1}}],["面试一开始纯聊天",{"2":{"43":1}}],["面试官一步一步引导我说出来的",{"2":{"46":1}}],["面试官说他的意思是要直接打印出来这个矩阵",{"2":{"43":1}}],["面试官首先做了自我介绍",{"2":{"41":1}}],["面试官问我论文",{"2":{"39":1}}],["面试官问起来只能说不懂",{"2":{"39":1}}],["面试官向领导申请之后",{"2":{"22":1}}],["面试官那边也就过了",{"2":{"8":1}}],["面试体验度排行",{"2":{"22":1}}],["面试手撕大概率不会要你从控制台读输入",{"2":{"8":1}}],["实例以及类的",{"2":{"236":1}}],["实例反映了这一事实",{"2":{"198":1}}],["实现者必须规划所有的信息流",{"2":{"178":1}}],["实现者必须考虑内存大小与任何访问成本增加之间的权衡",{"2":{"163":1}}],["实现该虚拟机的解释器",{"2":{"152":1}}],["实现这一目标的常见方法是选择一个或多个词",{"2":{"145":1}}],["实现过什么",{"2":{"37":1}}],["实用主题",{"0":{"128":1},"1":{"145":1,"162":1,"180":1,"196":1}}],["实习生应该就要尽快入职的",{"2":{"22":1}}],["实际考虑因素",{"0":{"205":1}}],["实际的运行时间取决于fa的具体属性",{"2":{"141":1}}],["实际优化了一下",{"2":{"88":1}}],["实际挺复杂的",{"2":{"63":1}}],["实际文本中",{"2":{"47":1}}],["实际上",{"2":{"130":1,"139":1,"141":1,"157":1,"175":1,"178":1,"187":1,"205":1,"224":1}}],["实际上这两个堆都会拓展的",{"2":{"41":1}}],["实际上上图对sa还做了一次转置来避免bank",{"2":{"16":1}}],["实际会延长",{"2":{"33":1}}],["实际在矩阵乘法中",{"2":{"7":1}}],["沟通offer是否能留到寒假",{"2":{"22":1}}],["是在单独的字段中存储长度值",{"2":{"231":1}}],["是在第i分钟开始时进入商店的顾客数量",{"2":{"103":1}}],["是边集合",{"2":{"206":1}}],["是节点集合",{"2":{"206":1}}],["是表示程序控制流结构的图形化中间表示",{"2":{"206":1}}],["是ast的一种压缩形式",{"2":{"198":1}}],["是程序存储",{"2":{"194":1}}],["是局部的",{"2":{"193":1}}],["是面向对象语言运行时支持的核心组成部分",{"2":{"187":1}}],["是函数式编程中的一个重要概念",{"2":{"183":1}}],["是大多数编程语言中的核心抽象之一",{"2":{"183":1}}],["是解析树的简化版本",{"2":{"176":1}}],["是实数或负数",{"2":{"173":1}}],["是实习时长的问题",{"2":{"22":1}}],["是非负整数",{"2":{"173":1}}],["是非终结符且",{"2":{"153":2}}],["是语法分析过程中需要归约的最小单位",{"2":{"161":1}}],["是当前输入串的最左可归约子串",{"2":{"161":1}}],["是编译器和解释器中常用的三种树形数据结构",{"2":{"158":1}}],["是两个独立的赋值",{"2":{"155":1}}],["是完全类型的",{"2":{"154":1}}],["是终结符",{"2":{"153":1}}],["是任意的文法符号串",{"2":{"153":1}}],["是lr解析算法正确性的关键",{"2":{"161":1}}],["是lr",{"2":{"142":1}}],["是输入有限自动机",{"2":{"141":1}}],["是输出权重矩阵",{"2":{"75":1}}],["是其在分类单词或标记列表中的序数位置",{"2":{"139":1}}],["是标识符的词素",{"2":{"139":1}}],["是树中的项目数量",{"2":{"139":1}}],["是列表中的项目数量",{"2":{"139":1}}],["是有限的",{"2":{"113":1}}],["是有上限的",{"2":{"105":1}}],["是dfa的初始状态",{"2":{"113":1}}],["是该集合中所有状态的集合",{"2":{"113":1}}],["是以",{"2":{"110":1}}],["是最大的和",{"2":{"90":1}}],["是维度索引",{"2":{"75":1}}],["是位置索引",{"2":{"75":1}}],["是可学习参数",{"2":{"75":1}}],["是均值和方差",{"2":{"75":1}}],["是第",{"2":{"75":1}}],["是向量维度",{"2":{"75":1}}],["是一种基于",{"2":{"232":1}}],["是一种特殊的中间表示形式",{"2":{"171":1}}],["是一种三地址码",{"2":{"169":1}}],["是一种从输入符号开始",{"2":{"142":1}}],["是一种自底向上的解析器",{"2":{"121":1}}],["是一种自顶向下的解析器",{"2":{"121":1}}],["是一种经典的词嵌入",{"2":{"67":1}}],["是一个有效的",{"2":{"145":1}}],["是一个子序列",{"2":{"100":1}}],["是一个",{"2":{"23":1}}],["是由重新排列源单词的所有字母得到的一个新单词",{"2":{"65":1}}],["是由数组派生而来的序列",{"2":{"53":1}}],["是数组",{"2":{"53":1}}],["是他们teg云架构平台部下面的小部门做存储的",{"2":{"39":1}}],["是否包含",{"2":{"236":1}}],["是否能指代同一个元素",{"2":{"157":1}}],["是否超过的硬件寄存器的数量上限",{"2":{"155":1}}],["是否采用lr",{"2":{"130":1}}],["是否在哈希集合中",{"2":{"66":1}}],["是否存在于哈希集合中",{"2":{"66":1}}],["是否所有都可以重写和重载",{"2":{"37":1}}],["是否用过抓包工具",{"2":{"33":1}}],["是保持条件变量wait操作的原子性",{"2":{"37":1}}],["是加载好的",{"2":{"23":1}}],["是",{"2":{"23":2,"67":1,"75":2,"113":3}}],["是对每个线程私有的",{"2":{"23":1}}],["是汽车智能驾驶相关业务的",{"2":{"22":1}}],["是为了位于内部循环",{"2":{"7":1}}],["辉羲",{"2":{"22":1}}],["≈1",{"2":{"67":2}}],["≈",{"2":{"22":1}}],["百度",{"0":{"32":1},"2":{"22":1}}],["卓驭高性能计算",{"0":{"25":1},"1":{"31":1}}],["卓驭",{"0":{"31":1},"2":{"22":1}}],["腾讯teg云架构平台部",{"2":{"39":1}}],["腾讯云基础架构部门",{"0":{"35":1},"1":{"39":1,"43":1,"49":1}}],["腾讯云架构平台部",{"2":{"22":1}}],["腾讯机器学习平台部",{"0":{"38":1},"1":{"41":1,"46":1,"56":1},"2":{"22":1}}],["小规模语料",{"2":{"67":1}}],["小r最多能同时携带食物的份数",{"2":{"63":1}}],["小r希望在保证每天食物消耗的前提下",{"2":{"63":1}}],["小r在路途中每天都会经过一个补给站",{"2":{"63":1}}],["小r每天必须消耗1份食物",{"2":{"63":1}}],["小r正在计划一次从地点a到地点b的徒步旅行",{"2":{"63":1}}],["小米训练框架优化",{"0":{"28":1},"1":{"34":1}}],["小米",{"0":{"34":1},"2":{"22":1}}],["小红书训练推理引擎",{"0":{"30":1},"1":{"37":1}}],["小红书",{"0":{"37":1},"2":{"22":1}}],["墨芯的岗是ai编译器岗",{"2":{"22":1}}],["墨芯",{"2":{"22":1}}],["后端又一样能正常生成汇编",{"2":{"155":1}}],["后端代码优化那里聊了一个mem2reg的优化",{"2":{"46":1}}],["后端代码生成和优化",{"2":{"46":1}}],["后",{"2":{"115":2}}],["后能到达的nfa状态的",{"2":{"113":1}}],["后文简称re",{"2":{"105":1}}],["后文简称fa",{"2":{"102":1}}],["后整理了",{"2":{"97":1}}],["后来他提醒了一下",{"2":{"46":1}}],["后来又说了set",{"2":{"46":1}}],["后面的章节中会专门介绍",{"2":{"155":1}}],["后面利用llvm来实现lox的时候",{"2":{"114":1}}],["后面应该会推进流程",{"2":{"46":1}}],["后面应该会更新简单说一说gpu的编程模型",{"2":{"4":1}}],["后面我用大模型写了一个如下",{"2":{"43":1}}],["后面我还说了归并排序的思路",{"2":{"41":1}}],["后面又做了一题打印zig矩阵的",{"2":{"43":1}}],["后面又问我对分布式有哪些了解",{"2":{"43":1}}],["后面她看看说你这样也可以吧",{"2":{"43":1}}],["后面想了一会",{"2":{"41":1}}],["后面面试官思路提醒下",{"2":{"39":1}}],["后面也没问了",{"2":{"39":1}}],["后面也问了一些存储的",{"2":{"39":1}}],["后面手撕",{"2":{"39":1}}],["后面就没了",{"2":{"35":1}}],["后摩智能",{"2":{"22":1}}],["↩︎",{"2":{"21":4}}],["重命名变量",{"2":{"208":1}}],["重新思考计算往往比在树周围传递所有这些信息更好",{"2":{"178":1}}],["重复了第5章的例子",{"2":{"187":1}}],["重复直到没有新项可以添加",{"2":{"179":1}}],["重复直到接受或报错",{"2":{"144":1}}],["重复上述过程",{"2":{"142":1}}],["重复上述操作",{"2":{"113":1}}],["重复进行上次操作",{"2":{"113":1}}],["重复的页脚定义",{"2":{"21":1}}],["重叠",{"2":{"84":1}}],["重写重载",{"2":{"37":1}}],["重要",{"2":{"7":1,"146":1,"236":1}}],["脚注文字",{"2":{"21":1}}],["脚注",{"2":{"21":4}}],["october",{"2":{"215":1}}],["ools",{"2":{"201":1}}],["ool",{"2":{"187":2}}],["oov",{"2":{"67":1}}],["other2ifexprithenifexpr2thenother1elseother2",{"2":{"164":1}}],["other1",{"2":{"164":1}}],["on",{"2":{"137":1,"156":1}}],["one",{"0":{"57":1},"2":{"67":2,"221":1}}],["operator",{"2":{"176":6,"221":2}}],["operator=",{"2":{"41":1}}],["op",{"2":{"169":2}}],["options",{"2":{"114":1}}],["ors",{"2":{"236":1}}],["or包含指向类和方法向量的指针",{"2":{"187":1}}],["or",{"2":{"105":2,"187":2,"236":10,"237":1}}],["out",{"2":{"90":5}}],["outputs",{"2":{"75":2}}],["owo​",{"2":{"75":1}}],["of",{"2":{"67":1,"98":1,"137":2,"156":2}}],["o",{"2":{"66":4,"67":3,"75":7,"87":1,"88":1,"105":1,"139":2,"141":3,"164":3}}],["overlap",{"2":{"23":2}}],["object",{"0":{"236":1},"2":{"187":1}}],["obj",{"2":{"21":1}}],["omega^i",{"2":{"21":1}}],["omega^r",{"2":{"21":1}}],["omega",{"2":{"21":4}}],["https",{"2":{"114":1}}],["http报文包含哪些部分",{"2":{"33":1}}],["hsmap",{"2":{"90":6}}],["hidden",{"2":{"75":1}}],["hi",{"2":{"75":1}}],["hierarchical",{"2":{"67":1}}],["heap",{"2":{"187":1,"210":1}}],["headi​=attention",{"2":{"75":1}}],["headi=attention",{"2":{"75":1}}],["headh​",{"2":{"75":1}}],["headh",{"2":{"75":1}}],["head1​",{"2":{"75":1}}],["head1",{"2":{"75":1}}],["head",{"2":{"75":4}}],["hello",{"2":{"39":2,"75":1}}],["handle",{"0":{"161":1}}],["hash",{"2":{"139":1}}],["hasallcodes",{"2":{"101":1}}],["hat",{"2":{"67":2}}],["hard",{"2":{"33":1}}],["h",{"2":{"67":6,"75":7,"106":3,"164":12}}],["h=wtx",{"2":{"67":1}}],["h=wtxh",{"2":{"67":1}}],["h=c1​i=1∑c​wtxi​",{"2":{"67":1}}],["h=1c∑i=1cwtxih",{"2":{"67":1}}],["hypothesis",{"2":{"67":1}}],["hopcroft算法具有更低的渐近复杂度",{"2":{"141":1}}],["hopcroft",{"0":{"115":1}}],["hot",{"2":{"67":2}}],["hot编码",{"0":{"57":1}}],["home",{"2":{"21":1}}],["h2o",{"2":{"21":1}}],["链接到",{"2":{"236":1}}],["链接约定创建了一种标准方式来调用由其他人编写的代码以及用其他语言编写的代码",{"2":{"183":1}}],["链接约定定义了将名称映射到值和位置",{"2":{"183":1}}],["链接约定",{"2":{"183":1}}],["链接会报错",{"2":{"114":1}}],["链接",{"2":{"21":3}}],["无条件跳转",{"2":{"207":1}}],["无条件跳转或函数调用",{"2":{"206":1}}],["无关键字",{"2":{"201":1}}],["无左递归",{"2":{"188":1}}],["无限循环",{"2":{"150":1}}],["无用产生式有时有助于使语法更紧凑和易读",{"2":{"146":1}}],["无用产生式有助于使语法更紧凑",{"2":{"129":1}}],["无用产生式示例",{"0":{"146":1}}],["无论选择哪一种",{"2":{"234":1}}],["无论是实际参数还是返回值",{"2":{"224":1}}],["无论是显式还是隐式地",{"2":{"206":1}}],["无论是ll",{"2":{"145":1}}],["无论之前的自顶向下还是自低向上的解析器",{"2":{"145":1}}],["无论怎样",{"2":{"107":1}}],["无重复字符的最长字串",{"0":{"86":1,"100":1},"1":{"100":1}}],["无法判断用哪一个产生式",{"2":{"188":1}}],["无法书写",{"2":{"162":1}}],["无法凑成金额",{"2":{"68":1}}],["无法区分",{"2":{"67":3}}],["无法使用该硬币",{"2":{"58":1,"68":1}}],["无法捕捉单词或句子的语义关系",{"2":{"47":1}}],["无法确保计算的顺序",{"2":{"7":1}}],["无序列表3",{"2":{"21":1}}],["无序列表2",{"2":{"21":1}}],["无序列表1",{"2":{"21":1}}],["ωyω​",{"2":{"21":2}}],["∂ωr∂r​",{"2":{"21":1}}],["∂r∂ωr",{"2":{"21":1}}],["pl",{"2":{"180":1}}],["p中的每条规则具有形式",{"2":{"131":1}}],["p是产生式的有限集合",{"2":{"131":1}}],["p0p",{"2":{"115":3}}],["p0​=",{"2":{"115":1}}],["p0=",{"2":{"115":1}}],["p1p",{"2":{"115":1}}],["p1​=",{"2":{"115":1}}],["p1=",{"2":{"115":1}}],["p1−p",{"2":{"41":1}}],["pip",{"2":{"115":1}}],["pipeline",{"2":{"23":1}}],["pm​包含了所有的dfa状态",{"2":{"115":1}}],["pmp",{"2":{"115":1}}],["p3​",{"2":{"115":1}}],["p3",{"2":{"115":1}}],["p2​",{"2":{"115":1}}],["p2",{"2":{"115":1}}],["p=p1​",{"2":{"115":1}}],["p=p1",{"2":{"115":1}}],["pwke",{"2":{"100":1}}],["pwwkew",{"2":{"100":1}}],["pytorch",{"2":{"75":1}}],["python",{"2":{"67":1}}],["pe",{"2":{"75":6}}],["permute",{"2":{"69":1}}],["point",{"2":{"187":1}}],["pong缓存的想法",{"2":{"124":1}}],["pospospos",{"2":{"75":1}}],["pos",{"2":{"75":12,"139":2}}],["positional",{"2":{"75":1}}],["position",{"2":{"75":2}}],["pop操作移除栈顶元素并将其写回内存",{"2":{"152":1}}],["pop",{"2":{"63":2,"64":2,"69":1,"72":2}}],["pqrs",{"2":{"73":2}}],["protected",{"2":{"201":1}}],["procedure",{"2":{"183":1}}],["projects=",{"2":{"114":1}}],["project目录",{"2":{"114":1}}],["project",{"2":{"114":2}}],["programs",{"2":{"191":1}}],["program",{"2":{"98":2}}],["product",{"2":{"220":1}}],["productexceptself",{"2":{"88":1}}],["prod",{"2":{"67":1}}],["predict",{"2":{"137":1,"156":1}}],["prediction",{"2":{"75":2}}],["preserve",{"2":{"98":1}}],["pre=1",{"2":{"88":1}}],["pre",{"2":{"88":6,"106":8}}],["pretrained",{"2":{"75":2}}],["private",{"2":{"201":1}}],["price=min",{"2":{"104":1}}],["price=prices",{"2":{"104":1}}],["price",{"2":{"104":2}}],["prices",{"2":{"50":12,"62":2,"74":2,"104":5}}],["printzigarray",{"2":{"43":1}}],["printspiralmatrix",{"2":{"43":1}}],["printb",{"2":{"39":2}}],["printa",{"2":{"39":2}}],["padding",{"0":{"239":1}}],["pascal使用带有变体记录的联合体",{"2":{"221":1}}],["pass",{"2":{"155":2}}],["pair",{"2":{"63":2,"195":9}}],["parse",{"2":{"158":1,"176":1}}],["parser",{"2":{"142":2}}],["parsefactor",{"2":{"134":3}}],["parseterm",{"2":{"134":3}}],["parseexpression",{"2":{"134":2}}],["parsing",{"2":{"130":1}}],["parallel",{"2":{"114":1}}],["param",{"2":{"58":2,"68":2}}],["partial",{"2":{"21":1}}],["partial^r",{"2":{"21":1}}],["p",{"2":{"41":1,"67":4,"75":6,"99":10,"104":3,"115":10,"131":1,"162":2,"164":5,"172":2,"193":7}}],["ppp",{"2":{"41":1}}],["public",{"2":{"39":1,"41":1,"53":3,"58":1,"64":1,"65":1,"66":1,"68":1,"69":1,"72":1,"73":1,"80":1,"84":1,"87":1,"88":1,"90":1,"93":1,"99":1,"100":1,"101":1,"103":1,"104":1,"106":2,"107":1,"201":1}}],["push操作将一个值从内存复制到栈上",{"2":{"152":1}}],["push",{"2":{"33":1,"53":1,"63":1,"64":2,"65":2,"69":1,"73":1,"84":2,"99":2}}],["ptx",{"2":{"114":1}}],["pt",{"2":{"75":1}}],["pthread",{"2":{"37":1}}],["ptr",{"2":{"39":6,"232":3}}],["ptr的区别",{"2":{"33":1}}],["ptr和shared",{"2":{"33":1}}],["phi",{"2":{"155":2,"171":1,"229":1}}],["phase",{"2":{"29":3}}],["ph++",{"2":{"16":1}}],["ph",{"2":{"16":6}}],["~shareptr",{"2":{"41":1}}],["~=",{"2":{"22":1}}],["~",{"2":{"21":1,"105":2,"164":13}}],["−ε",{"2":{"153":1}}],["−ε加入",{"2":{"153":1,"170":1}}],["−εfirst",{"2":{"153":2,"170":1}}],["−j=0∑left−1​nums",{"2":{"106":1}}],["−s",{"2":{"106":2}}],["−∑j=0left−1nums",{"2":{"106":1}}],["−∑i=1klog⁡σ",{"2":{"67":2}}],["−vwi​t​vwi​​",{"2":{"67":2}}],["−vwitvwi",{"2":{"67":2}}],["−i=1∑k​logσ",{"2":{"67":2}}],["−prices",{"2":{"50":6,"62":2,"74":2}}],["−1​σ",{"2":{"67":1}}],["−1σ",{"2":{"67":1}}],["−1",{"2":{"21":2,"50":4,"62":6,"74":6}}],["−",{"2":{"21":2,"67":2}}],["标准比较运算符可以被重载",{"2":{"209":1}}],["标量的且无歧义",{"2":{"193":1}}],["标量值保持在ssa形式",{"2":{"154":1}}],["标量值仅存在于虚拟寄存器中",{"2":{"143":1}}],["标记为",{"2":{"29":1}}],["标记",{"2":{"21":1}}],["标题",{"0":{"6":1,"10":1,"14":1,"18":1,"21":1},"1":{"10":1,"14":2,"18":3,"21":4}}],["内联替换",{"2":{"224":1}}],["内联方法缓存针对单个调用点优化",{"2":{"187":1}}],["内部",{"2":{"187":1}}],["内部作用域中x的声明会遮蔽周围作用域中任何x的定义",{"2":{"139":1}}],["内部节点的数量和位置则完全取决于推导过程",{"2":{"129":1}}],["内存操作",{"0":{"232":1}}],["内存布局",{"0":{"177":1},"1":{"193":1,"203":1,"210":1,"216":1,"222":1,"227":1,"231":1,"234":1,"236":1,"237":1,"238":1,"239":1,"240":1}}],["内存中设置的一个区域",{"2":{"175":1}}],["内存中值的放置",{"0":{"143":1},"1":{"157":1,"175":1}}],["内存到内存模型",{"2":{"143":1}}],["内存模型有助于定义计算的基本模型",{"2":{"143":1}}],["内存会爆掉",{"2":{"41":1}}],["内存序",{"2":{"39":1}}],["内存分配的方法",{"2":{"33":1}}],["内层循环",{"2":{"23":1}}],["内容右对齐",{"2":{"21":1}}],["内容居中",{"2":{"21":1}}],["内容",{"2":{"21":1}}],["内的线程写入到一行",{"2":{"29":1}}],["内的",{"2":{"19":1}}],["内的不同",{"2":{"19":1}}],["内的不同地址的",{"2":{"19":1}}],["内的多个线程",{"2":{"19":1}}],["斜体文字",{"2":{"21":1}}],["斜体",{"2":{"21":1}}],["6给factorial",{"2":{"183":1}}],["64位浮点数乘法",{"2":{"220":1}}],["64",{"2":{"114":2}}],["6n7​",{"2":{"113":1}}],["66",{"2":{"93":1}}],["60",{"2":{"41":1}}],["6",{"0":{"21":1},"2":{"33":1,"37":1,"41":1,"43":2,"50":4,"53":2,"63":1,"64":9,"66":1,"78":1,"84":4,"88":1,"90":5,"99":2,"104":5,"106":2,"113":1,"127":1,"183":1,"187":1,"213":3}}],["时间复杂度内完成此题",{"2":{"88":1}}],["时间约在3",{"2":{"56":1}}],["时",{"2":{"19":1,"29":2,"66":1,"113":1,"127":1,"140":1,"183":1,"188":1,"198":1}}],["当lr",{"2":{"195":1}}],["当控制进入一个过程时创建",{"2":{"193":1}}],["当控制从循环底部的测试流入循环时",{"2":{"155":1}}],["当控制从循环上方的块流入循环时",{"2":{"155":1}}],["当创建对象时会明确地分配or",{"2":{"187":1}}],["当类层次结构发生变化时",{"2":{"187":1}}],["当过程p调用过程q时",{"2":{"187":1}}],["当p调用q时",{"2":{"187":1}}],["当递归到达factorial",{"2":{"183":1}}],["当被调用者完成其任务后",{"2":{"183":1}}],["当某些状态在action表中对所有输入符号有着完全相同的动作时",{"2":{"163":1}}],["当解析器处理类定义时",{"2":{"201":1}}],["当解析器处理输入代码时",{"2":{"190":1}}],["当解析器处于某个状态时",{"2":{"161":1}}],["当解析器应用这条规则进行规约时",{"2":{"160":1}}],["当解析器遇到错误时",{"2":{"145":1}}],["当编译器布局一个数据区域时",{"2":{"239":1}}],["当编译器布局",{"2":{"236":1}}],["当编译器对控制流图",{"2":{"212":1}}],["当编译器无法在编译时确定名称到实体的绑定",{"2":{"172":1}}],["当编译器能够在编译时确定名称到实体的绑定",{"2":{"172":1}}],["当编译器遇到一个名称时",{"2":{"172":1}}],["当编译器解析输入程序时",{"2":{"159":1}}],["当编译器编写者设计中间表示",{"2":{"140":1}}],["当初始化变量时",{"2":{"155":1}}],["当然",{"2":{"145":1,"163":1,"180":1,"236":1}}],["当然为了明年的秋招",{"2":{"8":1}}],["当栈顶符号序列与某个产生式的右部匹配时",{"2":{"142":1}}],["当面对不利的输入时",{"2":{"139":1}}],["当面临构建一个手工编写解析器的任务时",{"2":{"130":1}}],["当",{"2":{"127":2}}],["当扫描器回滚的时候",{"2":{"124":1}}],["当计算达到进一步迭代不会产生新结果的状态时",{"2":{"113":1}}],["当前的前缀和",{"2":{"106":1}}],["当前仅当",{"2":{"102":1}}],["当和小于0时",{"2":{"106":1}}],["当书店老板生气时",{"2":{"103":1}}],["当数组长达大于2时",{"2":{"87":1}}],["当我们遍历数组中的每个元素",{"2":{"66":1}}],["当我们步行到某一天时",{"2":{"63":1}}],["当金额为0时",{"2":{"58":1}}],["当晚hr约面",{"2":{"56":1}}],["当晚秒过",{"2":{"56":1}}],["当晚流程显示进入复试",{"2":{"39":1}}],["当时查了半天不知道哪问题",{"2":{"43":1}}],["当时给我吓坏了",{"2":{"41":1}}],["当时写的磕磕绊绊的",{"2":{"41":1}}],["当时觉得肯定凉了",{"2":{"39":1}}],["当时觉得为什么要面呢",{"2":{"39":1}}],["当同一个",{"2":{"23":1}}],["当线程访问",{"2":{"19":1}}],["一段内存区域",{"2":{"193":1}}],["一样缺乏实际意义",{"2":{"162":1}}],["一元运算符和含糊的结构会给编程语言语法带来复杂性",{"2":{"196":1}}],["一元运算符",{"0":{"162":1}}],["一次性赋值完毕后",{"2":{"155":1}}],["一些语言要求所有变量必须在任何可执行语句出现之前声明",{"2":{"238":1}}],["一些编译器为编译单元中的过程构建部分调用图",{"2":{"224":1}}],["一些编译器执行跨过程分析和优化",{"2":{"224":1}}],["一些编译器使用树和图来表示被编译的程序",{"2":{"148":1}}],["一些优化可以从单语句块中受益",{"2":{"212":1}}],["一些专家建议构建围绕比基本块更短的块的",{"2":{"212":1}}],["一些值的生命周期受程序控制",{"2":{"210":1}}],["一些局部的",{"2":{"143":1}}],["一些早期的编译器使用了线性ir",{"2":{"136":1}}],["一旦转换表的大小超过了第一级数据缓存的大小",{"2":{"139":1}}],["一种解决方案是采用完全限定的引用",{"2":{"221":1}}],["一种简单的方法是为每段代码文件创建一个单一的静态数据区",{"2":{"203":1}}],["一种是作为二维数组",{"2":{"180":1}}],["一种书写此语法的方法如图所示",{"2":{"162":1}}],["一种嵌入到解析器中的计算形式",{"2":{"159":1}}],["一种将键视为一组非循环正则表达式并逐步建立dfa以识别该集合的方法",{"2":{"139":1}}],["一种得到",{"2":{"93":1}}],["一起使用",{"2":{"139":1}}],["一条指令可能包含多个操作",{"2":{"136":1}}],["一条马路半小时有车经过的概率是90",{"2":{"41":1}}],["一边维护前缀和的最小值",{"2":{"106":1}}],["一边学英文了",{"2":{"97":1}}],["一定比以",{"2":{"66":1}}],["一定会出现",{"2":{"19":1}}],["一般来说",{"2":{"129":1,"182":1,"187":1}}],["一般步骤如下",{"2":{"64":1}}],["一般先写边界条件",{"2":{"50":1}}],["一股",{"2":{"50":1}}],["一开始不会特别难",{"2":{"46":1}}],["一开始还是自我介绍了部门业务",{"2":{"46":1}}],["一开始拿了小米的训练框架优化的岗位",{"2":{"22":1}}],["一上来面试官先自我介绍",{"2":{"39":1}}],["一面",{"0":{"39":1,"41":1},"2":{"49":1}}],["一个好的类型系统可以提高语言的表现力",{"2":{"235":1}}],["一个对象看起来像一个其组织结构由类定义所指定的记录或结构体",{"2":{"226":1}}],["一个节点是定义",{"2":{"218":1}}],["一个子节点保存控制表达式",{"2":{"217":1}}],["一个链表可能由一个自动局部变量组成",{"2":{"210":1}}],["一个控制流图可以表示为一个有向图",{"2":{"206":1}}],["一个过程的ir可能包括定义它的代码",{"2":{"205":1}}],["一个过程在其被另一个过程调用或invoke时执行",{"2":{"183":1}}],["一个数组将多个相同类型的对象组合在一起",{"2":{"202":1}}],["一个针对point",{"2":{"201":1}}],["一个指向其方法向量的指针",{"2":{"187":1}}],["一个指向apoint方法向量的指针",{"2":{"187":1}}],["一个指针向量持有块的四元组",{"2":{"186":1}}],["一个表达式",{"2":{"185":1}}],["一个其生命周期依赖于显式分配以及要么显式要么隐式释放的实体被称为不规则实体",{"2":{"175":1}}],["一个自动变量的生命周期与其作用域",{"2":{"175":1}}],["一个值的生命周期指的是其值可以被定义或引用的时间段",{"2":{"175":1}}],["一个被称为名称解析的过程",{"2":{"172":1}}],["一个操作符",{"2":{"186":1}}],["一个操作可能有超过三个地址",{"2":{"169":1}}],["一个操作在哪里找到它的参数",{"2":{"143":1}}],["一个lab节点表示汇编级别的标签",{"2":{"166":1}}],["一个num节点表示可以放入操作立即数字段的已知常量",{"2":{"166":1}}],["一个val节点表示已经位于寄存器中的值",{"2":{"166":1}}],["一个程序处于ssa形式时",{"2":{"155":1}}],["一个减法运算符移除栈顶的两个元素",{"2":{"152":1}}],["一个典型的控制流图",{"2":{"149":1}}],["一个解析器应该在每次编译中找到尽可能多的语法错误",{"2":{"145":1}}],["一个设计良好的哈希函数h",{"2":{"139":1}}],["一个编译器将包含多个不同的表",{"2":{"139":1}}],["一个编译器可能只有一种ir",{"2":{"132":1}}],["一个新的过程定义了一个覆盖其整个定义的新作用域",{"2":{"139":1}}],["一个或多个数据结构的集合",{"2":{"139":1}}],["一个能够产生较短推导的语法",{"2":{"129":1}}],["一个接受状态使得所有成功的匹配都指向同一个终点",{"2":{"118":1}}],["一个逐字识别单词的算法简单且易于理解",{"2":{"102":1}}],["一个词的语义由其上下文决定",{"2":{"67":1}}],["一个是第i个硬币",{"2":{"58":1}}],["一个是第",{"2":{"50":1}}],["一个小时秒过",{"2":{"49":1}}],["一个很少",{"2":{"46":1}}],["一个原子变量",{"2":{"39":1}}],["一个",{"2":{"29":2}}],["一个线程处理了多个元素",{"2":{"11":1}}],["一个线程块block计算bm",{"2":{"11":1}}],["一个线程块处理",{"2":{"11":1}}],["中获取那些私有成员",{"2":{"236":1}}],["中保存一份副本",{"2":{"236":1}}],["中表示此类事实",{"2":{"198":1}}],["中声明",{"2":{"193":1}}],["中使用非局部变量和数据结构来绕过这个范式并规避这些限制",{"2":{"178":1}}],["中等",{"2":{"176":1}}],["中端的一些其他优化",{"2":{"155":1}}],["中端一个叫做",{"2":{"155":1}}],["中文就是是",{"2":{"155":1}}],["中文字符通常占3字节",{"2":{"47":1}}],["中创建的命名空间具有同等的重要性",{"2":{"140":1}}],["中所示的小循环",{"2":{"155":1}}],["中所示的dfa",{"2":{"123":1}}],["中所示的nfa",{"2":{"123":1}}],["中所有",{"2":{"99":1}}],["中所有可以使数字和为",{"2":{"78":1}}],["中所有可能的",{"2":{"76":1}}],["中出现过",{"2":{"101":1}}],["中下标为",{"2":{"101":1}}],["中字符出现的次数",{"2":{"99":1}}],["中除了",{"2":{"88":1}}],["中除",{"2":{"88":1}}],["中心词的",{"2":{"67":1}}],["中间代码生成那里提了一下ssa模式",{"2":{"46":1}}],["中间代码生成",{"2":{"46":1}}],["中间部分写对了",{"2":{"33":1}}],["中",{"2":{"29":2,"63":1,"66":2,"101":1,"155":1,"173":1,"186":2,"187":4,"193":1,"197":2,"236":1}}],["中加载前",{"2":{"29":1}}],["中读取时",{"2":{"29":1}}],["中线程分为",{"2":{"29":1}}],["中32个线程访问连续的地址时",{"2":{"19":1}}],["中的布局",{"2":{"239":1}}],["中的每个终结符",{"2":{"188":2}}],["中的每个终结符b",{"2":{"179":1}}],["中的变量必须在运行时进行初始化",{"2":{"187":1}}],["中的低级ast使用表示汇编级别概念的节点",{"2":{"166":1}}],["中的内存写指令",{"2":{"155":1}}],["中的状态数",{"2":{"141":1}}],["中的终端符号集",{"2":{"131":1}}],["中的nfa",{"2":{"123":1}}],["中的不同元素数量是有限的",{"2":{"113":1}}],["中的数字可以无限制重复被选取",{"2":{"78":1}}],["中的数都放入一个哈希集合中",{"2":{"66":1}}],["中的元素",{"2":{"66":1}}],["中的逻辑位置是一行",{"2":{"29":1}}],["中的所有",{"2":{"23":1}}],["中的",{"2":{"19":1,"155":1,"162":1}}],["中的一个要计算的值",{"2":{"4":1}}],["比较不同枚举类型的运算没有意义",{"2":{"215":1}}],["比较新的",{"2":{"19":1}}],["比基于最大长度块构建的",{"2":{"212":1}}],["比dag更适合表示程序流程而非表达式计算",{"2":{"206":1}}],["比ast更关注控制流而非语法结构",{"2":{"206":1}}],["比解析树更为简洁",{"2":{"198":1}}],["比原来少遍历一次数组",{"2":{"88":1}}],["比如连接操作",{"2":{"231":1}}],["比如root",{"2":{"210":1}}],["比如表达式级别的抽象语法树",{"2":{"206":1}}],["比如表达式级别的",{"2":{"206":1}}],["比如词法嵌套的类定义",{"2":{"201":1}}],["比如变量名和函数名",{"2":{"180":1}}],["比如泰勒级数展开",{"2":{"173":1}}],["比如抽象语法树",{"2":{"168":1}}],["比如它可以将每个值存储在哪里",{"2":{"159":1}}],["比如a",{"2":{"157":1}}],["比如对变量用到了取地址运算符",{"2":{"155":1}}],["比如java虚拟机",{"2":{"152":1}}],["比如当关键字同时作为标识符使用的情况",{"2":{"130":1}}],["比如我们有三个类别老鼠",{"2":{"57":1}}],["比如最常见的中文的编码方案",{"2":{"47":1}}],["比如每次访问",{"2":{"19":1}}],["数字和标识符之间的区别对于goal",{"2":{"163":1}}],["数十年的研究推动了多种高效解析技术的演进",{"2":{"130":1}}],["数组存储分配",{"0":{"227":1}}],["数组是最常使用的聚合对象之一",{"2":{"202":1}}],["数组中的每个元素代表你在该位置可以跳跃的最大长度",{"2":{"107":1}}],["数组中的元素而不改变其余元素的顺序",{"2":{"53":1}}],["数组",{"0":{"202":1},"2":{"88":2,"139":1}}],["数据依赖图在各种优化中找到应用",{"2":{"218":1}}],["数据依赖图通常为特定任务构建",{"2":{"218":1}}],["数据依赖图中的一条边连接两个节点",{"2":{"218":1}}],["数据依赖图体现了这种关系",{"2":{"218":1}}],["数据依赖图",{"0":{"218":1}}],["数据流分析",{"2":{"206":1}}],["数据流分析变得简单直接",{"2":{"200":1}}],["数据空间通常与运行时间有直接关系",{"2":{"205":1}}],["数据成员按照前缀布局方案排序",{"2":{"187":1}}],["数据可以直接插入到静态数据区中的适当位置",{"2":{"187":1}}],["数据区域",{"2":{"175":1}}],["数据区域之一或堆",{"2":{"157":1}}],["数据结构上需要用到一个输出缓冲区和一个预测的指针",{"2":{"134":1}}],["数据",{"2":{"29":1}}],["数学表达式",{"2":{"21":1}}],["数比较大",{"2":{"19":1}}],["数有两个",{"2":{"19":1}}],["访问了",{"2":{"19":1}}],["访问了同一个",{"2":{"19":1}}],["下图显示了两个",{"2":{"236":1}}],["下图显示了一个编译器可能使用的典型方案",{"2":{"175":1}}],["下图展示了用于计算a←ax2xbxcxd的iloc代码",{"2":{"218":1}}],["下图展示了经典的表达式语法规则以及表达式",{"2":{"168":1}}],["下图表示了一个用于构建表达式的抽象语法树的简单语法驱动框架",{"2":{"194":1}}],["下图",{"2":{"186":1}}],["下图中的",{"2":{"149":2}}],["下图中",{"2":{"19":2}}],["下文用",{"2":{"113":1}}],["下一节会介绍如何构造lr",{"2":{"174":1}}],["下一个子数组不包含",{"2":{"90":1}}],["下一步是从share",{"2":{"29":1}}],["下午17",{"2":{"56":1}}],["下半部分",{"2":{"43":1}}],["下标会溢出了",{"2":{"43":1}}],["下次开obs录吧",{"2":{"35":1}}],["下面是计算机中虚拟内存的各种视角",{"2":{"216":1}}],["下面介绍更复杂的过程控制流",{"2":{"183":1}}],["下面介绍另一种dfa最小化的算法",{"2":{"123":1}}],["下面我们给出消除直接左递归的一般方法",{"2":{"150":1}}],["下面直接看我实现的c++样例代码",{"2":{"124":1}}],["下面来看代码",{"2":{"74":1}}],["下面看代码",{"2":{"50":1,"58":1}}],["下面以utf",{"2":{"47":1}}],["下面几个函数的调用",{"2":{"39":1}}],["下面的情况认为没有",{"2":{"19":1}}],["下面的优化",{"2":{"11":1}}],["下面给出如何消除间接左递归",{"2":{"150":1}}],["下面给出状态方程",{"2":{"62":1}}],["下面给出图示大致意思",{"2":{"16":1}}],["下面给出代码",{"2":{"7":1,"11":1,"16":1,"62":1,"87":1}}],["下面仅给出函数签名",{"2":{"7":1}}],["下面简单解释下代码",{"2":{"4":1}}],["示例控制流图",{"2":{"206":1}}],["示例代码",{"2":{"183":1}}],["示例",{"0":{"154":1,"195":1,"213":1},"2":{"19":1,"21":1,"50":3,"53":1,"58":3,"64":2,"65":3,"66":2,"68":3,"69":3,"72":2,"73":3,"76":2,"78":3,"80":2,"84":2,"87":2,"88":2,"90":3,"93":2,"99":2,"100":3,"101":3,"103":2,"104":2,"106":3,"107":2,"150":1,"153":1,"167":1,"169":1,"170":1,"176":1,"184":1,"229":1}}],["wednesday",{"2":{"215":1}}],["weekday",{"2":{"215":1}}],["wke",{"2":{"100":1}}],["wbwbbbw",{"2":{"93":1}}],["wbbwwbbwbw",{"2":{"93":1}}],["wth",{"2":{"75":2}}],["wxyz",{"2":{"73":2}}],["wc​∣wi​",{"2":{"67":1}}],["wc∣wi",{"2":{"67":1}}],["wv",{"2":{"67":1}}],["withelseother​",{"2":{"164":1}}],["withelse5∣other",{"2":{"164":1}}],["withelse",{"2":{"164":2}}],["wihelse",{"2":{"164":2}}],["wi​∣w1",{"2":{"75":1}}],["wi+1",{"2":{"75":2}}],["wi∣w1",{"2":{"75":1}}],["window=5",{"2":{"67":1}}],["width+threadidx",{"2":{"7":4}}],["width",{"2":{"7":8,"16":2}}],["wo",{"2":{"75":3}}],["wo​hi​",{"2":{"75":1}}],["wohi",{"2":{"75":1}}],["woman",{"2":{"67":3}}],["world",{"2":{"39":3,"75":1}}],["wordpiece",{"2":{"75":1}}],["word2vec",{"2":{"67":8,"75":2}}],["word2vec模型",{"0":{"67":1}}],["words",{"2":{"19":1,"67":1}}],["word",{"2":{"19":6,"67":1,"75":1}}],["www",{"2":{"67":1}}],["w|w",{"2":{"67":1}}],["w∣wi​",{"2":{"67":1}}],["w∣wi",{"2":{"67":1}}],["w",{"2":{"67":45,"75":10,"93":2,"102":2,"164":4}}],["while结构被改写成较低层次的抽象",{"2":{"155":1}}],["while",{"2":{"43":5,"63":2,"64":1,"66":1,"100":2,"134":2}}],["wrapper",{"2":{"21":1}}],["way",{"2":{"19":1}}],["warp",{"2":{"19":3,"23":3,"29":5}}],["同样的技巧",{"2":{"204":1}}],["同样的效果也出现在线性代码中",{"2":{"197":1}}],["同样的方法也适用于一元减",{"2":{"162":1}}],["同样",{"2":{"163":1,"187":1,"236":1}}],["同样地",{"2":{"149":1,"163":1,"173":1,"209":1,"236":1}}],["同一集合中的两个状态对于每一个字符",{"2":{"115":1}}],["同一个",{"2":{"19":1}}],["同时保持对定义时环境的访问",{"2":{"183":1}}],["同时保持了原语言的表达能力",{"2":{"150":1}}],["同时保持5个移进操作不变",{"2":{"146":1}}],["同时保持dfa的功能不变",{"2":{"115":1}}],["同时还会介绍编译器维护的辅助数据结构",{"2":{"132":1}}],["同时需满足以下两条规则",{"2":{"115":1}}],["同时",{"2":{"104":1}}],["同时维护队列单调性",{"2":{"64":1}}],["同时这是最容易出问题的",{"2":{"50":1}}],["同时utf",{"2":{"47":1}}],["同理可以应用到",{"2":{"7":1}}],["划分成了不同的",{"2":{"19":1}}],["第三个保存else子句中的语句",{"2":{"217":1}}],["第三个项目lox解释器",{"2":{"46":1}}],["第三章中用来描绘推导的解析树是图形化ir的一个实例",{"2":{"149":1}}],["第12章",{"2":{"218":1}}],["第13行的判断不能移到前面去",{"2":{"76":1}}],["第16行注释是原来我写的",{"2":{"43":1}}],["第i天补给站每份食物的价格",{"2":{"63":1}}],["第i天结束时的利润",{"2":{"50":1}}],["第0个硬币",{"2":{"58":2}}],["第0天开始",{"2":{"50":1}}],["第0天开始不可能持有股票",{"2":{"50":1,"62":1,"74":1}}],["第0天开始未持有股票利润为0",{"2":{"50":1,"62":1,"74":1}}],["第",{"2":{"50":2}}],["第一点意味这每次选择的时候",{"2":{"188":1}}],["第一个方案",{"2":{"186":1}}],["第一个输入符号",{"2":{"179":1,"195":1}}],["第一个选项用来构建clang编译器前端",{"2":{"114":1}}],["第一个下标",{"2":{"107":1}}],["第一道做太快了",{"2":{"49":1}}],["第一反应就是双指针",{"2":{"46":1}}],["第一题大概是力扣上的螺旋矩阵",{"2":{"43":1}}],["第二点也意味需要唯一选择",{"2":{"188":1}}],["第二个选项用来生成样例程序",{"2":{"114":1}}],["第二天3",{"2":{"56":1}}],["第二天晚上挂了",{"2":{"49":1}}],["第二题就是打印一个z字形的矩阵",{"2":{"43":1}}],["第二重量级的优化",{"0":{"19":1}}],["第31行的目的",{"2":{"7":1}}],["512",{"2":{"75":1}}],["5=1+1+1+1+1",{"2":{"68":1}}],["5=2+1+1+1",{"2":{"68":1}}],["5=2+2+1",{"2":{"68":1}}],["5=5",{"2":{"68":1}}],["5",{"0":{"18":1},"1":{"21":1},"2":{"33":1,"37":1,"43":2,"49":1,"50":8,"53":1,"58":3,"63":2,"64":11,"66":1,"67":1,"68":2,"75":1,"78":2,"80":2,"84":3,"87":2,"90":7,"103":2,"104":4,"106":2,"113":1,"164":1,"176":4,"183":5,"213":2,"220":1}}],["vrb和vrc中",{"2":{"143":1}}],["varphiφ",{"2":{"155":8}}],["varepsilon",{"2":{"113":6,"119":1,"131":1}}],["varepsilonε",{"2":{"105":1,"112":3,"113":2,"123":1,"127":1}}],["val++",{"2":{"43":9}}],["val",{"2":{"43":11,"163":1,"232":2}}],["value对比p",{"2":{"221":1}}],["valuelntoreg",{"2":{"194":1}}],["valuevaluevalue",{"2":{"90":1}}],["value是对应的字符串",{"2":{"65":1}}],["value",{"2":{"21":1,"162":3,"221":3,"230":2}}],["vq",{"2":{"75":2}}],["vbank​",{"2":{"67":1}}],["vbank",{"2":{"67":1}}],["vwiv​",{"2":{"75":1}}],["vwiv",{"2":{"75":1}}],["vwi​​",{"2":{"67":1}}],["vwi",{"2":{"67":1}}],["vwo​​",{"2":{"67":1}}],["vwo​t​vwi​​",{"2":{"67":2}}],["vwo",{"2":{"67":1}}],["vwotvwi",{"2":{"67":2}}],["vikram",{"2":{"110":1}}],["visited",{"2":{"58":2,"68":2,"69":4}}],["virtual",{"2":{"39":1,"110":1}}],["vod",{"2":{"41":1}}],["void",{"2":{"1":1,"4":1,"7":2,"11":1,"16":1,"39":5,"41":1,"43":2,"69":1,"72":1,"73":1}}],["vector>",{"2":{"183":1}}],["vectors",{"2":{"75":1}}],["vector",{"2":{"41":1,"43":3,"53":6,"58":3,"63":1,"64":3,"65":6,"66":1,"67":1,"68":3,"69":7,"72":2,"73":2,"80":1,"84":8,"87":1,"88":5,"90":1,"99":4,"103":2,"104":1,"106":2,"107":1,"183":1}}],["vscode",{"2":{"21":1}}],["v++",{"2":{"16":2}}],["v",{"2":{"16":9,"67":14,"75":11,"206":4,"213":4}}],["qq∈q",{"2":{"113":1}}],["qqq",{"2":{"113":2}}],["q∈qq",{"2":{"113":1}}],["qwiq​",{"2":{"75":1}}],["qwiq",{"2":{"75":1}}],["qk^t",{"2":{"75":1}}],["qktdk",{"2":{"75":1}}],["qkv那三个权重矩阵怎么来的了",{"2":{"37":1}}],["qkv怎么来的",{"2":{"37":1}}],["quad",{"2":{"67":1}}],["queen",{"2":{"67":3}}],["que",{"2":{"64":8}}],["quot",{"2":{"19":2,"65":32,"67":36,"72":12,"73":50,"93":6,"99":28,"100":14,"101":20,"127":2,"137":4,"156":4,"162":2,"178":2,"179":8,"195":10,"209":8,"233":2}}],["q++",{"2":{"16":2}}],["q",{"2":{"16":9,"75":8}}],["list",{"2":{"195":11}}],["lifo",{"2":{"183":1}}],["literal",{"2":{"176":3}}],["linux",{"2":{"33":1}}],["lr解析样例",{"0":{"174":1}}],["lr解析算法的主要步骤包括",{"2":{"144":1}}],["lr解析算法",{"0":{"144":1}}],["lr",{"0":{"156":1},"2":{"130":3,"142":5,"156":2,"180":1,"181":1,"195":1}}],["ldots",{"2":{"102":2}}],["ldmatrix",{"2":{"29":4}}],["ll",{"0":{"137":1,"188":1},"1":{"153":1,"170":1},"2":{"137":2,"188":1}}],["lld连接器",{"2":{"114":1}}],["lld",{"2":{"114":1}}],["llvm的ir是一种线性的三地址码",{"2":{"154":1}}],["llvm这个名字代表",{"2":{"154":1}}],["llvm编译器使用单一的低级ir",{"2":{"154":1}}],["llvm",{"0":{"110":1,"138":1,"154":1},"1":{"154":1,"171":1,"189":1,"200":1,"208":1,"214":1,"220":1,"225":1,"229":1,"232":1},"2":{"110":4,"114":6,"154":1,"155":1,"232":1}}],["llvm简介",{"0":{"96":1},"1":{"110":1,"114":1}}],["llbracket",{"2":{"67":1}}],["l^2",{"2":{"75":1}}],["l2⋅d",{"2":{"75":2}}],["l=−c=1∑c​logp",{"2":{"67":1}}],["l=−∑c=1clog⁡p",{"2":{"67":1}}],["l=−logσ",{"2":{"67":2}}],["l=−log⁡σ",{"2":{"67":2}}],["l",{"2":{"67":7,"105":2,"106":2,"137":2,"156":2,"164":12}}],["label",{"2":{"229":5}}],["lalr",{"2":{"181":3}}],["lattner",{"2":{"110":1}}],["latency",{"2":{"23":1}}],["last",{"2":{"75":1}}],["language",{"2":{"75":2}}],["lane",{"2":{"29":2}}],["layernorm",{"2":{"75":4}}],["layer",{"2":{"43":13}}],["lambda",{"2":{"33":2}}],["loop",{"2":{"229":4}}],["lookahead",{"2":{"134":7,"137":1,"142":2,"156":1}}],["low",{"2":{"110":1}}],["lower",{"2":{"53":1}}],["lock",{"2":{"41":1}}],["local的作用",{"2":{"39":1}}],["load",{"2":{"23":2,"29":1,"166":1,"229":2,"232":1}}],["longestconsecutive",{"2":{"66":1}}],["long",{"2":{"21":4,"90":6}}],["log2",{"2":{"139":1}}],["logy",{"2":{"21":2}}],["log",{"2":{"21":2,"67":5,"141":1}}],["log⁡y",{"2":{"21":2}}],["lettercombinations",{"2":{"73":1}}],["lengthoflongestsubstring",{"2":{"100":1}}],["lengthoflis",{"2":{"53":3}}],["length",{"2":{"87":2,"99":2}}],["len",{"2":{"66":1,"75":1,"80":2,"87":2,"100":4,"107":2}}],["len++",{"2":{"66":1}}],["len=1",{"2":{"66":1}}],["len=0",{"2":{"66":1}}],["level",{"2":{"23":1,"110":1}}],["leftparenthesis",{"2":{"176":1}}],["leftmost",{"2":{"137":1}}],["left++",{"2":{"100":1}}],["left=0",{"2":{"100":1}}],["left",{"2":{"21":3,"67":1,"75":1,"100":2,"102":6,"106":5,"137":1,"156":1,"221":2,"230":2}}],["leetcode上hot100还有面试top150其实刷完了",{"2":{"8":1}}],["lt",{"2":{"16":6,"63":7,"166":1,"169":1,"176":24,"209":2,"215":2}}],["80和java都使用字节码",{"2":{"152":1}}],["8代表使用8个线程进行构建",{"2":{"114":1}}],["87",{"2":{"93":1}}],["8仅仅解决了字符存储的问题",{"2":{"47":1}}],["8编码的字符串需先解码为unicode码点",{"2":{"47":1}}],["8是变长编码",{"2":{"47":1}}],["8的编码格式说明",{"2":{"47":1}}],["8的编码",{"2":{"47":1}}],["8+8内存跑起来",{"2":{"46":1}}],["824",{"2":{"39":1}}],["8b",{"2":{"19":3}}],["8",{"2":{"16":11,"29":5,"33":1,"37":1,"43":2,"66":1,"78":1,"84":2,"88":1,"106":1,"113":2,"114":1}}],["假如极端条件下一个很多",{"2":{"46":1}}],["假如c=a",{"2":{"46":1}}],["假如在上述矩阵中",{"2":{"16":1}}],["假设树大致平衡",{"2":{"139":1}}],["假设一个dfa具有一个状态转移",{"2":{"127":1}}],["假设我们现在从状态",{"2":{"112":1}}],["假设存在一个名为",{"2":{"102":1}}],["假设每一种面额的硬币有无限个",{"2":{"68":1}}],["假设当前是第",{"2":{"50":1}}],["假设",{"2":{"4":1,"188":1}}],["假设有要计算矩阵",{"2":{"1":1}}],["42",{"2":{"232":1}}],["4中所讨论的",{"2":{"139":1}}],["40二面面试官打电话过来说没问题",{"2":{"56":1}}],["4字节",{"2":{"47":1}}],["4b",{"2":{"19":2}}],["4",{"0":{"14":1,"232":1},"1":{"18":1,"21":1},"2":{"16":11,"19":2,"29":2,"33":1,"37":1,"43":5,"50":9,"53":2,"63":3,"66":5,"67":1,"68":1,"75":1,"76":4,"80":3,"84":4,"88":1,"90":8,"93":1,"104":2,"106":4,"107":2,"113":3,"164":1,"176":4,"183":5,"197":1,"213":2,"220":1}}],["可移植到不同架构",{"2":{"232":1}}],["可视化程序执行路径",{"2":{"206":1}}],["可寻址性槽存放了让被调用者能够访问周围词法作用域内局部变量的信息",{"2":{"187":1}}],["可见性的含义",{"2":{"203":1}}],["可见性和声明作用域",{"2":{"175":1}}],["可见区域",{"2":{"175":1}}],["可见且可访问",{"2":{"139":1}}],["可解释形式",{"2":{"152":1}}],["可能是迭代的",{"2":{"238":1}}],["可能意味着",{"2":{"233":1}}],["可能需要保存所有寄存器的值",{"2":{"187":1}}],["可能的推导过程如下",{"2":{"150":1}}],["可能注重的是优化方面的内容",{"0":{"12":1}}],["可接受状态在状态转移图中",{"2":{"102":1}}],["可被视为重叠区间",{"2":{"84":1}}],["可是我不是这方向的",{"2":{"39":1}}],["可惜去不了",{"2":{"22":1}}],["可以保存一个字符字符串",{"2":{"233":1}}],["可以从源代码级别变化到低于机器码级别",{"2":{"228":1}}],["可以从任何有限自动机构建一个正则表达式",{"2":{"112":1}}],["可以减少",{"2":{"198":1}}],["可以用",{"2":{"188":1}}],["可以作为参数传递或存储在容器中",{"2":{"183":1}}],["可以捕获外部作用域的变量",{"2":{"183":1}}],["可以使语法缩小一个产生式",{"2":{"163":1}}],["可以使用多次",{"2":{"78":1}}],["可以通过清除缓存或生成新标签来实现",{"2":{"187":1}}],["可以通过归约操作将其替换为产生式左部的非终结符",{"2":{"161":1}}],["可以通过dfa来最小化dfa",{"2":{"123":1}}],["可以拆成两个常量",{"2":{"155":1}}],["可以实现快速的执行",{"2":{"139":1}}],["可以实习半年",{"2":{"22":1}}],["可以根据自己的电脑性能进行调整",{"2":{"114":1}}],["可以让自己连续",{"2":{"103":1}}],["可以采用代码来解决",{"2":{"100":1}}],["可以把",{"2":{"93":1}}],["可以把共享内存理解成缓存嘛",{"2":{"46":1}}],["可以证明无法用少于",{"2":{"93":1}}],["可以形成一组候选",{"2":{"78":1}}],["可以参考这篇csdn博客",{"2":{"67":1}}],["可以按任意顺序返回结果列表",{"2":{"65":1}}],["可以先跳",{"2":{"107":1}}],["可以先购买完食物后再消耗今天的1份食物",{"2":{"63":1}}],["可以先把数据读进共享内存",{"2":{"7":1}}],["可以对应于",{"2":{"29":1}}],["可以看到在一个warp内",{"2":{"29":1}}],["可以并行",{"2":{"23":1}}],["可以包含特殊标记",{"2":{"21":1}}],["可以认为",{"2":{"19":1}}],["可以理解为",{"2":{"19":1}}],["可以写出最朴素的矩阵乘法",{"2":{"1":1}}],["以过程值作为参数",{"2":{"224":1}}],["以确定对同一数组的引用何时可以重叠",{"2":{"218":1}}],["以确定静态变量如何映射到各个数据区",{"2":{"203":1}}],["以确保在应用||之前先计算括号内的表达式",{"2":{"162":1}}],["以模拟源语言的规则",{"2":{"201":1}}],["以结合表的方式模拟语言指定的作用域规则",{"2":{"201":1}}],["以反映冗余",{"2":{"198":1}}],["以揭示开始寻找当前句柄之前dfa的状态",{"2":{"195":1}}],["以保存相应块的代码",{"2":{"186":1}}],["以保留任一解决方案所需的所有信息",{"2":{"180":1}}],["以链接约定",{"2":{"183":1}}],["以将标识符解析为不同的类别",{"2":{"180":1}}],["以将ir中的虚拟寄存器映射到最终代码中的物理寄存器",{"2":{"157":1}}],["以if",{"2":{"164":1}}],["以这种方式重写后",{"2":{"180":1}}],["以这种方式定义它们的行为使得操纵ssa形式的算法可以忽略位于块顶部的",{"2":{"155":1}}],["以这种形式分析和改进代码",{"2":{"159":1}}],["以此类推",{"2":{"153":1}}],["以捕捉它们的优点并避免它们的缺点",{"2":{"149":1}}],["以便字符串比较能够自然地工作",{"2":{"209":1}}],["以便被调用者在返回时可以恢复调用者的环境",{"2":{"187":1}}],["以便其能够连接到调用上下文并允许它与其他过程进行交互",{"2":{"187":1}}],["以便算法能够区分移进动作和归约动作",{"2":{"181":1}}],["以便它们不会在代码缓存中相互冲突",{"2":{"163":1}}],["以便它们可以共享实现",{"2":{"139":1}}],["以便编译器可以细化操作符和引用以反映正确的类型信息",{"2":{"233":1}}],["以便编译器可以为此调整代码",{"2":{"136":1}}],["以便编译后的代码能够将值存储到内存并在需要时检索它们",{"2":{"148":1}}],["以便在解析不成功后停止",{"2":{"145":1}}],["以便后续的语义分析和代码生成",{"2":{"131":1}}],["以非模糊方式描述的语言",{"2":{"130":1}}],["以产生图",{"2":{"123":1}}],["以构造",{"2":{"118":1}}],["以下是它们的详细对比",{"2":{"158":1}}],["以下整理的",{"2":{"67":1}}],["以下多线程执行",{"2":{"41":1}}],["以",{"2":{"66":1,"101":1}}],["以最小的花费完成这次徒步旅行",{"2":{"63":1}}],["以为有第三面",{"2":{"56":1}}],["以为还有什么内存分配器",{"2":{"33":1}}],["以上的位置为0",{"2":{"47":1}}],["以上的最基本的gemm的优化",{"2":{"11":1}}],["以及指向其类和",{"2":{"236":1}}],["以及为了支持多重继承",{"2":{"201":1}}],["以及为什么高效",{"2":{"46":1}}],["以及过程入口和出口",{"2":{"190":1}}],["以及用于colorpoint数据成员的空间",{"2":{"187":1}}],["以及用于point数据成员的空间",{"2":{"187":1}}],["以及类特定数据成员",{"2":{"187":1}}],["以及编译器需要存储的其他值",{"2":{"187":1}}],["以及编译器生成的临时值",{"2":{"139":1}}],["以及在调用者和被调用者之间转移控制的规则",{"2":{"183":1}}],["以及在不使用0拷贝技术从内核缓冲区到用户缓冲区再到网卡缓冲区的过程",{"2":{"46":1}}],["以及具有向前查找功能的lr",{"2":{"181":1}}],["以及一些封装控制流的更复杂操作",{"2":{"169":1}}],["以及一个分支和两个跳转",{"2":{"223":1}}],["以及一个目标",{"2":{"186":1}}],["以及一个结果",{"2":{"169":1}}],["以及一个整数amount",{"2":{"58":1}}],["以及属性文法系统中",{"2":{"168":1}}],["以及将加法和减法运算符合并为一个终结符addsub",{"2":{"163":1}}],["以及推导出的事实",{"2":{"159":1}}],["以及该索引指向名称属性的仓库",{"2":{"139":1}}],["以及函数入口点的可重定位汇编语言标签",{"2":{"139":1}}],["以及相关的lr",{"2":{"125":1}}],["以及从该集合中的任何状态可以通过",{"2":{"113":1}}],["以及",{"2":{"88":1,"155":2,"159":1}}],["以及选或不选的情况",{"2":{"78":1}}],["以及结果变量",{"2":{"63":1}}],["以及两台机子rdma",{"2":{"46":1}}],["以及还说了一个错误的点",{"2":{"46":1}}],["以使用",{"2":{"29":1}}],["以防止数组太大的情况下",{"2":{"7":1}}],["而没有直接的成本",{"2":{"236":1}}],["而当前类的数据成员被添加到",{"2":{"236":1}}],["而fee",{"2":{"233":1}}],["而显式长度表示则需要一个足够大的整数来保存最大字符串长度",{"2":{"231":1}}],["而名称可能不重要",{"2":{"230":1}}],["而各个列表元素则可能在堆上分配",{"2":{"210":1}}],["而大多数情况下使用数组的应用会使用所有已分配的元素",{"2":{"209":1}}],["而块内的操作则用另一种ir表示",{"2":{"206":1}}],["而块内的操作则用另一种",{"2":{"206":1}}],["而用来创建和维护该模型的基础技术则不然",{"2":{"201":1}}],["而这些边描述了块之间的可能的控制转移",{"2":{"199":1}}],["而这些栈都存在于进程的虚拟地址空间内",{"2":{"33":1}}],["而ast则是后续阶段的主要数据结构",{"2":{"192":1}}],["而相对于apoint调用draw则是调用了point",{"2":{"187":1}}],["而colorpoint中声明的数据成员则位于它们下方",{"2":{"187":1}}],["而cpu在计算机里面占主要地位",{"2":{"46":1}}],["而cpu这么多年",{"2":{"46":1}}],["而无需担心周围的上下文环境",{"2":{"183":1}}],["而无需依赖aaa的上下文α",{"2":{"131":1}}],["而在不需要声明的语言中",{"2":{"233":1}}],["而在显式长度字符串中",{"2":{"231":1}}],["而在其他语言中",{"2":{"224":1}}],["而在其他情况下",{"2":{"173":1}}],["而在没有声明的语言中",{"2":{"190":1}}],["而在使用解析器生成工具构建的表格驱动解析器中",{"2":{"180":1}}],["而自顶向下的信息流则不然",{"2":{"178":1}}],["而自下而上的解析器则执行一次归约操作",{"2":{"129":1}}],["而必须将此解析推迟到运行时",{"2":{"172":1}}],["而$1",{"2":{"160":1}}],["而如果先通过",{"2":{"155":1}}],["而循环结束时的测试引用的是x2这一事实",{"2":{"155":1}}],["而虚拟寄存器没有内存地址",{"2":{"155":1}}],["而swap操作交换栈顶的两个元素",{"2":{"152":1}}],["而lisp的s表达式本身就是简单的图",{"2":{"148":1}}],["而值则存储在内存中",{"2":{"143":1}}],["而另一些ir则使大多数名称在表示中隐含",{"2":{"140":1}}],["而非从零开始设计一个新的解析器",{"2":{"130":1}}],["而且允许编译器开发者更灵活地应对语言中的歧义问题",{"2":{"130":1}}],["而且需要一个数组来记录是否已经被选过了",{"2":{"69":1}}],["而nfa具有多重歧义",{"2":{"112":1}}],["而nlp任务依赖语义建模",{"2":{"47":1}}],["而不是在每个对象的",{"2":{"236":1}}],["而不是在当前天购买",{"2":{"63":1}}],["而不是由编译器编写者决定",{"2":{"230":1}}],["而不是显式的",{"2":{"206":1}}],["而不是显式由程序员指定的名称",{"2":{"202":1}}],["而不是寄存器中",{"2":{"157":1}}],["而不是减少对物理寄存器的需求",{"2":{"143":1}}],["而不是从",{"2":{"78":1}}],["而不是从i开始枚举",{"2":{"69":1}}],["而不是枚举选或不选",{"2":{"73":1}}],["而上一个题目是组合",{"2":{"69":1}}],["而机器学习中需要固定纬度的输入",{"2":{"47":1}}],["而二分应该不如双指针快的",{"2":{"46":1}}],["而是这个层次结构在何时被定义",{"2":{"201":1}}],["而是需要根据操作数的类型生成条件逻辑",{"2":{"173":1}}],["而是应该是max",{"2":{"39":1}}],["而是会",{"2":{"19":1}}],["而",{"2":{"29":1,"197":1}}],["而一个block处理",{"2":{"11":1}}],["而blockdim",{"2":{"4":1}}],["3节讨论的单继承布局方案",{"2":{"187":1}}],["34",{"2":{"163":1}}],["3d3​",{"2":{"113":1}}],["30hr面",{"2":{"56":1}}],["31",{"2":{"29":1,"56":1}}],["33中",{"2":{"129":1}}],["33",{"2":{"19":1}}],["32位整数加法",{"2":{"220":1}}],["32∈",{"2":{"16":4}}],["32",{"2":{"16":14,"19":2,"68":1,"88":1}}],["3",{"0":{"10":1,"36":1,"74":1,"229":1},"1":{"14":1,"18":1,"21":1},"2":{"21":2,"33":1,"37":1,"39":1,"43":3,"49":3,"50":9,"53":4,"56":7,"58":3,"63":5,"64":27,"65":1,"66":3,"67":1,"68":3,"69":8,"72":1,"73":1,"75":3,"76":3,"78":9,"80":4,"84":2,"87":9,"88":3,"90":17,"93":4,"100":5,"101":2,"102":2,"103":2,"104":2,"106":2,"107":4,"113":3,"115":4,"162":1,"164":1,"176":4,"183":5,"206":1,"213":2,"214":2,"220":1}}],["争取做到每日复习一题做一题的地步",{"2":{"8":1}}],["巩固下思维和代码能力",{"2":{"8":1}}],["也包括为了操作这些值及其标签所需的逻辑",{"2":{"173":1}}],["也有可能实现额外的效率提升",{"2":{"163":1}}],["也很容易清除这些未使用的常量寄存器",{"2":{"155":1}}],["也适用于自下而上的解析器",{"2":{"129":1}}],["也方便后续nfa到dfa的转换",{"2":{"118":1}}],["也避免了不必要的状态转换计算",{"2":{"118":1}}],["也属于",{"2":{"115":1}}],["也可以构建为特殊目的的衍生ir",{"2":{"228":1}}],["也可以通过垃圾回收或引用计数等技术进行隐式管理",{"2":{"210":1}}],["也可以将它们全部合并到一个区域中",{"2":{"203":1}}],["也可以由多个段落组成",{"2":{"21":1}}],["也可能会贯穿整个执行过程",{"2":{"203":1}}],["也可能有一系列在将源代码翻译成目标语言的过程中使用的ir",{"2":{"132":1}}],["也可被视为正式的数学对象",{"2":{"102":1}}],["也算是一边看编译器",{"2":{"97":1}}],["也要递归到处理",{"2":{"78":1}}],["也没往深处问",{"2":{"39":1}}],["也没办法找实习了",{"2":{"22":1}}],["也是有限的",{"2":{"113":1}}],["也是一个候选",{"2":{"78":1}}],["也是在他提醒下写对了",{"2":{"41":1}}],["也是力扣上寻找两个有序数组中位数的思路",{"2":{"41":1}}],["也是写前两列",{"2":{"29":1}}],["也是只能针对特定长度的数组来进行优化",{"2":{"16":1}}],["也在",{"2":{"23":1}}],["也电话沟通过了",{"2":{"22":1}}],["也不打算面了",{"2":{"22":1}}],["也尽量做点新题",{"2":{"8":1}}],["也就是说",{"2":{"112":1,"131":1,"145":1,"159":1,"173":1,"175":1,"210":1}}],["也就是最左",{"2":{"87":1}}],["也就是不能超过股票交易次数",{"2":{"62":1,"74":1}}],["也就是不止一个线程来使用共享内存",{"2":{"7":1}}],["也就是在每个线程块中的线程已经完成了当前分段",{"2":{"7":1}}],["也就是更底层一步的缓存",{"2":{"7":1}}],["也就是三维的",{"2":{"4":1}}],["不展开说了",{"2":{"216":1}}],["不规则变量",{"0":{"210":1}}],["不规则变量的生命周期并不与任何单一的作用域绑定",{"2":{"175":1}}],["不执行表查找",{"2":{"163":1}}],["不关心",{"2":{"163":1}}],["不幸的是",{"2":{"163":1}}],["不可达",{"2":{"155":1}}],["不可以",{"2":{"22":1}}],["不平衡的树可能会退化成线性搜索",{"2":{"139":1}}],["不平衡的树具有更简单的插入和删除协议",{"2":{"139":1}}],["不能用于描述配对或嵌套的结构",{"2":{"131":1}}],["不能确定",{"2":{"112":1}}],["不分割",{"2":{"115":2}}],["不然那边教程的程序可能要自己另外写cmakelist",{"2":{"114":1}}],["不动点算法的终止论证通常依赖于域的已知属性",{"2":{"113":1}}],["不动点计算在编译器构造中扮演着重要且反复出现的角色",{"2":{"113":1}}],["不动点",{"2":{"113":1}}],["不考虑答案输出的顺序",{"2":{"99":1}}],["不等时",{"2":{"87":1}}],["不对应任何字母",{"2":{"73":1}}],["不支持",{"2":{"67":1}}],["不断查找下一个数",{"2":{"66":2}}],["不需要任何操作",{"2":{"93":1}}],["不需要任何硬币",{"2":{"58":1}}],["不需要考虑数组中超出新长度后面的元素",{"2":{"80":2,"87":2}}],["不需要发撒思维",{"2":{"8":1}}],["不拿的话",{"2":{"58":1}}],["不存在多个状态集合",{"2":{"115":1}}],["不存在",{"2":{"53":1,"66":1}}],["不持有股票",{"2":{"50":1}}],["不要求在使用前声明的语言迫使编译器构建一个抽象掉类型细节的初始ir",{"2":{"233":1}}],["不要求序列元素在原数组中连续",{"2":{"66":1}}],["不要使用除法",{"2":{"88":1}}],["不要使用额外的数组空间",{"2":{"87":1}}],["不要用矩阵填数这种思路",{"2":{"43":1}}],["不要访问同一个",{"2":{"29":1}}],["不应该更倾向于上海和杭州吗",{"2":{"43":1}}],["不应该是dp",{"2":{"39":1}}],["不知道为什么英伟达驱动自带的录屏只录了前面两分钟",{"2":{"35":1}}],["不访问同一个",{"2":{"29":3}}],["不是子串",{"2":{"100":1}}],["不是",{"2":{"23":1}}],["不会生气下的人数",{"2":{"103":1}}],["不会",{"2":{"29":1}}],["不会发生",{"2":{"19":2}}],["不会出现数据覆盖或使用旧数据的情况",{"2":{"7":1}}],["不同ir的数据空间需求变化范围很大",{"2":{"205":1}}],["不同的直接超类可能会对其成员分配冲突的偏移量",{"2":{"237":1}}],["不同的",{"2":{"127":1}}],["不同面额的硬币数组",{"2":{"58":1,"68":1}}],["不同malloc库实现上有什么区别",{"2":{"33":1}}],["不同",{"2":{"19":1}}],["我的环境是windows上的wsl",{"2":{"114":1}}],["我的思路就是对角线上坐标",{"2":{"43":1}}],["我顺便拉踩了下拼多多",{"2":{"46":1}}],["我和他说二分",{"2":{"46":1}}],["我和他实话实话6月份",{"2":{"41":1}}],["我想了想说几百g",{"2":{"46":1}}],["我想说的其实有点是这两个有点像房子装修的时候承重墙和非承重墙的区别",{"2":{"46":1}}],["我想慢点看用什么方法",{"2":{"33":1}}],["我讲的cmu的哪个neddle",{"2":{"46":1}}],["我当时觉得",{"2":{"46":1}}],["我当时楞了一下",{"2":{"43":1}}],["我当时不知道怎么想",{"2":{"39":1}}],["我大概采用了力扣上的思路",{"2":{"43":1}}],["我实话实话",{"2":{"43":1}}],["我只记得本科学的hadoop和他说一通",{"2":{"43":1}}],["我又和他说了一次无所谓",{"2":{"43":1}}],["我就说了一个锁的粒度",{"2":{"41":1}}],["我就说一个锁",{"2":{"39":1}}],["我也不知道我说的细不细",{"2":{"39":1}}],["我把代码贴在下面",{"2":{"39":1}}],["我其实听过也看过",{"2":{"39":1}}],["我弄成w",{"2":{"37":1}}],["我说了剪枝和量化",{"2":{"46":1}}],["我说参考书上实现的",{"2":{"46":1}}],["我说分布式好",{"2":{"46":1}}],["我说在纳秒级",{"2":{"46":1}}],["我说一台机子快",{"2":{"46":1}}],["我说就cpu的一个缓存块可以把分片矩阵的一行都给放进去",{"2":{"46":1}}],["我说b转置",{"2":{"46":1}}],["我说可能因为gpu是异构计算",{"2":{"46":1}}],["我说我没比较过",{"2":{"46":1}}],["我说我看过6",{"2":{"39":1}}],["我说没问题",{"2":{"43":1}}],["我说江苏扬州",{"2":{"43":1}}],["我说知道",{"2":{"39":1}}],["我说用过前两个",{"2":{"39":1}}],["我说看过",{"2":{"39":1}}],["我说的意思是线程中的栈是互相隔离的",{"2":{"33":1}}],["我说如果老师不喊我",{"2":{"22":1}}],["我答不会",{"2":{"33":1}}],["我所面的都是把输入在main函数中写死了",{"2":{"8":1}}],["我们绘制依赖图时",{"2":{"218":1}}],["我们应当考虑ir的表达能力",{"2":{"205":1}}],["我们应该使用一个线程对多个值的计算",{"2":{"11":1}}],["我们说这种语言具有开放的类结构",{"2":{"201":1}}],["我们说这样的语言具有封闭的类结构",{"2":{"201":1}}],["我们认为这种绑定是动态的",{"2":{"172":1}}],["我们认为这种绑定是静态的",{"2":{"172":1}}],["我们也可以为value添加一个解引用产生式",{"2":{"162":1}}],["我们注意到",{"2":{"150":1}}],["我们用一个例子来进行说明假设有如下的文法规则",{"2":{"147":1}}],["我们消除了factor这一层",{"2":{"146":1}}],["我们需要消除左递归",{"2":{"150":1}}],["我们需要定义两个集合firstfirstfirst和followfollowfollow",{"2":{"137":1}}],["我们需要一个字母表",{"2":{"105":1}}],["我们将",{"2":{"193":1}}],["我们将这种数据结构的集合称为中间表示",{"2":{"132":1}}],["我们将符号",{"2":{"127":1}}],["我们引入了上下文无关语法",{"2":{"131":1}}],["我们称r为被调方保存寄存器",{"2":{"187":1}}],["我们称r为调用方保存寄存器",{"2":{"187":1}}],["我们称这些变量为",{"2":{"175":1}}],["我们称这样的产生式为无用产生式",{"2":{"129":1}}],["我们称它是几乎唯一子数组",{"2":{"90":1}}],["我们讨论对语法以及动作",{"2":{"129":1}}],["我们考察对语法的转换",{"2":{"129":1}}],["我们在之前的nfa一节",{"2":{"127":1}}],["我们映入三个函数",{"2":{"123":1}}],["我们有如下的构造法",{"2":{"118":1}}],["我们现在对上面得到的dfa进行最小化",{"2":{"115":1}}],["我们拿下图进行举例说明",{"2":{"113":1}}],["我们是选择",{"2":{"112":1}}],["我们规定如下三个基础的正则表达式操作",{"2":{"105":1}}],["我们使用递归下降的语法分析方法来解析该文法",{"2":{"150":1}}],["我们使用有限自动机工作的目标是自动化从一组正则表达式推导出扫描器的过程",{"2":{"112":1}}],["我们使用更严谨的定义来说明正则表达式",{"2":{"105":1}}],["我们使用共享内存是为了提高内存利用率",{"2":{"7":1}}],["我们从左到右枚举",{"2":{"104":1}}],["我们就可以找到最长的连续序列的长度",{"2":{"66":1}}],["我们就不考虑以",{"2":{"66":1}}],["我们检查",{"2":{"66":1}}],["我们可以描述n1和n2如下",{"2":{"221":1}}],["我们可以构建ll",{"2":{"188":1}}],["我们可以进行一下修改",{"2":{"164":1}}],["我们可以把",{"2":{"155":1}}],["我们可以将这种策略编码为产生式特定的规则",{"2":{"160":1}}],["我们可以将其改写为",{"2":{"150":1}}],["我们可以将factor的产生式合并到term中",{"2":{"146":1}}],["我们可以修改成下面的文法",{"2":{"150":1}}],["我们可以通过将factor的不同展开选项合并到term中",{"2":{"129":1}}],["我们可以通过维护一个单调递增的双端队列来记录当前窗口内的最小价格",{"2":{"63":1}}],["我们可以从正则表达式中构造nfa",{"2":{"118":1}}],["我们可以一边遍历数组计算前缀和",{"2":{"106":1}}],["我们可以选择在之前购买食物",{"2":{"63":1}}],["我们可以选择拿或者不拿",{"2":{"58":1}}],["我们可以统一规定在卖出或者买入的时候减",{"2":{"62":1}}],["我们可以使用模板来实现",{"2":{"7":1}}],["我们给出状态方程",{"2":{"50":1}}],["我们采取下面的假设",{"2":{"11":1}}],["我们还是用一个线程去对应一个值的计算",{"2":{"11":1}}],["我们希望通过多线程的方式来进行加速",{"2":{"4":1}}],["这允许它为引用生成具体的代码",{"2":{"238":1}}],["这就是",{"2":{"203":1}}],["这就是nfa的不确定性",{"2":{"112":1}}],["这有时被称为静态调度",{"2":{"187":1}}],["这有时被称为调用序列",{"2":{"183":1}}],["这意味着它们只能在同一个包内访问",{"2":{"201":1}}],["这意味着若被调函数使用了寄存器r",{"2":{"187":1}}],["这意味着在调用其他函数之前",{"2":{"187":1}}],["这使得调用图的构建变得复杂",{"2":{"224":1}}],["这使得闭包可以在其定义的作用域之外继续访问这些变量",{"2":{"183":1}}],["这使得软件开发者可以构建大型软件系统",{"2":{"183":1}}],["这消除了歧义",{"2":{"180":1}}],["这消除了9个归约动作中的3个",{"2":{"146":1}}],["这既包括为了生成标签所需的逻辑",{"2":{"173":1}}],["这反过来又决定了编译器可以生成的代码",{"2":{"172":1}}],["这不利于特定上下文的定制",{"2":{"166":1}}],["这三项改动产生了如图3",{"2":{"163":1}}],["这与",{"2":{"162":1}}],["这时此类信息是可用的",{"2":{"233":1}}],["这时他会注意到",{"2":{"155":1}}],["这时候就保证了",{"2":{"87":1}}],["这时候就可以写入了",{"2":{"87":1}}],["这时候就要用高育良的那句话了",{"2":{"63":1}}],["这也确实使将ssa形式翻译回可执行代码的过程变得复杂",{"2":{"155":1}}],["这也就意味着",{"2":{"113":1}}],["这需要错误恢复装置与调用编译器各个遍历的驱动程序之间进行简单的握手",{"2":{"145":1}}],["这可能会减少复杂性并使某些算法更容易编写和理解",{"2":{"212":1}}],["这可能会使表更大",{"2":{"146":1}}],["这可能涉及到操作运行时堆栈或使用类似c语言中的setjmp和longjmp的非本地跳转",{"2":{"145":1}}],["这可以通过使用错误产生式",{"2":{"145":1}}],["这两种表示方式之间的真正差异在于计算字符串长度的成本",{"2":{"231":1}}],["这两种布局在空间需求上略有不同",{"2":{"231":1}}],["这两种构造方法产生的表都比规范的lr",{"2":{"181":1}}],["这两种设计之间的选择可能取决于目标机器的指令集架构",{"2":{"143":1}}],["这两个可以同时进行",{"2":{"104":1}}],["这两个我也直接说不知道了",{"2":{"39":1}}],["这为每个标识符创建了一系列子集",{"2":{"139":1}}],["这被称为fall",{"2":{"136":1}}],["这被称为taken",{"2":{"136":1}}],["这表明",{"2":{"130":1}}],["这类信息直到运行时才能得知",{"2":{"224":1}}],["这类变量通常是显式分配的",{"2":{"175":1}}],["这类代码逐渐被弃用",{"2":{"136":1}}],["这类解析器不仅便于实现",{"2":{"130":1}}],["这类计算的特点是对来自一个已知结构域的一些集合反复应用单调函数",{"2":{"113":1}}],["这减少了复杂性",{"2":{"118":1}}],["这会导致程序的复杂度增加",{"2":{"115":1}}],["这是语法上不明显的信息",{"2":{"180":1}}],["这是因为哈希的预期效率较高",{"2":{"139":1}}],["这是因为如果",{"2":{"66":1}}],["这是一种重要的简化",{"2":{"155":1}}],["这是一种基于栈的虚拟机的指令集架构",{"2":{"152":1}}],["这是一种自然的符号表示法",{"2":{"136":1}}],["这是一种特定的计算风格",{"2":{"113":1}}],["这是",{"2":{"114":2}}],["这恰好是它们",{"2":{"93":1}}],["这种翻译方案需要为then部分",{"2":{"223":1}}],["这种行为类似于基础类型发生的情况",{"2":{"221":1}}],["这种行为防止编译器在一个不正确的程序上浪费更多时间",{"2":{"145":1}}],["这种形式的语法接受相同的语言",{"2":{"204":1}}],["这种策略可以降低求值成本",{"2":{"198":1}}],["这种双重层次结构的命名空间导致了名称之间更复杂的交互和更为复杂的实现",{"2":{"187":1}}],["这种结构支持高效的方法查找和继承机制",{"2":{"187":1}}],["这种方式非常高效",{"2":{"187":1}}],["这种方法假设结构重要",{"2":{"230":1}}],["这种方法假设命名是一种有意的行为",{"2":{"230":1}}],["这种方法达到了预期的效果",{"2":{"187":1}}],["这种方法简单且效率高",{"2":{"187":1}}],["这种方法非常依赖于寄存器分配器",{"2":{"157":1}}],["这种方法就会显著变慢",{"2":{"139":1}}],["这种方法会把这些路径合并成一条路径",{"2":{"123":1}}],["这种机制确保了调用者无需关心被调函数内部对寄存器的使用情况",{"2":{"187":1}}],["这种分配必须是自动且高效的",{"2":{"183":1}}],["这种分类建议了用于存储值的具体数据区域",{"2":{"175":1}}],["这种比语法更深入的知识使得编译器能够检测出可能在运行时发生的错误",{"2":{"173":1}}],["这种名称到实体的绑定在翻译中起着关键作用",{"2":{"172":1}}],["这种二义性会导致编译器无法确定程序的正确语法结构",{"2":{"164":1}}],["这种空间节省可能会因为代码量增大而被抵消",{"2":{"163":1}}],["这种合并不仅减少了表的空间占用",{"2":{"163":1}}],["这种寄存器只读的",{"2":{"155":1}}],["这种设计创造了一个用于分发的程序紧凑形式和一个简单的语言移植到新机器的方案",{"2":{"152":1}}],["这种字节码要么在一个解释器中运行",{"2":{"152":1}}],["这种中间表示似乎是作为那些指令集架构的模型而出现的",{"2":{"152":1}}],["这种左递归会导致递归下降解析器陷入无限递归",{"2":{"150":1}}],["这种优化虽然增加了term的产生式数量",{"2":{"146":1}}],["这种重新同步更加复杂",{"2":{"145":1}}],["这种情况使得编译器难以生成正确的代码来保持x在寄存器中",{"2":{"157":1}}],["这种情况使得将值提升到未使用的寄存器中的优化变得尤为重要",{"2":{"143":1}}],["这种情况鼓励那些不会显著增加寄存器需求的优化",{"2":{"143":1}}],["这种技术几乎可以在任何允许离线解决方案的应用中取代哈希表",{"2":{"139":1}}],["这种技术增加了编译的一些成本",{"2":{"139":1}}],["这种函数可以在好的算法教科书中找到",{"2":{"139":1}}],["这种表的抽象视图如下所示",{"2":{"139":1}}],["这种能力也施加了一个要求",{"2":{"132":1}}],["这种的缺点是需要消耗大量内存",{"2":{"112":1}}],["这种使用全知nfa的模型吸引人之处在于它",{"2":{"112":1}}],["这种题目思路其实很简单",{"2":{"76":1}}],["这种做法的特点是",{"2":{"16":1}}],["这题怎么说呢",{"2":{"107":1}}],["这题显然也是滑动窗口",{"2":{"101":1}}],["这题是一个经典的滑动窗口",{"2":{"100":1}}],["这题是可以重复选的",{"2":{"78":1}}],["这题也是一眼滑动窗口",{"2":{"90":1}}],["这题也是一样的思路",{"2":{"72":1}}],["这题采用前后缀分解的方法",{"2":{"88":1}}],["这题和上一题很像",{"2":{"78":1}}],["这题其实是上题的一搬形式",{"2":{"74":1}}],["这题思路有很多",{"2":{"106":1}}],["这题思路是滑动窗口",{"2":{"103":1}}],["这题思路首先是如何计算满意的客户数量",{"2":{"103":1}}],["这题思路其实也是滑动窗口",{"2":{"93":1}}],["这题思路就是对左端点进行排序",{"2":{"84":1}}],["这题思路也和之前一样",{"2":{"73":1}}],["这题思路也是动态规划",{"2":{"58":1}}],["这题思路和上题差不多",{"2":{"68":1}}],["这题可以通过维护一个单调递减的单调队列来实现",{"2":{"64":1}}],["这题可以用一个单调队列来解决",{"2":{"64":1}}],["这题可以考虑用动态规划",{"2":{"50":1}}],["这题与上题的区别是",{"2":{"62":1}}],["这题被力扣hot100给害了",{"2":{"41":1}}],["这笔交易所能获得利润",{"2":{"50":3}}],["这样的框架更容易编写",{"2":{"204":1}}],["这样的共享机制使得dag比相应的ast更加紧凑",{"2":{"198":1}}],["这样的线性ir可以揭示目标机器本地代码的特性",{"2":{"148":1}}],["这样做非常有利",{"2":{"163":1}}],["这样做虽然使term的选择数量增加了三倍",{"2":{"129":1}}],["这样一来一回",{"2":{"155":1}}],["这样修改后",{"2":{"150":1}}],["这样按照thompson",{"2":{"118":1}}],["这样",{"2":{"63":1,"66":1}}],["这样我们可以从未来向过去考虑",{"2":{"63":1}}],["这样可以避免重复计算",{"2":{"66":1}}],["这样可以避免大量重复计算",{"2":{"66":1}}],["这样可以避免了重复计算",{"2":{"62":1}}],["这样可以",{"2":{"66":1}}],["这样可以递推下去",{"2":{"50":1}}],["这样大概半小时过去了",{"2":{"43":1}}],["这样在进行下一个分段的数据加载时",{"2":{"7":1}}],["这里的",{"2":{"198":1}}],["这里的枚举是枚举当前选哪个",{"2":{"73":1}}],["这里不展开了",{"2":{"195":1}}],["这里不想叙述书中所列举的",{"2":{"124":1}}],["这里所谓的虚方法",{"2":{"187":1}}],["这里三地址可以参考下一节的llvm",{"2":{"169":1}}],["这里$$代表整个表达式的值",{"2":{"160":1}}],["这里并没有列出",{"2":{"146":1}}],["这里",{"2":{"127":1}}],["这里我想记录一下书中所说的扫描器实现的一些优化",{"2":{"124":1}}],["这里也用了掩码的操作来避免if的判断",{"2":{"103":1}}],["这里将会从向量化开始记录",{"2":{"42":1}}],["这里预计更新搜索引擎相关的知识",{"2":{"40":1}}],["这里在",{"2":{"23":1}}],["这点被面试官提醒了",{"2":{"39":1}}],["这句话应该不太准确",{"2":{"33":1}}],["这些方法之间的选择取决于源语言的规则以及编译器设计者的偏好",{"2":{"238":1}}],["这些方法已经在实际系统中被使用",{"2":{"233":1}}],["这些私有成员可能是必要的",{"2":{"236":1}}],["这些类型进而作为类型推断的初始信息",{"2":{"233":1}}],["这些类别随后会在语法中作为不同的非终结符号出现",{"2":{"180":1}}],["这些ir编码了可能在线性ir中难以表示或操作的关系",{"2":{"228":1}}],["这些ir被称为确定性ir",{"2":{"182":1}}],["这些新类型应该具有与基础类型相同的本质属性",{"2":{"221":1}}],["这些可能被写成",{"2":{"215":1}}],["这些搜索发生的顺序取决于特定语言的作用域和继承规则",{"2":{"201":1}}],["这些后者系统倾向于将",{"2":{"198":1}}],["这些更高级别的抽象可以通过多个实体的集合来实现",{"2":{"191":1}}],["这些更为严格的构造算法的语法必须以某种方式成形",{"2":{"181":1}}],["这些机制共同构成了面向对象语言高效方法调度的基础",{"2":{"187":1}}],["这些保存寄存器值的生命周期与被调函数的生命周期相匹配",{"2":{"187":1}}],["这些保存的值必须被恢复",{"2":{"187":1}}],["这些初始化就是赋值操作",{"2":{"187":1}}],["这些数据也会放入被调用者的ar中",{"2":{"187":1}}],["这些局部声明会遮蔽任何先前定义的同名项",{"2":{"183":1}}],["这些代码可能是用不同的编译器编译的",{"2":{"183":1}}],["这些代码揭示了机器对隐式名称的使用",{"2":{"136":1}}],["这些语言使用括号来包含数组引用的下标表达式和子程序或函数的参数列表",{"2":{"180":1}}],["这些整数语法值计算也可以被写成对语法树的递归遍历",{"2":{"178":1}}],["这些名称保存各种操作的结果",{"2":{"169":1}}],["这些结构构成了ir不可或缺的一部分",{"2":{"165":1}}],["这些结构也是ir的一部分",{"2":{"132":1}}],["这些在图表中显示为空白",{"2":{"163":1}}],["这些状态的行就可以合并为一行",{"2":{"163":1}}],["这些规则可能是",{"2":{"160":1}}],["这些规则合起来构成了编译代码的内存模型",{"2":{"143":1}}],["这些树状的中间表示",{"2":{"151":1}}],["这些不同的内存模型对中间表示",{"2":{"143":1}}],["这些层次结构在软件中扮演着关键角色",{"2":{"139":1}}],["这些符号表与表示可执行代码的中间表示",{"2":{"139":1}}],["这些操作会并行执行",{"2":{"136":1}}],["这些过程可能是递归的",{"2":{"134":1}}],["这些过渡中的第一个如下所示",{"2":{"29":1}}],["这些技术中包括简单的lr",{"2":{"181":1}}],["这些技术直接减少了表的大小",{"2":{"163":1}}],["这些技术对于确保编译器能够正确理解和转换源代码至关重要",{"2":{"130":1}}],["这些技术仅适用于lr解析器",{"2":{"129":1}}],["这些转换能够减小表的大小",{"2":{"129":1}}],["这些转换能够减少推导的长度",{"2":{"129":1}}],["这些想法既适用于自上而下的解析器",{"2":{"129":1}}],["这些路径构成了dfa的正则表达式",{"2":{"127":1}}],["这些路径同样不经过编号高于k",{"2":{"127":1}}],["这些路径也不经过编号高于",{"2":{"127":1}}],["这些路径不经过编号高于k",{"2":{"127":1}}],["这些计算就会终止",{"2":{"113":1}}],["这些构造方法共同形成一个循环",{"2":{"112":1}}],["这些构造方法依赖于非确定性有限自动机",{"2":{"112":1}}],["这些子数组中",{"2":{"90":2}}],["这些对应于",{"2":{"29":1}}],["这些访存请求将会串行",{"2":{"19":1}}],["这一差异会影响到其他需要知道长度的操作",{"2":{"231":1}}],["这一策略简化了翻译框架",{"2":{"204":1}}],["这一转换可以降低分配的开销以及堆管理的成本",{"2":{"187":1}}],["这一限制消除了项目中对向前查找符号的需求",{"2":{"181":1}}],["这一行优化掉",{"2":{"155":1}}],["这一类解析器生成工具的广泛普及",{"2":{"130":1}}],["这一改动消除了九个归约动作中的三个",{"2":{"129":1}}],["这一节是书上没有对比的",{"2":{"158":1}}],["这一节将会重点介绍static",{"2":{"140":1}}],["这一节解析器",{"2":{"131":1}}],["这一节会介绍自顶向下解析器的非递归预测方法",{"2":{"122":1}}],["这一节主要介绍递归下降的语法分析方法",{"2":{"134":1}}],["这一节主要介绍另一种解析器",{"2":{"125":1}}],["这一节主要介绍自顶向下解析器和ll",{"2":{"121":1}}],["这一节主要讲的是如何识别单词",{"2":{"102":1}}],["这一天营业下来",{"2":{"103":1}}],["这一点很重要",{"2":{"72":1}}],["这一点会在下一个章节cutlas实现gemm中有详细说明",{"2":{"19":1}}],["这一开始我说的很粗糙",{"2":{"46":1}}],["这一步优化",{"2":{"16":1}}],["这个也是特别熟悉了",{"2":{"239":1}}],["这个规则有助于在解析器翻译成初始中间表示",{"2":{"233":1}}],["这个没什么好说的了",{"2":{"227":1}}],["这个虚拟地址空间就是整个图景",{"2":{"216":1}}],["这个应该读过csapp或ostep之类的书应该算比较了解的了",{"2":{"216":1}}],["这个层次结构具有树形结构",{"2":{"201":1}}],["这个决定将确定程序中的哪些值会被暴露给优化过程",{"2":{"197":1}}],["这个决定取决于实体的生命周期及其可见性",{"2":{"177":1}}],["这个激活记录",{"2":{"193":1}}],["这个模型随着解析器进入和离开各个作用域而变化",{"2":{"190":1}}],["这个结构依赖于类定义",{"2":{"187":1}}],["这个坐标告诉编译器沿着超类链向上查找多少步才能找到代码指针",{"2":{"187":1}}],["这个向量反映了通过继承层次解决这些名称的结果",{"2":{"187":1}}],["这个方案要求扫描器和解析器之间有协调",{"2":{"180":1}}],["这个方法和递归下降比较解决",{"2":{"122":1}}],["这个问题类似于在后面讨论的控制流图构建中分支模糊的问题",{"2":{"224":1}}],["这个问题的一个例子出现在几种早期的编程语言中",{"2":{"180":1}}],["这个问题之前我也想过",{"2":{"46":1}}],["这个想法效果不佳",{"2":{"178":1}}],["这个区域常常被称为常量池",{"2":{"175":1}}],["这个过程常被称为动态调度",{"2":{"187":1}}],["这个过程展示了典型的后进先出",{"2":{"183":1}}],["这个过程分为两个步骤",{"2":{"177":1}}],["这个过程称为隐式转换",{"2":{"173":1}}],["这个过程中",{"2":{"39":1}}],["这个语法出现二义性的原因是",{"2":{"164":1}}],["这个语法也会产生相当大的解析树",{"2":{"129":1}}],["这个很容易检测的事实",{"2":{"155":1}}],["这个比较难检测的条件",{"2":{"155":1}}],["这个未使用的变量剔除掉",{"2":{"155":1}}],["这个选项是必须要开的",{"2":{"114":1}}],["这个rtti是运行时类型信息",{"2":{"114":1}}],["这个点每次更新的时候",{"2":{"107":1}}],["这个判断可以使用",{"2":{"101":1}}],["这个题目是全排列",{"2":{"69":1}}],["这个题目和上一个题目很像",{"2":{"69":1}}],["这个题看起来简单",{"2":{"63":1}}],["这个时间有点久了",{"2":{"46":1}}],["这个我之前跑过",{"2":{"46":1}}],["这个当时没记录",{"2":{"41":1}}],["这个正常说",{"2":{"39":1}}],["这个代码应该从程序的内存布局角度来考虑",{"2":{"39":1}}],["这个两轮面试已过",{"2":{"34":1}}],["这个两个数据类型都dim3的",{"2":{"4":1}}],["这个标准答案应该是",{"2":{"33":1}}],["这个同步点的作用是确保所有线程都完成了当前分段上的乘法累加操作",{"2":{"7":1}}],["这个最小尺寸的立方体就对应着一个cuda",{"2":{"4":1}}],["这个立方体被切分成",{"2":{"4":1}}],["这个对应着整个grid",{"2":{"4":1}}],["上述例子创建了一个新的类型node",{"2":{"221":1}}],["上一小节描述了如何将nfa转换为dfa",{"2":{"115":1}}],["上一小节描述了nfa的构造方法",{"2":{"113":1}}],["上构建",{"2":{"114":1}}],["上下文语法英文是context",{"2":{"131":1}}],["上下文无关的的意思在文法推导的每一步",{"2":{"131":1}}],["上下文无关语法g由一个四元组来进行定义",{"2":{"131":1}}],["上下文无关语法",{"0":{"120":1,"131":1},"1":{"131":1,"147":1,"164":1}}],["上下文建模",{"2":{"67":1,"75":1}}],["上下文窗口",{"2":{"67":1}}],["上下文窗口大小",{"2":{"67":1}}],["上下文词的",{"2":{"67":1}}],["上下文",{"2":{"47":1}}],["上下班时间",{"2":{"46":1}}],["上半部分",{"2":{"43":1}}],["上图展示了三种表示三地址码的方案",{"2":{"186":1}}],["上图展示了在每种模型下相同的加法操作",{"2":{"143":1}}],["上图图展示了语句",{"2":{"166":1}}],["上图显示了参与",{"2":{"29":1}}],["上图中",{"2":{"29":1}}],["上",{"2":{"23":2,"50":1}}],["上面是消除直接左递归的例子",{"2":{"150":1}}],["上面是英伟达gtc大会ppt上的截图",{"2":{"29":1}}],["上面的循环可以直接用下一步的初始化",{"2":{"66":1}}],["上面的代码",{"2":{"11":1}}],["上面代码自然而然可以用动态规划来进行优化",{"2":{"53":1}}],["上面使用共享内存优化依然存在的问题是",{"2":{"11":1}}],["上的部分积计算之后",{"2":{"7":1}}],["上文的乘法",{"2":{"4":1}}],["将存储布局引入翻译过程",{"0":{"238":1},"1":{"239":1}}],["将多个任意类型的对象组合在一起",{"2":{"221":1}}],["将多个简单操作组合成复杂操作",{"2":{"183":1}}],["将比最大长度",{"2":{"212":1}}],["将线性代码序列划分为基本块",{"2":{"207":1}}],["将代码划分为基本块",{"2":{"206":1}}],["将语法塑造成适应计算的方式可以简化语法驱动的动作",{"2":{"204":1}}],["将创建新的作用域并将其链接到搜索路径中",{"2":{"204":1}}],["将类名输入到当前的词法作用域",{"2":{"201":1}}],["将goto",{"2":{"195":1}}],["将a压入输入符号栈",{"2":{"195":1}}],["将aj→aiαa",{"2":{"167":1}}],["将状态j压入状态栈",{"2":{"195":1}}],["将此语法驱动翻译方案应用于表达式",{"2":{"194":1}}],["将四元组链接成一个列表",{"2":{"186":1}}],["将剩余部分作为新产生式的右部",{"2":{"184":1}}],["将操作封装在闭包中稍后执行",{"2":{"183":1}}],["将闭包作为参数传递给其他函数",{"2":{"183":1}}],["将input",{"2":{"179":1,"195":1}}],["将单个字符转换为整数值",{"2":{"178":1}}],["将单词适配到源编程语言的语法规则模型中",{"2":{"131":1}}],["将浮点数用作指针",{"2":{"173":1}}],["将$放入",{"2":{"170":1}}],["将值视为地址并表示内存引用",{"2":{"166":1}}],["将值保存在寄存器中",{"0":{"157":1}}],["将相同的行或列合并是一种优化技术",{"2":{"163":1}}],["将num和name合并成一个符号val会移除这些列中的一个",{"2":{"163":1}}],["将nvptx换成amggpu即可",{"2":{"114":1}}],["将两个产生式",{"2":{"163":1}}],["将这样的运算符添加到表达式语法中需要谨慎处理",{"2":{"162":1}}],["将累积的值乘以十再加上下一个数字",{"2":{"160":1}}],["将信息收集和ir构建过程与输入程序的语法结构和语义细节关联起来",{"2":{"159":1}}],["将x",{"2":{"157":1}}],["将解析树的节点从14个减少到11个",{"2":{"146":1}}],["将活跃值移到堆栈上或从堆栈上移除",{"2":{"143":1}}],["将输入符号移入栈中",{"2":{"142":1}}],["将键映射到索引",{"2":{"139":1}}],["将lookahead挪到下一个位置",{"2":{"134":1}}],["将lookahead指向的位置与产生式迭代生",{"2":{"134":1}}],["将不会为空",{"2":{"127":1}}],["将子集构造应用于这个nfa",{"2":{"123":1}}],["将",{"2":{"113":1,"153":1,"167":1,"170":1,"188":2}}],["将正则表达式所描述的语言记作l",{"2":{"105":1}}],["将它们合并为",{"2":{"84":1}}],["将头部元素弹出",{"2":{"63":1}}],["将当前天的索引和价格作为键值对添加到双端队列尾部",{"2":{"63":1}}],["将当前窗口内的最小价格",{"2":{"63":1}}],["将尾部元素弹出",{"2":{"63":1}}],["将文本映射到低维稠密向量空间",{"2":{"47":1}}],["将结果写回全局内存",{"2":{"7":1}}],["将任务分为多个线程",{"2":{"4":1}}],["\\t",{"2":{"7":1,"16":1,"41":2}}],["分号等",{"2":{"176":2}}],["分支和跳转",{"2":{"223":1}}],["分支",{"2":{"169":1}}],["分配和访问内存",{"2":{"232":1}}],["分配和释放发生在与任何特定过程的生命周期无关的时间点",{"2":{"210":1}}],["分配寄存器",{"2":{"155":1}}],["分配一个",{"2":{"23":1}}],["分析跳转和分支指令",{"2":{"207":1}}],["分析表",{"2":{"188":1}}],["分析表的构建",{"0":{"188":1}}],["分析可以揭示出原本需要在堆上分配的or",{"2":{"187":1}}],["分析",{"2":{"159":1}}],["分析过程",{"2":{"134":1}}],["分析树的构造方法",{"2":{"121":2}}],["分钟保持冷静",{"2":{"103":1}}],["分钟不生气",{"2":{"103":1}}],["分词",{"2":{"75":1}}],["分词后的语料",{"2":{"67":1}}],["分别位于虚拟寄存器vra",{"2":{"143":1}}],["分别为",{"2":{"90":2}}],["分别是查询",{"2":{"75":1}}],["分别会发生什么",{"2":{"39":1}}],["分别对应要计算的",{"2":{"4":1}}],["分成",{"2":{"23":1}}],["分块内部列号",{"2":{"16":2}}],["分块内部行号",{"2":{"16":2}}],["分段共享读取",{"2":{"7":1}}],["达到加速计算的结果",{"2":{"7":1}}],["再选择性地",{"2":{"155":1}}],["再次捕捉语法",{"2":{"206":1}}],["再次应用第一个产生式",{"2":{"150":1}}],["再次考虑经典的左递归表达式语法",{"2":{"129":1}}],["再与从",{"2":{"127":1}}],["再通过",{"2":{"112":1}}],["再添加一个数就是",{"2":{"90":1}}],["再判断是否出界的情况",{"2":{"76":1}}],["再转换为数值向量",{"2":{"47":1}}],["再访问会遇见什么问题",{"2":{"41":1}}],["再试了一下",{"2":{"39":1}}],["再继续进行计算",{"2":{"23":2}}],["再继续处理",{"2":{"23":1}}],["再统一进行计算",{"2":{"7":1}}],["再对应到相应的",{"2":{"4":1}}],["在处理第一条可执行语句之前",{"2":{"238":1}}],["在许多实现中",{"2":{"236":1}}],["在许多情况下",{"2":{"173":1}}],["在具有强制声明的语言中",{"2":{"233":1}}],["在具有更复杂推断规则的语言中",{"2":{"233":1}}],["在具有封闭类结构的语言中",{"2":{"187":1}}],["在执行过程中会改变调用图",{"2":{"224":1}}],["在面向对象的语言中",{"2":{"226":1,"236":1}}],["在面向对象程序中",{"2":{"224":1}}],["在面向对象语言",{"2":{"187":1}}],["在选定子部分的末尾",{"2":{"223":1}}],["在选择解析策略时",{"2":{"130":1}}],["在更复杂的数据依赖图应用中",{"2":{"218":1}}],["在数据依赖图中",{"2":{"218":1}}],["在数组上可能没有对应的运算",{"2":{"209":1}}],["在上述例子中",{"2":{"215":1}}],["在控制流合并点插入φ函数",{"2":{"208":1}}],["在后续引用出现位置",{"2":{"204":1}}],["在后端的",{"2":{"155":1}}],["在后端",{"2":{"143":2}}],["在名称x的定义出现位置",{"2":{"204":1}}],["在树遍历表述中",{"2":{"204":1}}],["在继承的情况下",{"2":{"201":4}}],["在单一继承环境中",{"2":{"236":1}}],["在单一继承的语言中",{"2":{"201":1}}],["在单继承的情况下",{"2":{"236":1}}],["在单继承情况下",{"2":{"187":1}}],["在为这个表达式构建",{"2":{"198":1}}],["在dag中",{"2":{"198":1}}],["在图",{"2":{"197":1}}],["在图中表现为一个superclass指针",{"2":{"201":1}}],["在图中",{"2":{"29":1}}],["在抽象语法树",{"2":{"197":1}}],["在翻译期间",{"2":{"201":1}}],["在翻译源代码的过程中",{"2":{"197":1}}],["在翻译过程中一致且逐步地做出这些决定",{"2":{"143":1}}],["在过程内声明的静态变量具有过程范围的可见性",{"2":{"203":1}}],["在过程",{"2":{"193":1}}],["在实现上",{"2":{"226":1}}],["在实际的编译器或解释器设计中",{"2":{"192":1}}],["在实践中",{"2":{"178":2}}],["在退出时",{"2":{"190":1}}],["在进入作用域时创建一个新表",{"2":{"190":1}}],["在进入一个块时",{"2":{"155":1}}],["在类似algol的语言",{"2":{"187":1}}],["在编译期为每个过程分配固定的内存空间",{"2":{"187":1}}],["在编译器构造中",{"2":{"236":1}}],["在编译器可以将源程序翻译成其中间表示",{"2":{"143":1}}],["在编译器中",{"2":{"136":1}}],["在堆内存中动态分配活动记录",{"2":{"187":1}}],["在堆栈模型中",{"2":{"143":1}}],["在函数结束前恢复r的原始值",{"2":{"187":1}}],["在返回到p时",{"2":{"187":1}}],["在被调用者的arp处的槽位保存了调用者的arp",{"2":{"187":1}}],["在下图",{"2":{"186":2}}],["在下一节中补充",{"2":{"16":1}}],["在c++中",{"2":{"187":1}}],["在c++中通过lambda表达式实现",{"2":{"183":1}}],["在c语言中实现一个解析树的程序员可能需要具有一个孩子节点和两个孩子节点的节点",{"2":{"221":1}}],["在c语言中",{"2":{"175":1,"221":1}}],["在调用语句之后立即的位置继续执行",{"2":{"183":1}}],["在系统设计和工程中也是一样",{"2":{"183":1}}],["在开发期间对于每一次编辑更改都要重新编译一个拥有数百万行代码的应用程序",{"2":{"183":1}}],["在开启了优化的情况下",{"2":{"155":1}}],["在那时可以通过从声明派生出的类型信息来解决",{"2":{"180":1}}],["在自上而下",{"2":{"180":1}}],["在自顶向下的解析器中",{"2":{"145":1}}],["在运行时",{"2":{"175":1}}],["在值的生命周期之外",{"2":{"175":1}}],["在表达式",{"2":{"173":1}}],["在某些语言中",{"2":{"224":1}}],["在某些情况下可以改为存放在某个方法的ar中",{"2":{"187":1}}],["在某些情况下",{"2":{"173":1}}],["在某些分钟内",{"2":{"103":1}}],["在程序的一个点",{"2":{"172":1}}],["在讨论构建和维护可见性模型的机制之前",{"2":{"172":1}}],["在三地址码中",{"2":{"169":2}}],["在ir中隐含的事实很难改变",{"2":{"166":1}}],["在黑色菱形块操作符的右边",{"2":{"166":1}}],["在黑色菱形块操作符的左边",{"2":{"166":1}}],["在基于遍的编译器中",{"2":{"165":1}}],["在action表中",{"2":{"163":1}}],["在经典表达式语法中",{"2":{"163":1}}],["在规则integer",{"2":{"160":1}}],["在左侧",{"2":{"160":1}}],["在其他因素相同的情况下",{"2":{"212":1}}],["在其他上下文中也会出现",{"2":{"204":1}}],["在其他调用中则不然",{"2":{"157":1}}],["在其中名称被声明",{"2":{"139":1}}],["在给定的过程里",{"2":{"157":1}}],["在中端方便了优化",{"2":{"155":1}}],["在多个不同值可以到达一个块的起点的位置插入了φ函数",{"2":{"155":1}}],["在生成",{"2":{"155":1}}],["在我们的例子中",{"2":{"146":1}}],["在递归下降解析器中",{"2":{"146":1}}],["在寄存器到寄存器模型中",{"2":{"143":1}}],["在内存中的下一个实体之前可能会浪费一些空间",{"2":{"239":1}}],["在内存到内存模型中",{"2":{"143":1}}],["在内层循环每一轮中",{"2":{"23":1}}],["在一个面向对象的语言中",{"2":{"201":1}}],["在一个多重继承的语言中",{"2":{"201":1}}],["在一个有声明的语言中",{"2":{"190":1}}],["在一个稍微反直觉的结果中",{"2":{"181":1}}],["在一个作用域内部",{"2":{"172":1}}],["在一个表驱动的解析器中",{"2":{"145":1}}],["在一个lr",{"2":{"145":1}}],["在一个递归下降解析器中",{"2":{"145":1}}],["在一个寄存器到寄存器的模型中展示了相同的加法操作",{"2":{"143":1}}],["在一个等价预测语法的自上而下的递归下降解析器中",{"2":{"129":1}}],["在大多数编程语言中",{"2":{"183":1}}],["在大多数其他需要源代码级别树结构的应用中",{"2":{"168":1}}],["在大多数语言中",{"2":{"139":1}}],["在大多数指令集架构中",{"2":{"136":1}}],["在解析器进行规约时应用",{"2":{"160":1}}],["在解析期间",{"2":{"139":1}}],["在解析时会花费较少的时间",{"2":{"129":1}}],["在手工编码解析器的选择中占据了重要位置",{"2":{"130":1}}],["在众多解析方法中",{"2":{"130":1}}],["在lr解析中",{"2":{"161":1}}],["在lr",{"2":{"129":1,"146":2}}],["在逐个比较",{"2":{"124":1}}],["在计算机科学的许多领域中经常出现",{"2":{"113":1}}],["在哈希集合中",{"2":{"66":1}}],["在每个节点",{"2":{"233":1}}],["在每个表中查找m",{"2":{"201":1}}],["在每个调用点存储最近使用的类和代码指针",{"2":{"187":1}}],["在每次调用过程前",{"2":{"187":1}}],["在每次遍历中",{"2":{"63":1}}],["在每一步中",{"2":{"102":1}}],["在每一天",{"2":{"50":1}}],["在卖出股票和买入股票的时候修改",{"2":{"62":1}}],["在买入和卖出股票的时候",{"2":{"50":1}}],["在这两种情况下",{"2":{"239":1}}],["在这些地方它们是权威的中间表示",{"2":{"168":1}}],["在这一点上",{"2":{"145":1}}],["在这个语法中",{"2":{"146":1}}],["在这个例子中",{"2":{"123":1,"183":1}}],["在这个模型中",{"2":{"112":1}}],["在这种情况下",{"2":{"50":1,"104":1,"183":1,"198":1}}],["在这里",{"2":{"4":1}}],["在第",{"2":{"50":6,"104":2}}],["在最后结果上被面试官提醒了",{"2":{"43":1}}],["在文本文件中查关键字",{"2":{"33":1}}],["在",{"2":{"29":1,"154":1,"155":2,"175":1}}],["在nvidia",{"2":{"7":1}}],["知道上面的问题",{"2":{"7":1}}],["并按照它们的对齐限制从大到小排序",{"2":{"239":1}}],["并发出带有抽象引用的ir",{"2":{"238":1}}],["并依赖于后续对ir的遍历来完成翻译",{"2":{"238":1}}],["并依赖编译器的名字解析机制来强制执行可见性约束",{"2":{"203":1}}],["并让编译器避免运行时类型检查",{"2":{"235":1}}],["并随后在这个抽象ir上执行类型推断和检查",{"2":{"233":1}}],["并随后被丢弃",{"2":{"182":1}}],["并执行一次或多次遍历来为子表达式分配类型",{"2":{"233":1}}],["并以指定的字符串结束标记来标识字符串的末尾",{"2":{"231":1}}],["并优化该子集",{"2":{"224":1}}],["并消除了使用全局变量在产生式之间传递信息的需求",{"2":{"204":1}}],["并确保它们可以通过名称a来寻址",{"2":{"202":1}}],["并给每个对象一个独特的名称",{"2":{"202":1}}],["并沿词法层次结构向上工作",{"2":{"201":1}}],["并沿继承层次结构向上工作",{"2":{"201":1}}],["并",{"2":{"201":1}}],["并行性分析",{"2":{"200":1}}],["并通过边连接这些块",{"2":{"199":1}}],["并通过查看下一个输入符号",{"2":{"142":1}}],["并丢弃",{"2":{"198":1}}],["并两次使用该结果",{"2":{"198":1}}],["并返回当前绑定到该名称的实体的符号表条目",{"2":{"194":1}}],["并保留了正确执行所需的状态",{"2":{"187":1}}],["并保持五个移进",{"2":{"129":1}}],["并生成直接调用",{"2":{"187":1}}],["并维护",{"2":{"187":2}}],["并可以在后续调用时使用这个值",{"2":{"183":1}}],["并根据调用和语言创建任何指定的这两个环境之间的链接",{"2":{"183":1}}],["并添加所需的额外代码来检查名称的声明类型",{"2":{"180":1}}],["并为成员名称引用生成代码",{"2":{"201":1}}],["并为数据区域内的各个值分配偏移量",{"2":{"175":1}}],["并为每个标识符实例构建一个",{"2":{"139":1}}],["并在没有好处的情况下增加编译时间",{"2":{"197":1}}],["并在控制退出该过程时释放",{"2":{"193":1}}],["并在对象不再可达时释放",{"2":{"187":1}}],["并在被调函数执行完毕后恢复这些值",{"2":{"187":1}}],["并在达到固定点后计算它们的闭包",{"2":{"181":1}}],["并在数据区域内遍历该数据区域的值",{"2":{"175":1}}],["并在使用",{"2":{"87":1}}],["并由解析器的动作排序",{"2":{"159":1}}],["并由符号标签命名",{"2":{"143":1}}],["并翻译代码以便其能在某个目标机器上执行",{"2":{"159":1}}],["并重新命名变量使得单赋值属性得以保持",{"2":{"155":1}}],["并尝试把他们优化为虚拟寄存器",{"2":{"155":1}}],["并从中间表示中消除了许多名称",{"2":{"152":1}}],["并使用图来表示这些块之间的控制流",{"2":{"149":1}}],["并建立辅助结构来记录这些派生的知识",{"2":{"148":1}}],["并将其链接到周围的继承层次结构中",{"2":{"201":1}}],["并将其链接到与当前作用域关联的块的搜索路径的起始位置",{"2":{"190":1}}],["并将其与词素",{"2":{"194":1}}],["并将其连接到所有原本是接受状态的状态",{"2":{"123":1}}],["并将找到的结果缓存",{"2":{"187":1}}],["并将一组参数或实参从调用者的命名空间映射到被调用者的命名空间",{"2":{"183":1}}],["并将所有含糊的值",{"2":{"157":1}}],["并将任何无法保留在物理寄存器中的虚拟寄存器溢出到内存",{"2":{"157":1}}],["并将它们的差值压入栈中",{"2":{"152":1}}],["并将它们的结果压入栈中",{"2":{"152":1}}],["并将由goto",{"2":{"145":1}}],["并将不活跃的值移回内存",{"2":{"143":1}}],["并提供对该信息的有效访问",{"2":{"132":1}}],["并选择在",{"2":{"104":1}}],["并预测",{"2":{"75":1}}],["并统计序列的长度",{"2":{"66":2}}],["并知晓",{"2":{"42":1}}],["并对每个线程指针的列索引应用",{"2":{"29":1}}],["并假设是",{"2":{"29":1}}],["并不是完全错误",{"2":{"33":1}}],["并不想骗人",{"2":{"22":1}}],["并不需要你每次都重新读内存",{"2":{"7":1}}],["并且能够访问其超类的代码成员",{"2":{"236":1}}],["并且作用域规则将确保正确的解释",{"2":{"234":1}}],["并且程序员使用名称来传达意义",{"2":{"230":1}}],["并且定义了用于解析对象相对引用的继承层次结构",{"2":{"226":1}}],["并且有可能在单次执行中多次发生",{"2":{"210":1}}],["并且有限自动机可以识别任何可以用正则表达式指定的语言",{"2":{"112":1}}],["并且相同的子树会被复用",{"2":{"198":1}}],["并且尽可能清晰地报告这些错误的原因",{"2":{"196":1}}],["并且任何两个产生式a→α|β都满足下列条件",{"2":{"188":1}}],["并且需要垃圾回收机制来管理不再使用的内存",{"2":{"187":1}}],["并且剩余的项目可以通过计算其闭包来添加到集合中",{"2":{"181":1}}],["并且通常在其作用域外不可见",{"2":{"172":1}}],["并且在填充上浪费了六个字节",{"2":{"239":1}}],["并且在退出作用域时其值就不再存在",{"2":{"175":1}}],["并且在编译期间必须遍历所有这些节点和边",{"2":{"168":1}}],["并且在解析开始之前就明确了符号表的初始大小",{"2":{"139":1}}],["并且缺少骨架解析器中的外部循环",{"2":{"163":1}}],["并且每当遇到一个新的数字时",{"2":{"160":1}}],["并且每个数据都会重复使用",{"2":{"23":1}}],["并且只向前查看1个符号",{"2":{"156":1}}],["并且只提前看一个符号",{"2":{"137":1}}],["并且明确支持数组和结构体地址",{"2":{"154":1}}],["并且这是决定运行时性能的关键因素之一",{"2":{"143":1}}],["并且是经过验证的有效解决方案",{"2":{"130":1}}],["并且添加一个新的初始状态",{"2":{"123":1}}],["并且合并nfa转换图中的路径",{"2":{"123":1}}],["并且没有回溯",{"2":{"122":1}}],["并且此时",{"2":{"115":1}}],["并且对于每一个字符都能产生确定的状态转移",{"2":{"112":1}}],["并且nfa可能对一个字符产生两个状态转移",{"2":{"112":1}}],["并且可以支持多种编程语言",{"2":{"110":1}}],["并且可以给出其状态图",{"2":{"102":1}}],["并且原数组的前七个元素被修改为",{"2":{"87":1}}],["并且原数组的前五个元素被修改为",{"2":{"87":1}}],["并且原数组",{"2":{"80":2}}],["并且小r在购买完食物后最多只能同时携带",{"2":{"63":1}}],["并且当晚发了云证",{"2":{"56":1}}],["并且成为了互联网主导编码",{"2":{"47":1}}],["并且保证sa和sb的大小正好和线程块的线程数目一致",{"2":{"16":1}}],["并且使用的共享内存",{"2":{"11":1}}],["并且规定立方体的不可被分割的最小尺寸为",{"2":{"4":1}}],["行为",{"2":{"183":1}}],["行优先",{"2":{"29":1}}],["行内脚注文本",{"2":{"21":1}}],["行内的脚注",{"2":{"21":1}}],["行",{"2":{"19":1}}],["行上的数据",{"2":{"7":1}}],["行都可以用来计算",{"2":{"7":1}}],["行和",{"2":{"7":1}}],["行乘以",{"2":{"4":1}}],["就像c++中的虚函数一样",{"2":{"201":1}}],["就很容易安排",{"2":{"180":1}}],["就避免产生了二义性",{"2":{"164":1}}],["就不允许再次修改",{"2":{"155":1}}],["就对应于",{"2":{"114":1}}],["就说明可以到达",{"2":{"107":1}}],["就得到了以当前元素结尾的子数组和的最大值",{"2":{"106":1}}],["就将和置为0",{"2":{"106":1}}],["就可以正常工作了",{"2":{"150":1}}],["就可以算出",{"2":{"88":1}}],["就可以采取更进一步的优化了",{"2":{"7":1}}],["就把两个区间合并成一个区间",{"2":{"84":1}}],["就是除",{"2":{"155":1}}],["就是最左推导",{"2":{"137":1}}],["就是dfa状态转移没有二义性",{"2":{"112":1}}],["就是一个开源的编译器基础设施",{"2":{"110":1}}],["就是一个他说他也不知道答案的问题",{"2":{"46":1}}],["就是维护一共最找到达的点",{"2":{"107":1}}],["就是相当于状态转移图中边的标签的集合",{"2":{"102":1}}],["就是在里面如何少用if判断",{"2":{"93":1}}],["就是减少两次用户态和内核态切换的开销",{"2":{"46":1}}],["就是我提了一嘴neddl里数组实现的那种逻辑计算索引的策略",{"2":{"46":1}}],["就是为什么gpu会对缓存进行编程",{"2":{"46":1}}],["就是想知道我的理解",{"2":{"46":1}}],["就是每次计算",{"2":{"7":1}}],["就这两个问题",{"2":{"41":1}}],["就能答上来了",{"2":{"39":1}}],["就聊项目",{"2":{"31":1}}],["就一句话来说",{"2":{"4":1}}],["2给factorial",{"2":{"183":1}}],["2节",{"2":{"143":1}}],["2d2​",{"2":{"113":1}}],["2n2^n2n",{"2":{"113":1}}],["2n2​",{"2":{"112":1}}],["2n−1−12^",{"2":{"21":1}}],["2n−1",{"2":{"21":2}}],["2k2^k2k",{"2":{"101":1}}],["26",{"2":{"99":2}}],["26行和31行处的",{"2":{"7":1}}],["2slow−2",{"2":{"87":2}}],["2slow=2",{"2":{"87":1}}],["2i+1",{"2":{"75":3}}],["2i",{"2":{"75":5}}],["23",{"2":{"73":1,"90":2,"106":1}}],["24给factorial",{"2":{"183":1}}],["24hr面之后的后续流程",{"2":{"56":1}}],["24",{"2":{"56":2,"88":1,"183":1}}],["21流程显示进入hr面",{"2":{"56":1}}],["25",{"2":{"49":1}}],["20世纪80年代和90年代risc架构的兴起使这类代码再次流行起来",{"2":{"136":1}}],["2022年出版的第三版英文原版",{"2":{"97":1}}],["2024",{"0":{"8":1,"36":1}}],["2013",{"2":{"67":1}}],["20",{"2":{"56":1,"67":1,"202":1}}],["2005",{"2":{"110":1}}],["2000",{"2":{"110":1}}],["2000w来分一下",{"2":{"41":1}}],["200",{"2":{"39":1,"66":1,"202":2}}],["2^",{"2":{"21":1}}],["2∈",{"2":{"16":4}}],["2",{"0":{"6":1,"62":1,"225":1},"1":{"10":1,"14":1,"18":1,"21":1},"2":{"16":4,"19":1,"21":5,"33":1,"37":1,"43":8,"47":1,"49":2,"50":3,"53":5,"58":6,"63":5,"64":2,"65":1,"66":4,"67":3,"68":4,"69":8,"72":2,"73":3,"75":3,"76":5,"78":15,"80":10,"84":3,"87":12,"88":3,"90":12,"93":3,"99":3,"100":1,"101":7,"102":2,"103":2,"104":2,"106":4,"107":3,"113":1,"114":1,"115":4,"129":2,"150":4,"152":1,"155":5,"159":1,"164":1,"166":1,"167":3,"168":1,"169":1,"183":6,"184":2,"185":2,"186":1,"194":2,"201":1,"206":1,"213":3,"214":2,"220":1}}],["0的条件",{"2":{"183":1}}],["0p0​",{"2":{"115":3}}],["0=",{"2":{"115":1}}],["0=cbow",{"2":{"67":1}}],["0n0​",{"2":{"112":2,"113":1}}],["0s0​",{"2":{"102":1,"103":1}}],["0110",{"2":{"101":2}}],["01",{"2":{"101":1}}],["00",{"2":{"101":2}}],["00110110",{"2":{"101":1}}],["000个整数预留了空间",{"2":{"202":1}}],["000",{"2":{"50":2,"127":1}}],["0d0​",{"2":{"113":1,"127":1}}],["0dp",{"2":{"58":1}}],["0dfs",{"2":{"50":1,"62":1,"74":1}}],["05",{"0":{"8":1}}],["0",{"2":{"7":2,"11":4,"16":23,"19":1,"29":1,"39":1,"41":1,"43":14,"50":14,"53":6,"58":11,"62":12,"63":8,"66":2,"68":5,"69":5,"72":2,"73":2,"74":12,"80":4,"84":4,"87":6,"88":9,"90":3,"93":4,"99":7,"101":3,"102":2,"103":7,"104":4,"106":12,"107":4,"115":1,"131":2,"142":7,"174":8,"179":1,"183":4,"195":1}}],["0x3f",{"2":{"5":1}}],["0f",{"2":{"4":1,"7":3,"11":1,"16":3}}],["列表",{"2":{"191":1}}],["列为终结符或者开始符号$",{"2":{"188":1}}],["列从全局内存中重新读进来一次",{"2":{"7":1}}],["列",{"2":{"4":1}}],["和它的子类",{"2":{"236":1}}],["和边组成",{"2":{"206":1}}],["和规约",{"2":{"195":1}}],["和不规则",{"2":{"177":1}}],["和绝对值",{"2":{"162":1}}],["和抽象语法树",{"2":{"158":1}}],["和所有",{"2":{"155":1}}],["和有向无环图",{"2":{"151":1}}],["和指令集架构",{"2":{"143":1}}],["和ll",{"2":{"130":2}}],["和lalr",{"2":{"130":1,"181":1}}],["和转义",{"2":{"129":1}}],["和缓冲区开始的指针fence",{"2":{"124":1}}],["和手写扫描器的区别",{"2":{"124":1}}],["和mlir多层级中间表达",{"2":{"114":1}}],["和确定性有限自动机",{"2":{"112":1}}],["和克里斯",{"2":{"110":1}}],["和当前点能到达的最远点的最大值",{"2":{"107":1}}],["和一个目标数",{"2":{"78":1}}],["和一台机器16内存跑起来哪个快",{"2":{"46":1}}],["和上文同一个作者",{"2":{"75":1}}],["和面试官聊了好久rdma的分离式内存",{"2":{"46":1}}],["和寻问到岗时间",{"2":{"41":1}}],["和部门业务的介绍",{"2":{"41":1}}],["和标准库性能差多少",{"2":{"37":1}}],["和调用",{"2":{"23":1,"180":1}}],["和更多的gpu编程知识",{"2":{"11":1}}],["和",{"2":{"4":1,"7":1,"19":2,"67":3,"75":2,"76":1,"78":1,"84":2,"87":1,"90":3,"93":1,"99":2,"101":2,"102":1,"104":1,"110":1,"149":2,"150":2,"155":2,"157":1,"163":1,"166":2,"169":1,"173":1,"180":1,"187":1,"188":2,"190":2,"193":1,"194":3,"204":1,"206":1,"209":1,"215":1,"236":1}}],["对基于堆的实体的引用涉及通过具有常规生命期的变量进行一级间接寻址",{"2":{"240":1}}],["对其与补充",{"0":{"239":1}}],["对指向n1的指针进行自增操作或将指针转换为",{"2":{"221":1}}],["对字符串有意义的操作",{"2":{"209":1}}],["对象布局的主要复杂性来源于超类方法应当能够在子类对象上工作这一事实",{"2":{"236":1}}],["对象和类",{"0":{"226":1}}],["对象或结构布局",{"2":{"204":1}}],["对象或过程",{"2":{"172":1,"201":1}}],["对象",{"2":{"191":1}}],["对象记录的内存布局",{"0":{"236":1}}],["对象记录",{"2":{"187":1}}],["对自底向上信息流的限制可能看起来有问题",{"2":{"178":1}}],["对非终结符进行排序",{"2":{"167":1}}],["对另一个含糊值y的赋值可能会改变x的值",{"2":{"157":1}}],["对各种fa最小化技术运行时间的研究表明",{"2":{"141":1}}],["对cfg施加的限制条件",{"2":{"130":1}}],["对每一列非错误状态的数量技术的先进行分组",{"2":{"124":1}}],["对图",{"2":{"123":1}}],["对这个dfa应用反转操作产生了图",{"2":{"123":1}}],["对这种情况有一些",{"2":{"19":1}}],["对状态重新计数",{"2":{"115":1}}],["对比",{"2":{"75":1}}],["对括号组成的有效括号组合",{"2":{"72":1}}],["对于具有可预测生命期的对象",{"2":{"240":1}}],["对于空终止字符串",{"2":{"231":1}}],["对于基本类型",{"2":{"230":1}}],["对于开放的类结构",{"2":{"201":1}}],["对于没有赋值或函数调用的表达式",{"2":{"198":1}}],["对于表达式",{"2":{"194":1}}],["对于虚方法",{"2":{"187":1}}],["对于静态分配的变量",{"2":{"187":1}}],["对于静态绑定的名称",{"2":{"172":1}}],["对于那些生命周期与过程调用相匹配的值",{"2":{"187":1}}],["对于产生式",{"2":{"184":1}}],["对于factorial",{"2":{"183":1}}],["对于first",{"2":{"179":1}}],["对于包含",{"2":{"179":1}}],["对于i中的每个项",{"2":{"179":1}}],["对于给定项集i和符号x",{"2":{"179":1}}],["对于给定的nfa状态集合",{"2":{"113":1}}],["对于给定的输入字符",{"2":{"112":1}}],["对于b的每个产生式b",{"2":{"179":1}}],["对于在源程序中声明的变量",{"2":{"175":1}}],["对于动态绑定的名称",{"2":{"172":1}}],["对于句子",{"2":{"164":1}}],["对于其他一元运算符",{"2":{"162":1}}],["对于寄存器用量较少的函数则完全避免了内存读写",{"2":{"155":1}}],["对于存在",{"2":{"155":1}}],["对于多个左递归产生式的情况",{"2":{"150":1}}],["对于单个左递归产生式",{"2":{"150":1}}],["对于小规模的键集",{"2":{"139":1}}],["对于一个含糊的值x",{"2":{"157":1}}],["对于一个明确的值x",{"2":{"157":1}}],["对于一个小的过程",{"2":{"139":1}}],["对于一个fa来说",{"2":{"102":1}}],["对于函数",{"2":{"139":1}}],["对于简单的标量变量",{"2":{"139":1}}],["对于程序中实际使用的每个名称",{"2":{"139":1}}],["对于程序来说dfa的执行相对于nfa来说更容易模拟",{"2":{"113":1}}],["对于这些编译器的作者来说",{"2":{"136":1}}],["对于推导中的每一个产生式",{"2":{"129":1}}],["对于该算法",{"2":{"123":1}}],["对于前一节提到了正则表达式式的三个操作来说",{"2":{"118":1}}],["对于",{"2":{"115":1,"206":1}}],["对于子集构造而言",{"2":{"113":1}}],["对于初始状态",{"2":{"113":1}}],["对于nfa状态子集s",{"2":{"113":1}}],["对于上面的示例图",{"2":{"112":1}}],["对于两个正则表达式的集合",{"2":{"105":2}}],["对于出现的大多数编程语言中出现的标点符号",{"2":{"105":1}}],["对于每个产生式",{"2":{"188":1}}],["对于每个非终结符a和每个输入符号a",{"2":{"188":1}}],["对于每个非终结符a",{"2":{"179":1}}],["对于每个项集ii",{"2":{"179":2}}],["对于每个项",{"2":{"179":3}}],["对于每个逻辑数据区",{"2":{"177":1}}],["对于每个aia",{"2":{"167":1}}],["对于每个表",{"2":{"139":1}}],["对于每个字母",{"2":{"102":1}}],["对于每个样本",{"2":{"57":1}}],["对于本题",{"2":{"93":1}}],["对于当前元素判断",{"2":{"76":1}}],["对于当前第i个硬币",{"2":{"58":1}}],["对于矩阵的乘法",{"2":{"4":1}}],["对角线和",{"2":{"43":1}}],["对",{"2":{"23":1,"155":1,"187":1,"188":1}}],["对应一个基本块",{"2":{"206":1}}],["对应一个bank",{"2":{"29":1}}],["对应表达式",{"2":{"186":1}}],["对应的key是排序后的字符串",{"2":{"65":1}}],["对应python代码其14行的内容",{"2":{"50":1}}],["对应python代码中第10行的内容",{"2":{"50":1}}],["对应",{"2":{"4":1,"29":1}}],["1节",{"2":{"197":1}}],["1具体化了这一点",{"2":{"197":1}}],["1给factorial",{"2":{"183":1}}],["175",{"2":{"178":1}}],["17打电话约复试",{"2":{"56":1}}],["1a1​到ai−1a",{"2":{"167":1}}],["1k−1",{"2":{"127":1}}],["1的状态",{"2":{"127":2}}],["1∣d∣−1",{"2":{"127":1}}],["1p1​",{"2":{"115":1}}],["1d1​",{"2":{"113":2}}],["1n1​",{"2":{"112":1}}],["1stmt→if",{"2":{"164":1}}],["1s1​",{"2":{"103":1}}],["1slow−1",{"2":{"87":1}}],["1个数",{"2":{"90":1}}],["1个硬币凑成金额c的组合数",{"2":{"68":1}}],["1个硬币凑成金额c所需的最少硬币个数",{"2":{"58":1}}],["1=skip",{"2":{"67":1}}],["1x−1",{"2":{"66":8}}],["18",{"2":{"53":1,"84":2,"90":2}}],["1i−1",{"2":{"50":2}}],["1−p",{"2":{"41":2}}],["1−p1",{"2":{"41":1}}],["1号都没有约2面",{"2":{"39":1}}],["15展示了这个更大的图景",{"2":{"216":1}}],["15",{"2":{"33":1,"43":2,"75":1,"84":2,"183":1}}],["14晚面完之后",{"2":{"56":1}}],["14号晚上",{"2":{"56":1}}],["14",{"2":{"33":1,"43":2,"183":1,"220":1}}],["13打电话介绍业务并约面",{"2":{"56":1}}],["13",{"2":{"33":1,"43":2,"183":1}}],["19面完之后",{"2":{"56":1}}],["19号",{"2":{"56":1}}],["19",{"2":{"49":1}}],["192",{"2":{"33":1}}],["19th",{"2":{"21":1}}],["112个码点",{"2":{"47":1}}],["114",{"2":{"47":1}}],["11",{"2":{"33":1,"37":1,"43":2,"58":2,"101":1,"183":1}}],["11∗1∗1",{"2":{"4":1}}],["162​",{"2":{"127":1}}],["162r",{"2":{"127":1}}],["16",{"2":{"33":1,"43":2,"103":2,"127":1}}],["168",{"2":{"33":1}}],["16b",{"2":{"19":1}}],["16个宽",{"2":{"19":1}}],["120",{"2":{"183":1}}],["12345​stmtwithelse​→∣∣→∣​if",{"2":{"164":1}}],["12n−1−1",{"2":{"21":1}}],["127",{"2":{"16":6}}],["128b",{"2":{"29":1}}],["128",{"2":{"16":8,"29":8}}],["12",{"0":{"8":1,"36":1},"2":{"33":2,"43":2,"88":1,"183":1}}],["1∗1∗11",{"2":{"4":1}}],["1",{"0":{"121":1,"122":1,"125":1,"126":1,"137":1,"156":1,"163":1,"188":1,"195":1,"220":1},"1":{"134":1,"137":1,"142":1,"144":1,"150":1,"153":2,"156":1,"161":1,"167":1,"170":2,"174":1,"179":1,"184":1,"188":1,"195":1},"2":{"4":3,"7":1,"11":1,"16":5,"19":3,"21":7,"33":1,"37":1,"39":1,"41":1,"43":22,"46":1,"47":1,"50":27,"53":8,"58":20,"62":20,"63":7,"64":20,"65":1,"66":8,"67":9,"68":11,"69":13,"72":2,"73":2,"74":20,"75":7,"76":8,"78":2,"80":10,"84":12,"87":17,"88":8,"90":14,"93":5,"99":3,"100":3,"101":6,"102":3,"103":17,"104":6,"106":10,"107":8,"113":1,"114":2,"115":5,"119":1,"121":1,"125":1,"127":10,"129":2,"130":9,"137":1,"139":1,"142":7,"144":1,"145":3,"146":2,"150":4,"155":5,"156":1,"159":1,"162":2,"163":1,"164":1,"167":4,"174":1,"180":1,"181":20,"183":8,"184":4,"188":2,"195":4,"201":1,"206":1,"213":3,"214":4,"229":3,"231":1}}],["101",{"2":{"53":2}}],["1010∗10∗10的小立方体",{"2":{"4":1}}],["101010",{"2":{"4":1}}],["10100∗10∗10",{"2":{"4":1}}],["10000^",{"2":{"75":2}}],["100002i",{"2":{"75":4}}],["10000",{"2":{"63":1}}],["1000",{"2":{"63":1}}],["1000w",{"2":{"41":1}}],["1000w的数据分一下",{"2":{"41":1}}],["100",{"2":{"39":1,"66":1,"202":1}}],["100∗10∗10100",{"2":{"4":1}}],["1024的乘法",{"2":{"16":1}}],["1024",{"2":{"16":1}}],["10∗10∗1010",{"2":{"4":1}}],["10",{"2":{"4":6,"33":1,"37":1,"43":2,"53":1,"63":1,"68":2,"73":2,"84":2,"101":1,"160":1,"183":1}}],["个人疑问罢了",{"2":{"158":1}}],["个元素",{"2":{"104":1}}],["个连续的黑块",{"2":{"93":2}}],["个连续黑色块的方法是把第",{"2":{"93":1}}],["个块涂成黑色",{"2":{"93":1}}],["个数了",{"2":{"90":1}}],["个数的组合",{"2":{"76":1}}],["个互不相同元素的子数组",{"2":{"90":1}}],["个互不相同的元素",{"2":{"90":2}}],["个长度为",{"2":{"90":2}}],["个节点",{"2":{"67":1}}],["个线程如何在逻辑上映射到共享内存中矩阵的",{"2":{"29":1}}],["个",{"2":{"4":1,"19":1,"29":3,"75":1}}],["的布局变得复杂",{"2":{"237":1}}],["的私有成员",{"2":{"236":1}}],["的对象记录时",{"2":{"236":1}}],["的方法向量减少了空间需求",{"2":{"236":1}}],["的规则",{"2":{"233":1}}],["的使用引用了其在过程开始时的隐式定义",{"2":{"218":1}}],["的可能控制流转移",{"2":{"206":1}}],["的成本应该引起我们的关注",{"2":{"205":1}}],["的首次定义和最后使用可以在执行过程中覆盖一段短暂的时间",{"2":{"203":1}}],["的首字母缩写",{"2":{"110":1}}],["的生命周期从程序执行期间首次定义",{"2":{"203":1}}],["的生命周期与其声明作用域的生命周期相同",{"2":{"193":1}}],["的程序变量",{"2":{"201":1}}],["的主要复杂性并不是来源于继承层次结构的存在",{"2":{"201":1}}],["的主循环",{"2":{"23":1}}],["的内存占用",{"2":{"198":1}}],["的dag",{"2":{"198":1}}],["的ast中包含两个不同的",{"2":{"198":1}}],["的ast展示在下面",{"2":{"185":1}}],["的偏移量",{"2":{"194":1}}],["的二元节点",{"2":{"194":1}}],["的二进制串",{"2":{"101":1}}],["的二进制串包括",{"2":{"101":2}}],["的参数",{"2":{"193":1}}],["的执行",{"2":{"193":1}}],["的局部数据区内为该作用域预留空间",{"2":{"193":1}}],["的局部数据区中",{"2":{"193":1}}],["的能力",{"2":{"191":1}}],["的代码合并",{"2":{"180":1}}],["的项集",{"2":{"179":1}}],["的一次激活相匹配",{"2":{"175":1}}],["的一个子集",{"2":{"113":1}}],["的类型决定了如何最佳地评估该表达式",{"2":{"173":1}}],["的实体",{"2":{"172":1}}],["的名为",{"2":{"172":1}}],["的出现指的是在离",{"2":{"172":1}}],["的三地址码出现在页边",{"2":{"169":1}}],["的形式",{"2":{"169":1}}],["的解析树",{"2":{"168":1}}],["的直接左递归",{"2":{"167":1}}],["的直接路径",{"2":{"127":1}}],["的四种不同表示方法",{"2":{"166":1}}],["的变量进行解引用",{"2":{"162":1}}],["的语法树",{"2":{"162":1,"178":1}}],["的优先级低",{"2":{"162":1}}],["的优化",{"2":{"155":1}}],["的概念",{"0":{"161":1}}],["的寄存器",{"2":{"155":1}}],["的虚拟寄存器",{"2":{"155":1}}],["的好处是方便优化",{"2":{"155":1}}],["的知识",{"2":{"155":1}}],["的栈机代码出现在边栏中",{"2":{"152":1}}],["的机制",{"2":{"145":1}}],["的机器的架构",{"2":{"114":1}}],["的时间成本也会相应提高",{"2":{"212":1}}],["的时间",{"2":{"139":2}}],["的时候就已经固定",{"2":{"155":1}}],["的时候卖出",{"2":{"50":3,"104":1}}],["的时候买入",{"2":{"50":3,"104":1}}],["的时候",{"2":{"7":1}}],["的路径",{"2":{"127":1}}],["的路径长度",{"2":{"67":1}}],["的状态",{"2":{"127":1,"155":1}}],["的状态的正则表达式",{"2":{"127":1}}],["的所有路径的集合相连接",{"2":{"127":1}}],["的所有路径的集合",{"2":{"127":1}}],["的意思是",{"2":{"127":1}}],["的nfa",{"2":{"118":4}}],["的正则表达式为例",{"2":{"118":1}}],["的目标架构",{"2":{"114":1}}],["的自循环的这条边",{"2":{"112":1}}],["的研究",{"2":{"110":1}}],["的和最大",{"2":{"106":1}}],["的和是",{"2":{"90":1}}],["的克林闭包记作",{"2":{"105":1}}],["的集合字符拼接到",{"2":{"105":1}}],["的函数",{"2":{"102":1}}],["的异位词",{"2":{"99":5}}],["的大小即为不重复元素的个数",{"2":{"90":1}}],["的乘积",{"2":{"88":2}}],["的位置",{"2":{"107":1}}],["的位置上重复了",{"2":{"87":1}}],["的位置时",{"2":{"23":1}}],["的前缀和",{"2":{"106":1}}],["的前五个元素被修改为",{"2":{"80":1}}],["的前两个元素被修改为",{"2":{"80":1}}],["的组合",{"2":{"78":1}}],["的向量",{"2":{"75":1}}],["的隐藏层输出",{"2":{"75":1}}],["的输入由三部分组成",{"2":{"75":1}}],["的字符串",{"2":{"73":1}}],["的硬币不能凑成总金额",{"2":{"68":1}}],["的里程碑模型",{"2":{"67":1}}],["的核心思想是",{"2":{"67":1}}],["的算法解决此问题",{"2":{"66":1}}],["的长度是否为",{"2":{"101":1}}],["的长度进行滑动窗口",{"2":{"101":1}}],["的长度",{"2":{"66":1,"100":2}}],["的尾部元素的价格高于当前天的价格",{"2":{"63":1}}],["的头部元素",{"2":{"63":1}}],["的末尾元素",{"2":{"63":1}}],["的子集",{"2":{"115":2}}],["的子集的集合",{"2":{"113":1}}],["的子串是",{"2":{"99":5}}],["的子串",{"2":{"99":1,"101":2}}],["的子数组含有至少",{"2":{"90":1}}],["的子数组",{"2":{"90":2}}],["的子序列",{"2":{"53":1}}],["的子矩阵",{"2":{"16":2}}],["的矩阵往里面螺旋填数",{"2":{"43":1}}],["的结构",{"2":{"37":1}}],["的调用",{"2":{"29":1,"183":1}}],["的读和写一定有一个会",{"2":{"29":1}}],["的情况同理",{"2":{"19":1}}],["的数量和宽度和线程访问的大小相关",{"2":{"19":1}}],["的数据",{"2":{"11":2}}],["的数据不能一次性读到共享内存里",{"2":{"7":1}}],["的关系如下图所示",{"2":{"19":1}}],["的宽度是",{"2":{"19":1}}],["的分析上去",{"2":{"7":1}}],["的题解或者视频",{"2":{"5":1}}],["的",{"2":{"4":2,"7":3,"19":1,"23":1,"29":3,"53":1,"75":1,"93":2,"99":1,"155":1,"236":2}}],["的立方体",{"2":{"4":1}}],["的值为止",{"2":{"203":1}}],["的值在其被使用之间不能发生变化",{"2":{"198":1}}],["的值相对于",{"2":{"194":1}}],["的值",{"2":{"1":1,"62":1}}],["有些作者则将这些边从使用指向定义",{"2":{"218":1}}],["有向边表示执行顺序",{"2":{"206":1}}],["有向无环图",{"0":{"198":1},"2":{"198":1,"206":1}}],["有必要简要回顾一下作用域规则",{"2":{"172":1}}],["有了继承",{"2":{"236":1}}],["有了这样的构造",{"2":{"145":1}}],["有了可用的解析器后",{"2":{"129":1}}],["有许多有效且高效的构建平衡树的技术",{"2":{"139":1}}],["有时候",{"2":{"204":1}}],["有时",{"2":{"129":1,"169":1}}],["有点类似于ping",{"2":{"124":1}}],["有限闭包代表",{"2":{"105":1}}],["有限自动机f所接受的单词集合形成了一种语言",{"2":{"105":1}}],["有限自动机",{"0":{"102":1}}],["有四种方式可以凑成总金额",{"2":{"68":1}}],["有四个线程加载连续的通道",{"2":{"29":1}}],["有导师带",{"2":{"46":1}}],["有印象",{"2":{"39":1}}],["有印象的就是sgd和adam",{"2":{"37":1}}],["有哪些方法",{"2":{"33":1}}],["有序列表3",{"2":{"21":1}}],["有序列表2",{"2":{"21":1}}],["有序列表1",{"2":{"21":1}}],["有",{"2":{"19":1,"90":1}}],["有一个可以保存单个字符的类型",{"2":{"233":1}}],["有一个书店老板",{"2":{"103":1}}],["有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧",{"2":{"64":1}}],["有一个",{"2":{"4":1}}],["有两个关键数据来决定任务的划分",{"2":{"4":1}}],["即ir容纳编译器所需记录的所有信息的能力",{"2":{"205":1}}],["即x类的对象调用了从x类内部可见的方法的实现",{"2":{"187":1}}],["即x2和y2",{"2":{"155":1}}],["即过程的第一个语句之前执行",{"2":{"187":1}}],["即与单个过程激活相关联的一块私有内存",{"2":{"187":1}}],["即lalr",{"2":{"181":1}}],["即slr",{"2":{"181":1}}],["即simt",{"2":{"4":1}}],["即其生命周期",{"2":{"175":1}}],["即它在运行时不会改变",{"2":{"172":1}}],["即在对x进行赋值时",{"2":{"157":1}}],["即在相继迭代的空间中达到",{"2":{"113":1}}],["即使没有机制可以读取它们的值",{"2":{"236":1}}],["即使是最简单的类型系统",{"2":{"233":1}}],["即使是小型语法生成的lr",{"2":{"163":1}}],["即使用全局变量在翻译规则之间传递信息",{"2":{"204":1}}],["即使子类不在同一个包内",{"2":{"201":1}}],["即使在已经经过初步优化的表中",{"2":{"163":1}}],["即使我们将项",{"2":{"162":1}}],["即使不是后端",{"2":{"155":1}}],["即使对于简单的表达式",{"2":{"129":1}}],["即右侧包含指示错误同步点的保留字和一个或多个同步令牌的产生式来实现",{"2":{"145":1}}],["即每一层的子树大小大致相等",{"2":{"139":1}}],["即中间表示",{"2":{"131":1}}],["即factor节点层",{"2":{"129":1}}],["即fa进行如下的转换",{"2":{"102":1}}],["即采用双重缓冲",{"2":{"124":1}}],["即构建",{"2":{"114":1}}],["即分布假说",{"2":{"67":1}}],["即为完成徒步旅行的最小花费",{"2":{"63":1}}],["即队列头部元素的价格",{"2":{"63":1}}],["即",{"2":{"63":1,"115":1,"223":1}}],["即当天的最大利润是通过前一天来获得的",{"2":{"50":1}}],["即blockdim和griddim",{"2":{"4":1}}],["goal",{"2":{"195":4}}],["goto表包含66个条目",{"2":{"163":1}}],["goto表",{"2":{"144":1}}],["goto",{"2":{"129":1,"144":1,"195":4,"213":2}}],["google",{"2":{"67":1}}],["github",{"2":{"114":1}}],["git",{"2":{"114":2}}],["git命令",{"2":{"33":1}}],["gammaγ仅根据aaa的产生式推导",{"2":{"131":1}}],["gamma",{"2":{"75":2,"131":1,"184":4}}],["ghi",{"2":{"73":2}}],["graph",{"0":{"198":1},"2":{"206":1}}],["graphical",{"0":{"151":1},"1":{"168":1,"185":1,"198":1,"206":1,"212":1,"218":1,"224":1,"228":1}}],["graph区分",{"2":{"131":1}}],["grammar",{"2":{"130":1,"131":1}}],["gram",{"2":{"67":3}}],["grumpy",{"2":{"103":8}}],["groupanagrams",{"2":{"65":1}}],["group",{"2":{"29":2}}],["g",{"2":{"53":6,"106":3,"114":3,"131":1,"206":1}}],["guard",{"2":{"41":2}}],["geq",{"2":{"131":2}}],["generator>",{"2":{"114":1}}],["generateparenthesis",{"2":{"72":1}}],["gensim",{"2":{"67":2}}],["gets",{"2":{"127":1}}],["getspiralvalue",{"2":{"43":2}}],["getbuffer",{"2":{"41":2}}],["gemm",{"2":{"23":2}}],["gt",{"2":{"19":1,"22":6,"129":1,"162":2,"176":24,"188":7,"215":1,"221":2}}],["gpu",{"2":{"19":2,"114":3}}],["gpu中的内存模型",{"2":{"7":1}}],["gpu的编程模型",{"2":{"4":1}}],["global",{"2":{"4":1,"7":2,"11":1,"16":1,"23":2,"29":2}}],["x4",{"2":{"214":2}}],["xc",{"2":{"210":1}}],["x^2",{"2":{"198":6}}],["xβ",{"2":{"179":1}}],["x和y在某些调用中可能指向相同的存储位置",{"2":{"157":1}}],["xmm",{"2":{"155":1}}],["x→y1y2",{"2":{"153":1}}],["x→εx",{"2":{"153":1}}],["x86",{"2":{"114":2,"155":1}}],["x∈l",{"2":{"105":2}}],["x∣x∈l",{"2":{"105":2}}],["xn",{"2":{"102":1}}],["xn−1​",{"2":{"102":1}}],["xn−1",{"2":{"102":1}}],["xn​",{"2":{"102":2}}],["xnx",{"2":{"102":1}}],["x3​",{"2":{"102":2}}],["x3",{"2":{"102":2,"214":2}}],["x3c",{"2":{"1":3,"4":3,"7":9,"11":17,"16":10,"39":26,"41":7,"43":20,"53":12,"58":6,"63":5,"64":6,"65":7,"66":3,"68":5,"69":9,"72":5,"73":3,"80":2,"84":10,"87":3,"88":7,"90":5,"93":2,"99":6,"100":2,"101":4,"103":5,"104":1,"106":3,"107":3,"114":1,"183":8}}],["x1​",{"2":{"102":1}}],["x1",{"2":{"102":2,"155":3,"214":1}}],["xrightarrow",{"2":{"102":1}}],["xi",{"2":{"67":1}}],["x2​",{"2":{"102":2}}],["x2",{"2":{"102":2,"155":2,"214":2}}],["x27",{"2":{"67":3,"150":19,"153":6,"167":8,"184":5,"188":1}}],["x26",{"2":{"4":2,"7":6,"11":6,"16":6,"41":4,"53":7,"58":3,"63":2,"64":3,"65":2,"66":1,"68":3,"69":2,"72":1,"73":1,"80":1,"84":1,"87":1,"88":1,"90":1,"93":3,"103":2,"104":1,"106":2,"107":1}}],["x−1x",{"2":{"66":8}}],["x−1x−1x−1",{"2":{"66":2}}],["xxx",{"2":{"66":7,"153":3}}],["x+1",{"2":{"66":3}}],["x+2",{"2":{"66":4}}],["x++",{"2":{"43":2}}],["x+threadid",{"2":{"16":2}}],["xor",{"2":{"29":2}}],["x×tm",{"2":{"11":1}}],["x",{"2":{"4":3,"7":10,"11":6,"16":12,"23":1,"43":17,"53":4,"66":2,"67":6,"75":4,"102":8,"105":3,"106":2,"115":2,"153":16,"155":7,"162":8,"164":5,"168":2,"173":3,"183":2,"185":3,"202":1,"213":4,"214":4}}],["+te",{"2":{"153":1}}],["+nt",{"2":{"131":1}}],["+rijk−1​",{"2":{"127":1}}],["+rijk−1r",{"2":{"127":1}}],["+r",{"2":{"127":1}}],["+i",{"2":{"107":1}}],["+indexk",{"2":{"11":1}}],["+indexb",{"2":{"11":2}}],["+1",{"2":{"58":4}}],["+prices",{"2":{"50":2,"62":2,"74":2}}],["++",{"2":{"90":2,"99":3,"101":1}}],["++slow",{"2":{"80":1}}],["++n",{"2":{"66":1}}],["++j",{"2":{"43":1,"53":1,"63":1,"69":1}}],["++i",{"2":{"43":1,"53":1,"90":2,"93":2}}],["++k",{"2":{"7":1}}],["+=customers",{"2":{"103":1}}],["+=",{"2":{"7":1,"11":1,"16":1,"63":1,"72":2,"90":2,"93":2,"103":2,"106":1}}],["+",{"2":{"4":2,"7":4,"11":11,"16":34,"21":2,"43":11,"50":3,"53":2,"58":4,"62":1,"67":4,"68":2,"74":1,"75":5,"78":2,"90":1,"101":1,"103":5,"129":2,"131":1,"134":1,"146":1,"153":1,"155":1,"160":1,"168":1,"170":3,"174":10,"176":4,"183":1,"185":1,"198":2,"213":1,"214":2}}],["y和z位于与point实例相同的偏移位置",{"2":{"187":1}}],["yiyiyi",{"2":{"153":1}}],["yiyiyi不包含",{"2":{"153":1}}],["y2",{"2":{"153":3}}],["y1",{"2":{"153":6,"214":1}}],["y1y2",{"2":{"153":1}}],["yk",{"2":{"153":1}}],["ykx→y1y2",{"2":{"153":1}}],["ykx",{"2":{"153":1}}],["y++",{"2":{"43":2}}],["y^​c​=softmax",{"2":{"67":1}}],["y^​=softmax",{"2":{"67":1}}],["y^c=softmax",{"2":{"67":1}}],["y^=softmax",{"2":{"67":1}}],["y^",{"2":{"21":2}}],["yωω",{"2":{"21":2}}],["y∗blockdim",{"2":{"16":2}}],["y×tn",{"2":{"11":1}}],["y",{"2":{"4":3,"7":10,"11":6,"16":8,"21":2,"43":18,"67":2,"115":2,"155":4,"213":4,"214":1}}],["=∅",{"2":{"188":3}}],["=∅first",{"2":{"188":3}}],["=x",{"2":{"153":1}}],["=xfirst",{"2":{"153":1}}],["=∑j=0rightnums",{"2":{"106":1}}],["=∑j=0inums",{"2":{"106":1}}],["=customers",{"2":{"103":1}}],["=cos⁡",{"2":{"75":1}}],["=concat",{"2":{"75":2}}],["=end",{"2":{"88":1}}],["=pre",{"2":{"88":5}}],["=nums",{"2":{"87":1,"88":1}}],["=γσ2+ϵ​x−μ​+β",{"2":{"75":1}}],["=γx−μσ2+ϵ+β",{"2":{"75":1}}],["=σ",{"2":{"75":2}}],["=s",{"2":{"106":3}}],["=sin⁡",{"2":{"75":1}}],["=softmax",{"2":{"75":4}}],["=sum1",{"2":{"4":1}}],["=1",{"2":{"69":1}}],["=1023",{"2":{"16":1}}],["=10230",{"2":{"16":2}}],["=∥a∥∥b∥a⋅b​",{"2":{"67":1}}],["=a⋅b∥a∥∥b∥",{"2":{"67":1}}],["=j=0∑right​nums",{"2":{"106":1}}],["=j=0∑i​nums",{"2":{"106":1}}],["=j=1∏l",{"2":{"67":1}}],["=j−k",{"2":{"63":1}}],["=j−kmins",{"2":{"63":1}}],["=left",{"2":{"67":2}}],["=∏j=1l",{"2":{"67":1}}],["=∞",{"2":{"58":1}}],["=∞dp",{"2":{"58":1}}],["=min",{"2":{"58":2}}],["=max",{"2":{"50":4,"62":4,"74":4,"84":1}}],["=−∞",{"2":{"50":1,"62":2,"74":2}}],["=−∞dfs",{"2":{"50":1,"62":2,"74":2}}],["==0",{"2":{"84":1}}],["==",{"2":{"43":5,"53":2,"58":1,"68":1,"72":1,"90":1,"101":1,"102":3,"134":1,"183":2}}],["=2",{"2":{"19":1,"87":1}}],["=tid=threadidx",{"2":{"16":3}}],["=temp",{"2":{"1":1}}],["=4",{"2":{"16":1}}],["=digits",{"2":{"73":1}}],["=db",{"2":{"7":1}}],["=da",{"2":{"7":1}}],["=0s",{"2":{"106":4}}],["=0dp",{"2":{"58":1}}],["=0dfs",{"2":{"50":1,"62":1,"74":1}}],["=0",{"2":{"7":2,"11":2,"50":1,"58":1,"62":1,"69":1,"74":1,"90":3,"93":1,"100":2,"106":6,"107":1}}],["=32",{"2":{"7":1}}],["=",{"2":{"4":4,"7":6,"11":9,"16":33,"19":1,"21":7,"22":2,"29":1,"39":3,"41":2,"43":31,"50":21,"53":18,"58":16,"62":5,"63":13,"64":5,"65":4,"66":2,"67":12,"68":12,"69":4,"72":5,"73":6,"74":5,"75":14,"76":4,"78":8,"80":7,"84":3,"87":10,"88":2,"90":16,"93":7,"99":6,"100":5,"101":8,"102":3,"103":10,"104":6,"106":10,"107":5,"115":2,"119":1,"127":1,"153":8,"155":10,"160":2,"170":7,"179":11,"183":8,"188":5,"195":12,"202":1,"206":2,"213":4,"214":9,"220":2,"225":1,"229":8,"232":2,"233":2}}],["draw",{"2":{"187":4}}],["d1​→d16​",{"2":{"127":1}}],["d1→d16d",{"2":{"127":1}}],["d1d",{"2":{"113":2}}],["done",{"2":{"229":2}}],["double",{"2":{"124":1,"220":1}}],["dots",{"2":{"67":1}}],["dy​∈pt​",{"2":{"115":1}}],["dy∈ptd",{"2":{"115":1}}],["dx∈pt",{"2":{"115":1}}],["djd",{"2":{"127":4}}],["dj∈dad",{"2":{"115":1,"127":1}}],["dj∈pkd",{"2":{"115":1}}],["dj∈ps",{"2":{"115":1}}],["dj​∈da​",{"2":{"115":1}}],["dj​∈pk​",{"2":{"115":1}}],["dj​∈ps​",{"2":{"115":1}}],["dj​→cdy​",{"2":{"115":1}}],["dj→cdyd",{"2":{"115":1}}],["dllvm",{"2":{"114":5}}],["ddd",{"2":{"113":1,"150":1}}],["d0d",{"2":{"113":1,"127":1}}],["d⋅c",{"2":{"75":2}}],["dmodel​",{"2":{"75":2}}],["dmodel",{"2":{"75":2}}],["dkd",{"2":{"75":1,"127":5}}],["dk​​qkt​",{"2":{"75":1}}],["d",{"2":{"67":1,"75":5,"115":10,"123":1,"127":2,"149":1,"166":1,"170":1,"197":2}}],["d∣v∣×d",{"2":{"67":1}}],["directed",{"0":{"198":1}}],["digit中",{"2":{"160":1}}],["digit",{"2":{"160":2}}],["digits",{"2":{"73":5}}],["did",{"2":{"127":4}}],["di∈da",{"2":{"115":1}}],["di​→cdx​",{"2":{"115":1}}],["di​",{"2":{"115":1}}],["di→cdx",{"2":{"115":1}}],["di",{"2":{"115":2}}],["discernibly",{"2":{"98":1}}],["distributional",{"2":{"67":1}}],["dim",{"2":{"11":2,"16":4}}],["dimybm∗bk=bn∗bk=block",{"2":{"16":1}}],["dimybm",{"2":{"16":1}}],["dimy∗tn",{"2":{"11":1}}],["dimy∗tnbm=",{"2":{"11":1}}],["dimy",{"2":{"11":1,"16":1}}],["dimy>",{"2":{"7":1}}],["dimx∗block",{"2":{"16":2}}],["dimx∗tm",{"2":{"11":2}}],["dimx",{"2":{"7":1,"11":1,"16":1}}],["dfa的接受状态集合为",{"2":{"127":1}}],["dfa到re",{"0":{"117":1},"1":{"127":1}}],["dfa没用空边",{"2":{"112":1}}],["dfa",{"2":{"112":1,"195":1}}],["dfa和正则表达式的内容",{"2":{"46":1}}],["dfs=",{"2":{"73":1}}],["dfs",{"2":{"50":20,"53":4,"58":5,"62":21,"68":5,"69":3,"72":4,"73":1,"74":21}}],["dp",{"2":{"39":1,"53":6,"58":11}}],["december",{"2":{"215":1}}],["declaration",{"2":{"204":1}}],["derivation",{"2":{"137":1,"156":1}}],["depth",{"2":{"114":1}}],["deltaδ",{"2":{"102":1}}],["delta",{"2":{"102":7,"113":2}}],["def",{"2":{"73":2}}],["define",{"2":{"7":1,"225":1,"229":2,"232":1}}],["deque",{"2":{"63":1,"64":1}}],["deep",{"2":{"21":3}}],["detail",{"0":{"20":1},"1":{"24":1}}],["demo",{"0":{"13":1},"2":{"21":1,"24":1}}],["dcmake",{"2":{"114":1}}],["dc",{"2":{"4":2,"7":3,"11":2,"16":2}}],["db",{"2":{"4":2,"7":2,"11":2,"16":2}}],["da→aa",{"2":{"184":1}}],["da→aa∣ab∣c∣d",{"2":{"150":1}}],["da→ab∣ac∣d",{"2":{"184":2}}],["dag明确地编码了子表达式之间的冗余性",{"2":{"198":1}}],["dag",{"2":{"168":1,"198":8,"206":2}}],["dags",{"2":{"151":1}}],["dad",{"2":{"127":1}}],["data",{"2":{"63":8,"175":1}}],["da",{"2":{"4":1,"7":2,"11":2,"16":2,"150":1}}],["two",{"2":{"221":1}}],["twitter",{"2":{"21":1}}],["tuesday",{"2":{"215":3}}],["tuv",{"2":{"73":2}}],["t→ft",{"2":{"153":2}}],["t∪nt",{"2":{"131":2}}],["t是终结符的有限集合",{"2":{"131":1}}],["tdx​∈pt​",{"2":{"115":1}}],["txt文件",{"2":{"114":1}}],["type=debug",{"2":{"114":1}}],["typename",{"2":{"41":1}}],["t+1",{"2":{"106":1}}],["t++",{"2":{"7":1,"11":1}}],["transform",{"2":{"183":1}}],["transformers",{"2":{"75":1}}],["transformer",{"2":{"37":1,"67":1,"75":2}}],["tree和bush具有结构等价性但不具备名称等价性",{"2":{"230":1}}],["tree和bush是同一种类型吗",{"2":{"230":1}}],["tree",{"0":{"185":1},"2":{"158":3,"176":2,"230":3}}],["try",{"2":{"102":3}}],["true",{"2":{"101":2,"107":3,"229":2}}],["t​vwi​​",{"2":{"67":1}}],["tvwi",{"2":{"67":1}}],["tag",{"2":{"173":1}}],["targets",{"2":{"114":1}}],["target",{"2":{"78":5}}],["tan",{"2":{"65":2}}],["tables",{"2":{"21":1}}],["t>",{"2":{"41":1}}],["tcp三次握手和四次挥手的区别",{"2":{"41":1}}],["t4是c的运行时地址",{"2":{"197":1}}],["t4",{"2":{"29":2}}],["t31",{"2":{"29":1}}],["t28",{"2":{"29":2}}],["t20",{"2":{"29":2}}],["t25",{"2":{"29":1}}],["t24",{"2":{"29":3}}],["t23",{"2":{"29":1}}],["t9",{"2":{"29":1}}],["t8是a的运行时地址",{"2":{"197":1}}],["t8",{"2":{"29":3}}],["t7",{"2":{"29":2}}],["t12",{"2":{"29":2}}],["t17",{"2":{"29":1}}],["t16",{"2":{"29":3}}],["t15",{"2":{"29":1}}],["t1",{"2":{"29":1}}],["t0是b的运行时地址",{"2":{"197":1}}],["t0",{"2":{"29":4}}],["te",{"2":{"153":1}}],["term和factor的产生式来说是无关紧要的",{"2":{"163":1}}],["term",{"2":{"146":12,"162":2,"176":6}}],["tea",{"2":{"65":2}}],["teg",{"2":{"56":1}}],["teg云架构平台",{"2":{"49":1}}],["test",{"2":{"39":2}}],["tensors=",{"2":{"75":1}}],["tensor",{"2":{"29":2}}],["textnormal",{"2":{"164":2}}],["text",{"2":{"21":4,"67":13,"75":17,"123":6}}],["temp",{"2":{"43":7,"65":4,"69":4,"72":6,"73":3,"103":4}}],["template",{"2":{"7":1,"11":1,"16":1,"41":1}}],["temp+=a",{"2":{"1":1}}],["temp=0",{"2":{"1":1,"103":1}}],["top",{"2":{"179":1,"195":5}}],["tokens",{"2":{"137":1,"156":1}}],["tokenizer",{"2":{"75":2}}],["token",{"2":{"75":5}}],["to",{"0":{"98":1},"2":{"21":4,"114":1,"115":2,"131":2,"137":1,"143":2,"147":12,"150":18,"153":5,"156":1,"164":3,"167":16,"184":7}}],["tolong",{"2":{"21":1}}],["thursday",{"2":{"215":1}}],["through",{"2":{"136":1}}],["threadblock",{"2":{"23":2}}],["threadid",{"2":{"16":1}}],["threadidx",{"2":{"4":2,"7":12,"11":7,"16":6}}],["thread",{"2":{"4":1,"23":1,"39":1,"114":1}}],["thenthenthen",{"2":{"164":1}}],["then",{"2":{"102":3,"163":1,"164":12,"206":1,"217":1,"223":2}}],["the",{"2":{"98":5}}],["this",{"2":{"21":4,"53":1}}],["times",{"2":{"67":1}}],["tid",{"2":{"16":5}}],["tile",{"2":{"7":13,"23":4,"29":2}}],["tn+indexn",{"2":{"11":3}}],["tn",{"2":{"11":8,"16":11}}],["tn>",{"2":{"11":1,"16":1}}],["tnbm=block",{"2":{"11":1}}],["tntm∗tn",{"2":{"11":1}}],["tm=tn=4",{"2":{"16":3}}],["tm+indexm",{"2":{"11":1}}],["tmp",{"2":{"11":3,"16":3}}],["tm",{"2":{"11":9,"16":10}}],["tm∗tntm",{"2":{"11":1}}],["t",{"2":{"7":4,"11":2,"19":2,"41":2,"43":1,"106":5,"115":1,"131":2,"153":5,"164":25,"170":3,"174":9}}],["t=0",{"2":{"7":1,"11":1}}],["sgt",{"2":{"229":2}}],["sg=1",{"2":{"67":1}}],["symbol压入输入符号栈",{"2":{"179":1,"195":1}}],["symbol",{"2":{"179":1,"195":4}}],["syntax",{"0":{"185":1},"2":{"158":2,"176":1}}],["syncthreads",{"2":{"7":3,"11":3,"16":2,"23":3}}],["smalltalk",{"2":{"152":1}}],["smem",{"2":{"16":32,"29":1}}],["slr",{"2":{"142":2,"181":3}}],["slow++",{"2":{"87":1}}],["slow+1",{"2":{"80":1}}],["slow−2slow",{"2":{"87":2}}],["slow−1slow",{"2":{"87":1}}],["slow=2",{"2":{"87":1}}],["slow=2slow",{"2":{"87":1}}],["slow=0",{"2":{"80":1}}],["slow",{"2":{"80":1,"87":2}}],["scanner",{"2":{"163":1}}],["scan",{"2":{"137":1,"156":1}}],["s→bs",{"2":{"150":2}}],["s→sas",{"2":{"150":1}}],["s→abs",{"2":{"147":3}}],["s→",{"2":{"131":2}}],["s是开始符号",{"2":{"131":1}}],["s3​",{"2":{"115":3}}],["s3",{"2":{"115":3}}],["s2​",{"2":{"115":3}}],["s2",{"2":{"115":3,"217":1,"223":1}}],["s1​",{"2":{"115":3}}],["s1",{"2":{"115":3,"217":1,"223":1}}],["s1s",{"2":{"103":1}}],["sr",{"2":{"105":4}}],["ssa示例",{"0":{"214":1}}],["ssa的构建",{"0":{"208":1}}],["ssa的优势",{"0":{"200":1}}],["ssa的特点",{"0":{"189":1}}],["ssa形式天然适合寄存器分配算法",{"2":{"200":1}}],["ssa形式通过引入φ函数",{"2":{"171":1}}],["ssa形式是一种具有基于值的命名系统的中间表示",{"2":{"155":1}}],["ssa编码了控制流和值流",{"2":{"155":1}}],["ssa",{"0":{"155":1,"171":1},"1":{"189":1,"200":1,"208":1,"214":1,"220":1,"225":1,"229":1,"232":1},"2":{"140":1,"155":4,"171":1,"232":1}}],["ssa​⊆s",{"2":{"102":1}}],["ss∈s",{"2":{"102":1}}],["sss",{"2":{"101":1,"102":1,"105":1}}],["s∈ss",{"2":{"102":1}}],["s0s",{"2":{"102":1,"103":1}}],["s0​",{"2":{"102":2,"115":1}}],["s0",{"2":{"102":2,"115":1}}],["sunday",{"2":{"215":1}}],["subscript",{"2":{"180":1}}],["subset",{"2":{"123":7,"127":1}}],["subseteq",{"2":{"102":1}}],["substr",{"2":{"101":1}}],["success",{"2":{"102":1}}],["suf",{"2":{"88":3}}],["sum∀c∈∑",{"2":{"115":1}}],["sumc∈∑",{"2":{"102":1,"115":1}}],["sum∑",{"2":{"102":1,"105":1}}],["sum",{"2":{"7":3,"21":1,"67":4,"102":1,"106":12,"220":1}}],["sum1+=da",{"2":{"4":1}}],["sum1=0",{"2":{"4":1}}],["sqrt",{"2":{"75":2}}],["skip",{"2":{"67":2}}],["ses",{"2":{"102":1}}],["seq",{"2":{"75":1}}],["september",{"2":{"215":2}}],["sep",{"2":{"75":1}}],["segment",{"2":{"75":2}}],["sentence",{"2":{"75":2}}],["sentences=corpus",{"2":{"67":1}}],["settype",{"2":{"204":4}}],["setc的指针",{"2":{"187":1}}],["setsetset",{"2":{"101":1}}],["setunordered",{"2":{"101":2}}],["set",{"2":{"66":2,"100":1,"101":5}}],["second",{"2":{"63":2,"65":2}}],["sed控制输出",{"2":{"33":1}}],["something",{"2":{"102":3}}],["softmax",{"2":{"67":5,"75":2}}],["sort",{"2":{"65":1,"84":1}}],["solution",{"2":{"53":3,"58":1,"63":1,"64":1,"65":1,"66":1,"68":1,"69":1,"72":1,"73":1,"80":1,"84":1,"87":1,"88":1,"90":1,"93":1,"99":1,"100":1,"101":1,"103":1,"104":1,"106":2,"107":1}}],["soundbank",{"2":{"29":1}}],["shifts",{"2":{"195":1}}],["shift",{"2":{"129":1,"142":1}}],["shareptr",{"2":{"41":8}}],["shared引用计数",{"2":{"33":1}}],["shared",{"2":{"7":2,"11":2,"16":2,"19":2,"23":5,"29":5}}],["short",{"2":{"33":1}}],["stlookup",{"2":{"194":1}}],["stmt2",{"2":{"206":1}}],["stmt2∣if",{"2":{"164":1}}],["stmt1",{"2":{"206":1}}],["stmtotherif",{"2":{"164":1}}],["stmtother​",{"2":{"164":1}}],["stmt3∣other4withelse→if",{"2":{"164":1}}],["stmtif",{"2":{"164":1}}],["stmti",{"2":{"164":1}}],["stmt​→∣∣​i",{"2":{"164":1}}],["stmt∣other",{"2":{"164":1}}],["stmt∣i",{"2":{"164":1}}],["stmt→i",{"2":{"164":1}}],["stmt",{"2":{"145":2,"164":2}}],["stack",{"2":{"143":1,"179":1,"187":1,"195":5}}],["stackrel",{"2":{"115":2}}],["starti",{"2":{"84":1}}],["startvalue",{"2":{"43":5}}],["state",{"2":{"75":1,"179":1,"195":5}}],["static",{"0":{"155":1,"171":1},"1":{"189":1,"200":1,"208":1,"214":1,"220":1,"225":1,"229":1,"232":1},"2":{"39":2,"84":1,"139":1,"155":1,"175":1,"177":1,"187":1,"203":1}}],["std",{"2":{"39":10,"41":8,"63":4,"183":3}}],["strs",{"2":{"65":5}}],["string",{"2":{"41":2,"65":2,"72":1,"73":4,"93":1,"99":2,"100":1,"101":1}}],["string>>",{"2":{"65":3}}],["string>",{"2":{"41":1,"65":1,"72":2,"73":2,"101":1}}],["strip",{"2":{"29":2}}],["stripes",{"2":{"21":1}}],["struct",{"2":{"33":1,"221":4,"230":6}}],["store",{"2":{"29":2,"155":2,"166":1,"229":2,"232":1}}],["si​",{"2":{"102":1}}],["si​c​δ",{"2":{"102":1}}],["si",{"2":{"102":1}}],["si→cδ",{"2":{"102":1}}],["sin",{"2":{"75":1}}],["single",{"0":{"155":1,"171":1},"1":{"189":1,"200":1,"208":1,"214":1,"220":1,"225":1,"229":1,"232":1},"2":{"4":1,"140":1,"155":1}}],["sigmoid",{"2":{"75":1}}],["sigmaμ",{"2":{"75":1}}],["sigma^2",{"2":{"75":1}}],["sigmaσ",{"2":{"75":1}}],["sigma",{"2":{"67":5,"75":1}}],["simple",{"2":{"142":1}}],["sim",{"2":{"67":6}}],["simd指令",{"2":{"37":1}}],["size=100",{"2":{"67":1}}],["size",{"2":{"23":1,"41":1,"53":3,"58":1,"64":1,"68":1,"69":1,"73":1,"80":1,"84":2,"87":3,"88":1,"90":2,"93":1,"100":1,"101":2,"103":1,"107":1}}],["sb形状为",{"2":{"16":1}}],["sb∈r8∗128",{"2":{"16":1}}],["sb∈r8∗128sa",{"2":{"16":1}}],["sb",{"2":{"7":4,"11":4,"16":5}}],["saturday",{"2":{"215":1}}],["saves",{"2":{"187":2}}],["saaa→saaa",{"2":{"150":1}}],["saa→saa",{"2":{"150":1}}],["sa|bs→sa∣b",{"2":{"150":1}}],["sa⊆ss",{"2":{"102":1}}],["sas→sa",{"2":{"150":1}}],["sas",{"2":{"102":1}}],["sa​",{"2":{"102":1}}],["sampling",{"2":{"67":1}}],["sa形状为",{"2":{"16":1}}],["sa∈r128∗8",{"2":{"16":2}}],["sa",{"2":{"7":4,"11":4,"16":4,"102":1}}],["s++",{"2":{"1":1,"4":1,"43":1}}],["s",{"0":{"115":1},"2":{"1":2,"4":2,"43":8,"46":1,"65":3,"90":5,"99":16,"100":8,"101":9,"102":9,"105":5,"106":16,"113":6,"114":2,"115":12,"118":5,"127":3,"131":4,"145":2,"150":2,"164":14,"170":3,"174":1,"179":2,"195":1,"203":4}}],["s=0",{"2":{"1":1,"4":1}}],["fmul",{"2":{"220":1}}],["february",{"2":{"215":1}}],["fee",{"2":{"209":1,"233":3}}],["fnamelist",{"2":{"204":2}}],["f→",{"2":{"153":1}}],["ft",{"2":{"153":2}}],["f的状态转换图详细的规定了如何拼写除该语言中的每一个单词",{"2":{"105":1}}],["f",{"2":{"105":1,"106":3,"153":2,"164":9,"170":1,"190":1}}],["factorial",{"2":{"183":11,"229":1}}],["factor的产生式右侧都只有一个符号",{"2":{"146":1}}],["factor",{"2":{"146":3,"162":1,"163":3}}],["fa",{"2":{"141":1}}],["false",{"2":{"101":1,"107":4,"229":2}}],["fast=2",{"2":{"87":2}}],["fast=1",{"2":{"80":2}}],["fastfastfast",{"2":{"87":2}}],["fast++",{"2":{"80":1,"87":1}}],["fast",{"2":{"80":3,"87":3}}],["fs",{"2":{"73":1}}],["fie",{"2":{"209":1}}],["final",{"2":{"107":5,"229":2}}],["finite",{"2":{"102":1}}],["findanagrams",{"2":{"99":1}}],["firstfirstfirst",{"2":{"188":1}}],["firstfirstfirst集合",{"0":{"153":1}}],["first",{"2":{"63":1,"153":27,"170":3,"188":9}}],["filters",{"2":{"29":1}}],["file",{"2":{"23":4,"29":1}}],["flow",{"2":{"131":1,"206":1}}],["float4",{"2":{"16":4}}],["float",{"2":{"1":4,"4":4,"7":9,"11":6,"16":6,"204":4}}],["flag++",{"2":{"43":1}}],["flag",{"2":{"43":3}}],["function",{"2":{"58":1,"68":1,"69":1,"72":1,"73":1,"134":3,"171":1}}],["funcc",{"2":{"39":2}}],["funcb",{"2":{"39":2}}],["funca",{"2":{"39":2}}],["friday",{"2":{"215":1}}],["free",{"2":{"130":1,"131":1}}],["front",{"2":{"63":3,"64":3}}],["from",{"2":{"23":2,"67":1,"75":3}}],["frac",{"2":{"21":4,"67":2,"75":2}}],["followfollowfollow",{"2":{"188":1}}],["followfollowfollow集合",{"0":{"170":1}}],["follow",{"2":{"170":28,"188":6}}],["followepsilon",{"2":{"113":3}}],["foo",{"0":{"17":1},"2":{"13":1,"15":1}}],["formed",{"2":{"191":1}}],["form",{"0":{"155":1},"2":{"140":1}}],["forall",{"2":{"115":1}}],["for",{"2":{"1":3,"4":1,"7":2,"11":10,"16":7,"43":4,"46":1,"53":5,"63":1,"64":1,"65":2,"66":2,"69":1,"73":1,"80":1,"84":1,"87":1,"88":3,"90":2,"93":2,"99":2,"101":1,"103":3,"104":1,"106":2,"107":1,"155":1,"183":1}}],["august",{"2":{"215":1}}],["automatic",{"2":{"175":1,"177":1}}],["automata",{"2":{"102":1}}],["auto",{"2":{"53":3,"58":1,"65":2,"66":2,"68":2,"106":1,"183":1}}],["ax^2b",{"2":{"198":1}}],["axa^xax",{"2":{"173":2}}],["aα",{"2":{"188":1}}],["april",{"2":{"215":1}}],["apoint的or很简单",{"2":{"187":1}}],["apoint和acolorpoint都有它们自己的or",{"2":{"187":1}}],["approx",{"2":{"67":1}}],["acyclic",{"0":{"198":1}}],["acolorpoint的对象记录中包含的代码指针指向的是colorpoint而非point提供的方法向量",{"2":{"187":1}}],["acolorpoint的or同样简单",{"2":{"187":1}}],["ac",{"2":{"184":2}}],["activation",{"2":{"193":1}}],["activations",{"2":{"29":1}}],["action和goto表被代码所取代",{"2":{"163":1}}],["action表包含132个条目",{"2":{"163":1}}],["action表",{"2":{"144":1}}],["action",{"2":{"129":1}}],["aβ",{"2":{"179":1}}],["ai−1​",{"2":{"167":1}}],["ai引擎",{"0":{"31":1}}],["and",{"0":{"239":1}}],["an​",{"2":{"167":1}}],["ana",{"2":{"167":1}}],["ans+increase",{"2":{"103":1}}],["ans=0",{"2":{"103":1}}],["answer",{"2":{"88":9}}],["ans",{"2":{"53":4,"103":1,"106":4}}],["a2​",{"2":{"167":1}}],["a2",{"2":{"167":1}}],["a1",{"2":{"167":1}}],["a^",{"2":{"150":2}}],["a→αa→αa→α",{"2":{"188":1}}],["a→αa",{"2":{"184":1,"188":3}}],["a→αβ1∣αβ2∣",{"2":{"184":1}}],["a→αba",{"2":{"170":1}}],["a→αbβa",{"2":{"170":1}}],["a→ba∣aa",{"2":{"167":3}}],["a→baa",{"2":{"167":1}}],["a→ca",{"2":{"150":2}}],["a→β1​a",{"2":{"150":1}}],["a→β1a",{"2":{"150":1}}],["a→βa→βa→β",{"2":{"188":1}}],["a→βa",{"2":{"150":2}}],["a→ab∣ac∣da",{"2":{"184":2}}],["a→aba",{"2":{"150":1}}],["a→aα1​∣aα2​∣",{"2":{"150":1}}],["a→aα1∣aα2∣",{"2":{"150":1}}],["a→aα∣β",{"2":{"150":1}}],["a→aα∣βa",{"2":{"150":1}}],["a→aaa",{"2":{"150":1}}],["a→aa∣ab∣c∣da",{"2":{"150":1}}],["a→aa",{"2":{"147":1,"184":1}}],["aab",{"2":{"167":4}}],["aab→baa∣aa",{"2":{"167":1}}],["aa→ba∣a",{"2":{"167":3}}],["aa→a",{"2":{"147":1}}],["aa",{"2":{"150":2,"167":1,"184":1,"188":2}}],["aaa出现在前两个产生式中",{"2":{"184":1}}],["aaa→aa",{"2":{"150":1}}],["aaa",{"2":{"4":1,"7":3,"112":2,"167":1,"188":3}}],["a|b",{"2":{"119":1}}],["a∣b∗",{"2":{"119":2}}],["alignment",{"0":{"239":1}}],["aligned",{"2":{"21":1}}],["all",{"2":{"187":1}}],["allocation",{"2":{"187":3}}],["alloca",{"2":{"155":5,"229":1,"232":1}}],["alphaα后",{"2":{"184":1}}],["alphaaj​→β1​α∣β2​α∣",{"2":{"167":1}}],["alphaaj​→ai​α替换为aj→β1α∣β2α∣",{"2":{"167":1}}],["alpha|",{"2":{"150":1}}],["alpha",{"2":{"131":3,"150":7,"167":2,"184":4}}],["algorithm>",{"2":{"183":1}}],["algorithm",{"0":{"115":1,"123":1},"2":{"115":1,"123":1}}],["amp",{"2":{"164":21,"204":1}}],["amd",{"2":{"114":2}}],["amdgpu",{"2":{"114":1}}],["amount",{"2":{"58":7,"68":8}}],["abb→ab替换为b→baa∣aab",{"2":{"167":1}}],["abstract",{"0":{"185":1},"2":{"158":1}}],["aba→ab",{"2":{"150":1}}],["abab",{"2":{"99":1}}],["ab",{"2":{"99":6,"150":1,"167":2,"184":2}}],["abcabcbb",{"2":{"100":1}}],["abc",{"2":{"73":2,"99":3,"100":1}}],["as",{"2":{"150":1}}],["assignment",{"0":{"155":1,"171":1},"1":{"189":1,"200":1,"208":1,"214":1,"220":1,"225":1,"229":1,"232":1},"2":{"140":1,"155":1}}],["asts",{"2":{"151":1,"197":1}}],["ast",{"0":{"185":1,"217":1},"2":{"131":1,"158":1,"166":1,"168":1,"176":1,"185":1,"192":1,"194":2,"198":1,"206":4,"228":1}}],["asa​",{"2":{"102":1}}],["ascii",{"2":{"93":3}}],["aside",{"2":{"21":1}}],["attention",{"2":{"75":5}}],["ate",{"2":{"65":2}}],["af",{"2":{"73":1}}],["afterorder",{"2":{"65":3}}],["ae",{"2":{"73":1}}],["add",{"2":{"220":1,"225":2,"229":1}}],["addbase是一个闭包",{"2":{"183":1}}],["addbase",{"2":{"183":2}}],["address",{"2":{"19":1}}],["adj​∈da​",{"2":{"127":1}}],["ada​",{"2":{"127":1}}],["adi​∈da​",{"2":{"115":1}}],["adve",{"2":{"110":1}}],["ad",{"2":{"73":1}}],["a=",{"2":{"39":2,"188":2}}],["a=tid",{"2":{"16":6}}],["arp",{"2":{"194":1,"218":2}}],["arp协议",{"2":{"33":1}}],["ars",{"2":{"187":1}}],["ar需要有足够的容量来存储一套完整的调用方保存和被调方保存的寄存器",{"2":{"187":1}}],["ar",{"2":{"187":4,"193":2}}],["array",{"2":{"164":4}}],["are",{"2":{"21":2}}],["a矩阵是",{"2":{"29":1}}],["a矩阵从",{"2":{"29":1}}],["a",{"2":{"1":1,"4":1,"16":19,"21":2,"23":2,"33":1,"39":3,"65":2,"67":5,"73":1,"84":1,"97":1,"99":4,"102":3,"115":3,"118":5,"119":1,"129":3,"131":1,"141":1,"143":1,"147":9,"149":1,"150":20,"152":1,"155":1,"157":1,"163":1,"166":2,"167":4,"168":1,"169":1,"170":9,"173":1,"178":1,"179":15,"184":5,"185":2,"186":2,"187":1,"188":24,"193":4,"194":8,"195":2,"197":1,"198":7,"202":1,"204":1,"209":1,"218":1,"225":2,"229":3,"233":2,"239":1}}],["a∈rm∗k",{"2":{"1":2}}],["july",{"2":{"215":2}}],["june",{"2":{"215":2}}],["january",{"2":{"215":1}}],["ji=j",{"2":{"127":1}}],["jdj​",{"2":{"127":3}}],["jdj​的路径上而不经过编号高于dkd",{"2":{"127":1}}],["jkl",{"2":{"73":2}}],["j是右括号数量",{"2":{"72":1}}],["j=left∑right​nums",{"2":{"106":1}}],["j=l",{"2":{"106":1}}],["j=1",{"2":{"67":1}}],["j=0",{"2":{"1":1,"69":1,"106":3}}],["j+1",{"2":{"67":3,"72":1}}],["j++",{"2":{"1":1,"43":1,"53":1}}],["j−1",{"2":{"62":2,"74":2}}],["j−coins",{"2":{"58":2}}],["jjj",{"2":{"4":1,"7":1,"62":4,"67":1,"74":1}}],["jjj列",{"2":{"1":1}}],["j",{"2":{"1":4,"4":3,"7":3,"43":13,"53":10,"58":12,"62":22,"63":8,"67":9,"69":5,"72":3,"74":22,"106":12,"114":1,"115":4,"127":4,"157":1,"167":2,"169":2,"179":4,"180":1,"195":1}}],["icmp",{"2":{"229":2}}],["i4",{"2":{"195":1}}],["i32",{"2":{"220":1,"225":5,"229":22,"232":7}}],["i3",{"2":{"195":1}}],["i2",{"2":{"195":1}}],["i1",{"2":{"195":1,"229":2}}],["i0",{"2":{"195":5}}],["ill",{"2":{"191":1}}],["iloc",{"2":{"169":1,"194":1}}],["i和ada",{"2":{"180":1}}],["ii",{"2":{"179":2}}],["iii而不是",{"2":{"78":1}}],["iii",{"2":{"4":1,"7":2,"50":5,"75":2,"78":1,"88":2,"105":2}}],["iii行乘以b的",{"2":{"1":1}}],["iai​的直接左递归",{"2":{"167":1}}],["iai​的所有产生式",{"2":{"167":1}}],["iai​",{"2":{"167":1}}],["ij",{"2":{"127":6,"179":2}}],["ipi​",{"2":{"115":1}}],["iostream>",{"2":{"183":1}}],["ios",{"2":{"110":1}}],["improve",{"2":{"98":1}}],["import",{"2":{"67":1,"75":1}}],["i>=0",{"2":{"88":1}}],["i>n",{"2":{"73":1}}],["i^v",{"2":{"75":1}}],["i^k",{"2":{"75":1}}],["i^q",{"2":{"75":1}}],["ihi​",{"2":{"75":1}}],["i是左括号数量",{"2":{"72":1}}],["i代表正常处理的第几位",{"2":{"69":1}}],["ixi​",{"2":{"67":1}}],["it",{"2":{"53":3}}],["i−1​",{"2":{"75":1}}],["i−1",{"2":{"50":8,"58":2,"62":8,"74":8,"75":1,"88":3}}],["i−1i",{"2":{"50":2}}],["i天的价格",{"2":{"50":1}}],["isa",{"2":{"143":3,"152":1}}],["isnumber",{"2":{"134":1}}],["isnext",{"2":{"75":3}}],["is",{"2":{"21":6}}],["i+j",{"2":{"72":1}}],["i+j等于一个定值",{"2":{"43":1}}],["i+1i+1i+1",{"2":{"78":2}}],["i+1",{"2":{"21":1,"69":1,"72":1,"73":1,"75":1,"76":1,"88":5,"106":3}}],["i++",{"2":{"1":1,"43":1,"53":1,"64":1,"84":1,"88":2,"99":2,"103":3,"107":1}}],["ir版本",{"2":{"182":1}}],["ir使用模式",{"0":{"182":1}}],["irregular",{"2":{"175":1,"177":1}}],["ir通过表和集等结构来记录附加信息",{"2":{"165":1}}],["ir作为代码的主要表示形式",{"2":{"165":1}}],["ir生成以及比语法层次更深的错误检查",{"2":{"159":1}}],["ir是由执行gimple到llvm翻译的传递产生的",{"2":{"154":1}}],["irs",{"0":{"151":1},"1":{"168":1,"185":1,"198":1,"206":1,"212":1,"218":1,"224":1,"228":1},"2":{"151":1}}],["ir可以分为三类",{"2":{"149":1}}],["ir的抽象级别",{"0":{"166":1}}],["ir的结构组织",{"0":{"149":1}}],["ir的特性对编译器能对代码做什么和不能做什么有直接影响",{"2":{"132":1}}],["ir示例",{"0":{"138":1},"1":{"154":1,"171":1,"189":1,"200":1,"208":1,"214":1,"220":1,"225":1,"229":1,"232":1}}],["ir分类",{"0":{"133":1},"1":{"149":1,"166":1,"182":1,"197":1,"205":1}}],["ir必须能够表示所推导出的信息",{"2":{"132":1}}],["ir",{"0":{"154":1},"2":{"21":1,"132":2,"136":1,"139":1,"140":2,"143":4,"152":1,"154":1,"155":11,"159":2,"166":1,"168":1,"169":3,"198":4,"205":1,"206":5,"218":1,"224":1,"232":1,"233":2,"238":1}}],["ir⋯",{"2":{"21":2}}],["i=ji",{"2":{"127":1}}],["i=minutes",{"2":{"103":1}}],["i=n",{"2":{"88":1,"99":1}}],["i==n",{"2":{"69":1,"73":1}}],["i=1",{"2":{"21":1,"67":3,"84":1,"88":1}}],["i=0",{"2":{"1":1,"64":1,"88":1,"93":1,"99":1,"103":2,"105":1}}],["idf→",{"2":{"153":1}}],["idi​",{"2":{"127":4}}],["id++",{"2":{"16":1}}],["id",{"2":{"16":6,"29":2,"41":3,"153":3,"174":13}}],["ifexprithenifexpr2thenother1elseother2if",{"2":{"164":1}}],["if判断会影响程序的性能",{"2":{"93":1}}],["if",{"2":{"4":1,"7":3,"11":3,"16":3,"43":6,"53":5,"58":4,"64":2,"66":1,"68":4,"69":2,"72":3,"73":3,"80":1,"84":2,"87":2,"90":3,"99":3,"102":3,"106":2,"107":2,"134":2,"155":1,"164":1,"183":1,"206":1,"213":1,"214":2,"229":5}}],["i",{"2":{"1":6,"4":3,"7":6,"41":2,"43":14,"50":26,"53":15,"58":24,"62":16,"63":2,"64":5,"67":11,"68":8,"69":1,"72":4,"73":3,"74":16,"75":4,"84":5,"88":36,"90":9,"93":7,"99":7,"101":4,"102":2,"103":14,"104":3,"105":1,"106":4,"107":4,"115":4,"127":3,"157":1,"164":9,"167":3,"169":2,"179":4,"180":1,"229":6}}],["inamelist",{"2":{"204":2}}],["include",{"2":{"183":3}}],["increase",{"2":{"103":1}}],["increase=max",{"2":{"103":1}}],["increase=temp",{"2":{"103":1}}],["increase=0",{"2":{"103":1}}],["inputs",{"2":{"75":2}}],["input",{"2":{"75":1,"98":2,"137":1,"156":1,"179":1,"195":4}}],["input=token",{"2":{"75":2}}],["insert",{"2":{"66":1,"100":1,"101":1}}],["instruction",{"2":{"4":1}}],["infty",{"2":{"105":1}}],["infty∞个硬币",{"2":{"58":1}}],["inftydp",{"2":{"58":1}}],["inftydfs",{"2":{"50":1,"62":2,"74":2}}],["index",{"2":{"16":27,"29":1}}],["indexn=0",{"2":{"11":1}}],["indexn++",{"2":{"11":2}}],["indexn",{"2":{"11":3}}],["indexm++",{"2":{"11":2}}],["indexm",{"2":{"11":5}}],["indexm=0",{"2":{"11":1}}],["indexb++",{"2":{"11":1}}],["indexb",{"2":{"11":3}}],["indexk+t",{"2":{"11":2}}],["indexk++",{"2":{"11":3}}],["indexk",{"2":{"11":9}}],["indexk=0",{"2":{"11":3}}],["indexa++",{"2":{"11":1}}],["indexa",{"2":{"11":4}}],["indexa=0",{"2":{"11":1}}],["intro",{"0":{"98":1}}],["interface",{"2":{"183":1}}],["intervals",{"2":{"84":13}}],["integer",{"2":{"160":2,"178":1}}],["intel",{"2":{"37":1,"114":1}}],["int>b",{"2":{"84":1}}],["int>a",{"2":{"84":1}}],["int>",{"2":{"43":1,"53":6,"58":2,"63":1,"64":4,"66":3,"68":2,"69":3,"80":1,"87":1,"88":5,"90":2,"99":4,"103":2,"104":1,"106":2,"107":1,"183":1}}],["int>>",{"2":{"43":1,"63":1,"69":2,"84":3}}],["int",{"2":{"1":6,"4":6,"7":13,"11":21,"16":34,"29":1,"33":1,"39":3,"41":1,"43":19,"53":16,"58":13,"63":6,"64":2,"66":3,"68":9,"69":4,"72":6,"73":3,"80":3,"84":1,"87":3,"88":5,"90":7,"93":6,"99":4,"100":3,"101":2,"103":9,"104":4,"106":9,"107":3,"183":6,"202":1,"204":4,"221":8,"230":2}}],["in",{"2":{"1":3,"16":6,"67":1,"102":3,"105":2,"113":1,"115":8,"127":1,"134":2}}],["cptwo",{"2":{"236":1}}],["cpone",{"2":{"236":1}}],["cpu",{"2":{"114":1}}],["cmp",{"2":{"229":2}}],["cmake",{"2":{"114":2}}],["c语言使用联合体",{"2":{"221":1}}],["c语言中的声明",{"2":{"202":1}}],["c语言程序员可能需要书写",{"2":{"162":1}}],["c→abc",{"2":{"147":5}}],["c→cc",{"2":{"147":1}}],["cc",{"2":{"163":1}}],["cc→c",{"2":{"147":1}}],["ccc",{"2":{"4":1,"67":1,"75":1,"113":1,"150":1}}],["c和c++使用大括号来划分代码块",{"2":{"139":1}}],["cnt==p",{"2":{"99":2}}],["cnt",{"2":{"99":8}}],["cntw",{"2":{"93":5}}],["cb",{"2":{"167":2}}],["cb→baa∣aa∣c",{"2":{"167":1}}],["cb→bc",{"2":{"147":1}}],["cb→ab∣c",{"2":{"167":2}}],["cba",{"2":{"99":1}}],["cbaebabacd",{"2":{"99":1}}],["cbow",{"2":{"67":1}}],["clang",{"2":{"114":1,"155":1}}],["class",{"2":{"39":1,"41":1,"53":3,"58":1,"64":1,"65":1,"66":1,"68":1,"69":1,"72":1,"73":1,"80":1,"84":1,"87":1,"88":1,"90":1,"93":1,"99":1,"100":1,"101":1,"103":1,"104":1,"106":2,"107":1}}],["closure",{"2":{"144":1,"183":2,"195":1}}],["closureε−closure",{"2":{"113":4}}],["clone",{"2":{"114":1}}],["clousure",{"2":{"113":1}}],["cls",{"2":{"75":8}}],["cfg表示各代码块之间的关系",{"2":{"206":1}}],["cfg的主要特征在于它能够标识每个基本块的起点和终点",{"2":{"199":1}}],["cfg",{"2":{"130":1,"131":1,"149":1,"186":1,"206":8,"212":9}}],["cf",{"2":{"73":1}}],["ce",{"2":{"73":1}}],["centered",{"2":{"21":1}}],["cd",{"2":{"73":1,"114":2}}],["cdot",{"2":{"67":2,"75":2}}],["cdots",{"2":{"21":1}}],["chris",{"2":{"110":1}}],["change",{"2":{"68":1}}],["char>",{"2":{"100":1}}],["char",{"2":{"33":1,"73":1,"100":1,"162":1}}],["child",{"2":{"67":3}}],["c∈∑c",{"2":{"102":1,"115":1}}],["c∈",{"2":{"67":2}}],["c∈rm∗n",{"2":{"1":1}}],["c∈rm∗nc",{"2":{"1":1}}],["c++中的闭包特点",{"2":{"183":1}}],["c++上来给了一道代码题",{"2":{"39":1}}],["c++多态",{"2":{"37":1,"41":1}}],["c++新特性",{"2":{"33":1}}],["c=1",{"2":{"67":1}}],["c=0",{"2":{"29":1}}],["c=a∗bc=a",{"2":{"1":1}}],["customers",{"2":{"103":5}}],["cutlass",{"0":{"29":1}}],["current",{"2":{"229":2}}],["currow",{"2":{"16":7}}],["currow+indexn",{"2":{"11":1}}],["currow+indexa",{"2":{"11":1}}],["currow+",{"2":{"11":1}}],["currow=",{"2":{"11":1}}],["currow代表处理到哪一行",{"2":{"11":1}}],["curcol+indexm",{"2":{"11":2}}],["curcol代表处理到哪一列",{"2":{"11":1}}],["curcol",{"2":{"11":2,"16":3}}],["cuda优化和程序优化用过什么",{"2":{"37":1}}],["cuda了解多少",{"2":{"37":1}}],["cuda",{"0":{"4":1,"7":1,"11":1,"16":1}}],["c的数据已经读到了全局内存中",{"2":{"4":1}}],["cap",{"2":{"188":3}}],["callee",{"2":{"187":1}}],["caller",{"2":{"187":1}}],["call",{"2":{"180":1,"183":1}}],["canjump",{"2":{"107":1}}],["candidates",{"2":{"78":6}}],["ca",{"2":{"4":2,"115":4,"118":2,"150":1,"184":1}}],["cos",{"2":{"75":1}}],["com",{"2":{"114":1}}],["compiler",{"0":{"98":1},"2":{"97":1,"98":2}}],["computer",{"2":{"67":2}}],["commit",{"2":{"33":1}}],["count=1",{"2":{"67":1}}],["count",{"2":{"66":2}}],["cout",{"2":{"39":5,"41":1,"43":4,"183":1}}],["coinchange",{"2":{"58":1}}],["coins",{"2":{"58":10,"68":9}}],["cool",{"2":{"21":1}}],["cond",{"2":{"214":2}}],["conditionvarible",{"2":{"37":1}}],["control",{"2":{"131":1,"206":1}}],["context",{"2":{"130":1}}],["contains",{"2":{"100":1}}],["continuous",{"2":{"67":1}}],["concat",{"2":{"75":1}}],["conflicts",{"0":{"29":1},"2":{"19":1}}],["conflict",{"0":{"19":1},"2":{"16":1,"19":8,"29":5}}],["construction的执行过程大概如下",{"2":{"127":1}}],["construction和dfa",{"2":{"127":1}}],["construction进行构造的好处是仅一个接受状态",{"2":{"118":1}}],["construction",{"2":{"118":4,"127":2}}],["construction子集构造法",{"2":{"113":1}}],["constexpr",{"2":{"39":1}}],["const",{"2":{"16":7,"21":4}}],["core",{"2":{"4":2,"29":2}}],["core去执行",{"2":{"4":1}}],["colorpoint的方法向量包括了指向colorpoint",{"2":{"187":1}}],["colorpoint",{"2":{"187":1,"236":2}}],["column",{"2":{"29":2}}],["col",{"2":{"4":3,"7":4,"21":2}}],["c",{"2":{"1":5,"4":3,"7":6,"16":8,"21":1,"33":1,"58":7,"67":9,"68":7,"73":3,"75":1,"100":3,"102":10,"113":6,"115":5,"118":1,"123":2,"141":2,"143":1,"149":1,"150":1,"164":2,"166":3,"178":1,"186":1,"187":1,"194":2,"197":1,"203":1,"239":2}}],["node的类型是n1",{"2":{"221":1}}],["node",{"2":{"221":9}}],["november",{"2":{"215":1}}],["nordered",{"2":{"66":1}}],["nj",{"2":{"206":2}}],["ni",{"2":{"206":2}}],["ninja",{"2":{"114":3}}],["nlogn",{"2":{"141":2}}],["nlp",{"2":{"67":1}}],["nt→",{"2":{"131":1}}],["nt是非终结符的有限集合",{"2":{"131":1}}],["nt",{"2":{"131":2}}],["n≥0",{"2":{"131":4}}],["na",{"2":{"184":1}}],["na1​",{"2":{"167":1}}],["namelist",{"2":{"204":2}}],["namespace",{"2":{"183":1}}],["name",{"2":{"129":1,"139":2,"146":4,"163":1,"194":1,"204":4}}],["native",{"2":{"114":2}}],["nat",{"2":{"65":2}}],["nvptx",{"2":{"114":2}}],["nvidia",{"0":{"4":1,"7":1,"11":1,"16":1},"2":{"114":2}}],["nnn",{"2":{"113":3,"123":2,"141":1}}],["n7",{"2":{"113":1}}],["n8​",{"2":{"113":2}}],["n8",{"2":{"113":2}}],["n5",{"2":{"113":1}}],["n9",{"2":{"113":2}}],["n9​记作d2d",{"2":{"113":1}}],["n9​",{"2":{"113":3}}],["n9n",{"2":{"113":2}}],["n6n",{"2":{"113":1}}],["n6​记作d3d",{"2":{"113":1}}],["n6​",{"2":{"113":1}}],["n6",{"2":{"113":1}}],["n4​",{"2":{"113":3}}],["n4",{"2":{"113":3}}],["n3​",{"2":{"113":3}}],["n3",{"2":{"113":3}}],["n2​",{"2":{"113":1}}],["n2",{"2":{"113":1,"221":5}}],["n2n",{"2":{"112":1}}],["n1节点中的指针可以引用n1节点或n2节点",{"2":{"221":1}}],["n1",{"2":{"113":1,"221":5}}],["n1n",{"2":{"112":1}}],["n0n",{"2":{"112":2,"113":1}}],["nfa的构造",{"0":{"118":1}}],["nfa的初始状态的",{"2":{"113":1}}],["nfa的最小化",{"0":{"111":1},"1":{"115":1,"123":1,"141":1}}],["nfa并发地追踪所有路径",{"2":{"112":1}}],["nfa及其复制品处于某个状态集合中",{"2":{"112":1}}],["nfa会自我复制以追踪每一个可能的转换",{"2":{"112":1}}],["nfa在每个点上猜测正确的转换",{"2":{"112":1}}],["nfa引入了空边",{"2":{"112":1}}],["nfa和dfa的区别",{"2":{"112":1}}],["nfa",{"0":{"112":1},"2":{"112":1}}],["nfa到dfa的转换",{"0":{"109":1,"113":1},"1":{"113":1}}],["nx1​",{"2":{"102":1}}],["n>m",{"2":{"99":1}}],["n−1",{"2":{"88":3}}],["n​",{"2":{"75":1}}],["nsp",{"2":{"75":3}}],["n=customers",{"2":{"103":1}}],["n==0",{"2":{"73":1}}],["n=nums",{"2":{"69":1,"88":1}}],["num",{"2":{"163":1}}],["numberlntoreg",{"2":{"194":1}}],["numbers",{"2":{"183":5}}],["number",{"2":{"146":4}}],["nums之中任意元素的全部前缀元素和后缀的乘积都在",{"2":{"88":1}}],["numset",{"2":{"66":5}}],["numsnumsnums",{"2":{"66":4,"88":1}}],["nums",{"2":{"53":11,"64":7,"66":7,"69":6,"80":13,"87":12,"88":23,"90":10,"106":13,"107":6}}],["numtiles",{"2":{"7":2,"11":2}}],["nullptr",{"2":{"39":1}}],["n个链表翻转",{"2":{"33":1}}],["nextregister",{"2":{"194":1}}],["nextchar",{"2":{"102":4}}],["next",{"2":{"75":2,"229":5}}],["negative",{"2":{"67":1}}],["newptr",{"2":{"41":1}}],["new用的那个",{"2":{"33":1}}],["new",{"2":{"33":1,"102":1}}],["neat",{"2":{"21":1}}],["n+1",{"2":{"99":1}}],["n+currow+indexn",{"2":{"11":1}}],["n+curcol+indexb",{"2":{"11":1}}],["n+col",{"2":{"4":2,"7":1}}],["n+j",{"2":{"1":2}}],["n",{"2":{"1":4,"4":2,"7":5,"11":3,"16":14,"21":2,"23":1,"39":1,"41":1,"43":28,"53":7,"58":3,"63":8,"66":5,"67":10,"68":3,"69":2,"72":7,"73":2,"75":2,"76":4,"88":6,"90":3,"99":3,"102":4,"103":2,"106":5,"113":15,"123":6,"131":10,"139":5,"141":2,"150":2,"157":1,"164":5,"172":2,"183":6,"184":1,"206":4,"229":2,"231":1}}],["kai​→β1​∣β2​∣",{"2":{"167":1}}],["k−1k",{"2":{"127":1}}],["kleen",{"2":{"127":1}}],["kdi​",{"2":{"115":1}}],["kdk​到自身的任意路径相连接",{"2":{"127":1}}],["kdk​的路径",{"2":{"127":1}}],["kdk​",{"2":{"75":1,"127":4}}],["keykeykey",{"2":{"90":1}}],["kwik​",{"2":{"75":1}}],["kwik",{"2":{"75":1}}],["king",{"2":{"67":3}}],["kmins",{"2":{"63":1}}],["k=3",{"2":{"29":2}}],["k=2",{"2":{"29":2}}],["k=1",{"2":{"29":2}}],["k=0",{"2":{"29":2}}],["k=tid",{"2":{"16":3}}],["k++",{"2":{"16":1}}],["k+indexk+t",{"2":{"11":1}}],["k+t",{"2":{"7":1}}],["k+s",{"2":{"1":1,"4":1}}],["kkk",{"2":{"1":1,"67":1,"101":1,"127":1}}],["k",{"2":{"1":4,"4":2,"7":9,"11":4,"16":19,"23":2,"29":3,"63":9,"64":5,"75":11,"76":4,"90":10,"93":6,"101":7,"127":10,"137":3,"156":3,"167":1,"169":2}}],["mlir",{"2":{"114":1}}],["mlm",{"2":{"75":3}}],["mkdir",{"2":{"114":1}}],["mid",{"2":{"105":1}}],["minimization都在前面的章节中聊过了",{"2":{"127":1}}],["minimumrecolors",{"2":{"93":1}}],["minprices",{"2":{"104":1}}],["minutes",{"2":{"103":7}}],["mins",{"2":{"63":11}}],["minsminsmins",{"2":{"63":3}}],["min",{"2":{"43":3,"53":1,"58":2,"67":1,"104":4,"106":7}}],["mineed",{"2":{"29":2}}],["mycompare",{"2":{"84":2}}],["mysql",{"2":{"39":1}}],["mno",{"2":{"73":2}}],["m+n",{"2":{"46":1}}],["month",{"2":{"215":1}}],["monday",{"2":{"215":2}}],["mongodb",{"2":{"39":1}}],["move以及colorpoint",{"2":{"187":1}}],["move所有权",{"2":{"33":1}}],["model",{"2":{"67":2,"75":6,"143":3}}],["models",{"2":{"67":1}}],["mul",{"2":{"229":1}}],["multihead",{"2":{"75":3}}],["multi",{"2":{"75":1}}],["multiple",{"2":{"4":1}}],["must",{"2":{"98":2}}],["mu",{"2":{"75":2}}],["mutex>",{"2":{"41":1}}],["mutex",{"2":{"37":1,"41":3}}],["mpi是如何通信的",{"2":{"37":1}}],["mpi",{"2":{"37":1}}],["mem2reg",{"2":{"155":2}}],["memo",{"2":{"53":2}}],["memory",{"2":{"19":2,"23":7,"29":10,"143":2,"232":1}}],["meanss",{"2":{"137":1,"156":1}}],["means",{"2":{"137":2,"156":2}}],["meaning",{"2":{"98":1}}],["merge",{"2":{"33":1,"84":1}}],["mma",{"2":{"23":1}}],["m=tid",{"2":{"16":3}}],["m=n=k=1024m=n=k=1024m=n=k=1024",{"2":{"16":1}}],["may",{"2":{"215":1}}],["march",{"2":{"215":1}}],["markdown",{"0":{"3":1},"1":{"6":1,"10":1,"14":1,"18":1,"21":1}}],["ma→αa",{"2":{"184":1}}],["ma→αβ1​∣αβ2​∣",{"2":{"184":1}}],["machine",{"2":{"110":1}}],["macos",{"2":{"110":1}}],["masked",{"2":{"75":2}}],["man",{"2":{"67":3}}],["mapmapmap",{"2":{"90":2}}],["mapping",{"2":{"73":3}}],["map",{"2":{"65":1,"90":1,"139":2}}],["makeleaf",{"2":{"194":1}}],["makenode2",{"2":{"194":1}}],["make",{"2":{"63":1}}],["maxprofit",{"2":{"104":1}}],["maxsubarray",{"2":{"106":2}}],["maxsum=res",{"2":{"106":1}}],["maxsum=int",{"2":{"106":1}}],["maxsum",{"2":{"90":1,"106":2}}],["maxsatisfied",{"2":{"103":1}}],["maxslidingwindow",{"2":{"64":1}}],["max",{"2":{"50":2,"53":4,"58":3,"62":2,"74":2,"90":1,"100":1,"106":1,"107":1,"229":1}}],["malloc",{"2":{"33":1}}],["major",{"2":{"29":3}}],["main",{"2":{"21":1,"39":1,"41":1,"183":1}}],["matchnumber",{"2":{"134":1}}],["match",{"2":{"134":4}}],["mathcal",{"2":{"67":3}}],["mathbf",{"2":{"67":30,"75":13}}],["mathbb",{"2":{"1":3,"16":3}}],["mathrm",{"2":{"16":2,"102":1,"105":1,"164":9}}],["matrixkernel",{"2":{"4":1,"7":2,"11":1,"16":1}}],["matirixserial",{"2":{"1":1}}],["m",{"2":{"1":4,"4":2,"7":4,"11":3,"16":12,"23":1,"72":2,"90":6,"99":2,"106":4,"115":1,"150":2,"157":1,"164":7,"188":4}}],["^+nt→",{"2":{"131":1}}],["^n",{"2":{"131":4}}],["^2r1",{"2":{"127":1}}],["^0",{"2":{"103":3}}],["^o",{"2":{"75":1}}],["^c",{"2":{"67":1}}],["^krijk​",{"2":{"127":3}}],["^k",{"2":{"67":2}}],["^t",{"2":{"67":7,"75":1}}],["^60",{"2":{"41":1}}],["^3",{"2":{"29":2}}],["^1",{"2":{"29":2,"103":1}}],["^r",{"2":{"21":2}}],["^",{"2":{"1":3,"16":3,"21":2,"29":1,"67":2,"105":1,"106":4,"118":3,"127":9}}],["rarp​",{"2":{"194":1,"218":2}}],["rarpr",{"2":{"194":1,"218":2}}],["rarp",{"2":{"194":1}}],["ranges",{"2":{"53":1}}],["rand",{"2":{"41":1}}],["runtime",{"2":{"173":1}}],["rbp",{"2":{"155":1}}],["rsp",{"2":{"155":1}}],["rsrsrs",{"2":{"105":1}}],["rkkk−1​",{"2":{"127":1}}],["rkkk−1",{"2":{"127":1}}],["r1",{"2":{"127":1}}],["r128∗128",{"2":{"16":2}}],["r=ε∣b",{"2":{"119":2}}],["root需要在寄存器或局部数据区中有空间",{"2":{"210":1}}],["rocm",{"2":{"114":1}}],["row",{"2":{"4":4,"7":5,"29":2}}],["rtti=on",{"2":{"114":2}}],["r^",{"2":{"105":1}}],["r∗",{"2":{"105":2}}],["rrr",{"2":{"105":2}}],["rrbracket",{"2":{"67":1}}],["r∣sr|sr∣s",{"2":{"105":1}}],["rijk​←rikk−1​",{"2":{"127":1}}],["rijk←rikk−1",{"2":{"127":1}}],["rijk−1​",{"2":{"127":1}}],["rijk−1r",{"2":{"127":1}}],["rijkr",{"2":{"127":3}}],["rij−1​",{"2":{"127":2}}],["rij−1r",{"2":{"127":2}}],["ri​",{"2":{"21":1}}],["ri",{"2":{"21":1}}],["rightparenthesis",{"2":{"176":1}}],["rightmost",{"2":{"156":1}}],["rightarrow",{"2":{"127":1}}],["right+1",{"2":{"106":2}}],["right++",{"2":{"100":1}}],["right",{"2":{"21":4,"75":1,"100":4,"102":6,"106":6,"137":1,"156":1,"221":1,"230":2}}],["riωi",{"2":{"21":1}}],["r−i+1",{"2":{"21":2}}],["r+∑i=1r​ωi",{"2":{"21":1}}],["r+∑i=1r",{"2":{"21":1}}],["ret",{"2":{"225":1,"229":3,"232":1}}],["return",{"2":{"39":1,"43":4,"53":6,"58":7,"63":1,"64":1,"65":1,"66":1,"68":7,"69":2,"72":2,"73":4,"75":1,"80":1,"84":3,"87":2,"88":1,"90":2,"93":1,"99":2,"100":1,"101":1,"103":1,"104":1,"106":2,"107":3,"155":2,"183":4,"213":1}}],["records",{"0":{"236":1}}],["record",{"2":{"193":1}}],["recorded",{"2":{"100":4}}],["representation",{"2":{"187":1}}],["report",{"2":{"102":1}}],["reduces",{"2":{"195":1}}],["reduce",{"2":{"142":1}}],["redis",{"2":{"39":1}}],["reachable没有起到作用",{"2":{"123":1}}],["reachable",{"2":{"123":7}}],["realloc",{"2":{"33":1}}],["reverse",{"2":{"123":7,"156":1}}],["re到nfa",{"0":{"108":1},"1":{"112":1,"118":1}}],["removeduplicates",{"2":{"80":1,"87":1}}],["restrictions",{"0":{"239":1}}],["res+=n",{"2":{"106":1}}],["res=min",{"2":{"93":1}}],["res=max",{"2":{"66":1,"104":1}}],["res=0",{"2":{"66":1,"103":1,"104":1,"106":2}}],["res",{"2":{"43":11,"53":10,"58":7,"64":3,"65":3,"66":2,"68":6,"69":3,"72":3,"73":3,"84":7,"88":3,"90":5,"93":3,"99":5,"104":3,"106":2}}],["resultresultresult",{"2":{"63":3}}],["result",{"2":{"41":6,"63":4,"225":2,"229":5}}],["resolution",{"2":{"19":3}}],["rebase的区别",{"2":{"33":1}}],["region",{"2":{"175":1}}],["register的load过程避免bank",{"2":{"29":2}}],["register",{"2":{"23":4,"29":1,"143":2,"187":2}}],["reg",{"2":{"16":8}}],["r",{"2":{"1":3,"16":3,"21":1,"105":7,"106":3,"119":1,"127":3,"164":8}}],["bβ",{"2":{"179":1}}],["b→aab",{"2":{"167":4}}],["b→abb",{"2":{"167":1}}],["b→ab∣cb",{"2":{"167":2}}],["b→ab",{"2":{"147":1}}],["b→baa∣aa∣cb",{"2":{"167":1}}],["b→bcb",{"2":{"147":1}}],["bs",{"2":{"150":1}}],["bs→ab",{"2":{"147":3}}],["bsd",{"2":{"110":1}}],["b和c都是明确的标量值",{"2":{"143":1}}],["b但不会在解析树中编码任何优先级概念",{"2":{"129":1}}],["b的解析树有14个节点",{"2":{"129":1}}],["b|c",{"2":{"118":4}}],["b∣c",{"2":{"118":8,"141":2}}],["boo",{"2":{"209":1}}],["bool",{"2":{"84":1,"101":1,"107":1}}],["bottom",{"2":{"142":1}}],["bound",{"2":{"53":1}}],["bf",{"2":{"73":1}}],["bd",{"2":{"73":1}}],["betaα",{"2":{"131":1}}],["betaγ",{"2":{"75":1}}],["beta",{"2":{"75":1,"131":2,"150":8,"167":6,"184":6}}],["be",{"2":{"73":1}}],["begin",{"2":{"65":1,"66":1,"84":1,"164":2,"183":2,"190":1}}],["berttokenizer",{"2":{"75":2}}],["bertmodel",{"2":{"75":2}}],["bert可以参考这篇csdn博客",{"2":{"75":1}}],["bert模型",{"0":{"75":1}}],["bert",{"2":{"47":1,"67":2,"75":6}}],["br",{"2":{"176":24,"229":3}}],["branch",{"2":{"136":2}}],["brzozowski算法的实现几乎肯定会比hopcroft算法更简单",{"2":{"141":1}}],["brzozowski算法表现得相当不错",{"2":{"141":1}}],["brzozowski算法可能会因为子集构造过程中可能构建出呈指数级增长的状态集合而变得昂贵",{"2":{"141":1}}],["brzozowski",{"0":{"123":1},"2":{"123":1}}],["brief",{"2":{"58":1,"68":1}}],["broadcast",{"2":{"19":1}}],["bush",{"2":{"230":3}}],["build=",{"2":{"114":1}}],["build",{"2":{"114":6}}],["bucket",{"2":{"41":3}}],["buffering",{"2":{"124":1}}],["buffer",{"2":{"41":4}}],["binaryexpression",{"2":{"176":2}}],["bigcup",{"2":{"105":1}}],["bio吗",{"2":{"39":1}}],["bit",{"2":{"29":2}}],["b=",{"2":{"39":1,"188":2}}],["byte",{"2":{"19":1}}],["bytes",{"2":{"19":3}}],["basic",{"2":{"206":1}}],["based",{"2":{"137":1,"156":1}}],["base",{"2":{"75":2,"183":3}}],["baa",{"2":{"167":2}}],["baa→ba",{"2":{"167":1}}],["baaaa",{"2":{"150":3}}],["ba",{"2":{"99":1,"150":1,"167":5}}],["bac",{"2":{"99":1}}],["back",{"2":{"53":1,"63":3,"64":4,"65":2,"69":3,"72":3,"73":1,"84":5,"99":2}}],["bag",{"2":{"67":1}}],["bat",{"2":{"65":2}}],["badge",{"2":{"21":1}}],["bank示意图",{"2":{"19":1}}],["bank",{"0":{"29":1},"2":{"19":21,"29":4,"67":1}}],["barrier",{"2":{"23":1}}],["bar",{"0":{"15":1},"2":{"13":1,"17":1}}],["bk=block",{"2":{"16":1}}],["bk=bn",{"2":{"16":1}}],["bk=8",{"2":{"16":2}}],["bk=8blockdim=",{"2":{"16":2}}],["bk",{"2":{"11":14,"16":14}}],["bkbkbk则为内部循环k上面的分块",{"2":{"11":1}}],["bn+threadidx",{"2":{"11":1}}],["bn",{"2":{"11":5,"16":6}}],["bn=",{"2":{"11":1}}],["bn=block",{"2":{"11":3}}],["bnbm∗bn",{"2":{"11":1}}],["bm∗bk=bn∗bk=block",{"2":{"16":1}}],["bm∗bnbm",{"2":{"11":1}}],["bm",{"2":{"11":2,"16":3}}],["bm=block",{"2":{"11":2}}],["bbb有直接左递归",{"2":{"167":1}}],["bbbbb",{"2":{"100":1}}],["bbbbbbbwbw",{"2":{"93":1}}],["bbb",{"2":{"4":1,"7":3,"167":2,"188":1}}],["blocks",{"2":{"93":9}}],["block",{"2":{"7":2,"11":2,"16":5,"206":4}}],["blockdim=",{"2":{"16":2}}],["blockdim",{"2":{"4":2,"7":2,"11":2,"16":4}}],["blockidx",{"2":{"4":2,"7":2,"11":2,"16":2}}],["b∈rk∗n",{"2":{"1":1}}],["b∈rk∗na",{"2":{"1":1}}],["b",{"2":{"1":3,"4":3,"16":13,"21":2,"23":2,"33":1,"39":2,"46":1,"67":5,"73":1,"84":1,"93":2,"100":1,"114":2,"115":6,"118":3,"119":2,"123":1,"129":2,"141":2,"143":1,"147":6,"149":1,"152":1,"155":1,"162":1,"166":2,"167":5,"168":1,"169":1,"170":9,"178":1,"179":3,"184":1,"185":1,"186":2,"187":1,"188":2,"194":6,"197":1,"198":1,"210":1,"218":1,"225":2,"229":3,"239":1}}],["bc=a∗b",{"2":{"1":1}}]],"serializationVersion":2}';export{t as default};
