import{_ as i,c as a,e as s,o as t}from"./app-BChvZF5M.js";const n="/compiler/eac/scanners/doublebuf.png",r="/compiler/eac/scanners/conspress.png",c={};function l(o,e){return t(),a("div",null,[...e[0]||(e[0]=[s('<h3 id="扫描器的实现" tabindex="-1"><a class="header-anchor" href="#扫描器的实现"><span>扫描器的实现</span></a></h3><p>这里不想叙述书中所列举的，表驱动扫描器，直接编码扫描器，和手写扫描器的区别。说实话感觉不明显。</p><p>这里我想记录一下书中所说的扫描器实现的一些优化。</p><ol><li><p>Double buffering。即采用双重缓冲，有点类似于Ping-Pong缓存的想法。 <img src="'+n+'" alt="min_dfa" style="display:block;margin-left:auto;margin-right:auto;"> 具体实现的细节会有当前指针<code>input</code>，和缓冲区开始的指针<code>fence</code>。当扫描器回滚的时候，如果<code>input</code>回滚到<code>fence</code>就直接报错。下面直接看我实现的C++样例代码。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#24292eff;--shiki-dark:#eef0f9;--shiki-light-bg:#ffffff;--shiki-dark-bg:#17191e;"><pre class="shiki shiki-themes min-light houston vp-code"><code class="language-cpp"><span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>压缩状态表，其中可以使用基数排序的思想，对每一列非错误状态的数量技术的先进行分组，在逐个比较，避免了大量的比较操作。 <img src="'+r+'" alt="min_dfa" style="display:block;margin-left:auto;margin-right:auto;"></p></li></ol>',4)])])}const p=i(c,[["render",l]]),m=JSON.parse('{"path":"/compiler/rbwmrfsq/","title":"扫描器的实现","lang":"zh-CN","frontmatter":{"title":"扫描器的实现","createTime":"2024/12/28 16:40:12","permalink":"/compiler/rbwmrfsq/"},"readingTime":{"minutes":0.81,"words":243},"git":{"createdTime":1764058930000},"filePathRelative":"compiler/EaC/2.扫描器/6.扫描器的实现.md","headers":[]}');export{p as comp,m as data};
