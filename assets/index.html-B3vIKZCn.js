import{_ as a,c as r,a as e,o as l}from"./app-BChvZF5M.js";const n={};function i(o,t){return l(),r("div",null,[...t[0]||(t[0]=[e("p",null,"从根本上说，编译器是一个程序，它读取另一个程序，构建其含义的表示，以这种形式分析和改进代码，并翻译代码以便其能在某个目标机器上执行。翻译、分析、优化和代码生成需要对输入程序有深入的理解。语法驱动翻译的目的在于开始组装编译后续阶段所需的知識。",-1),e("p",null,"当编译器解析输入程序时，它构建代码的中间表示（IR）版本。它用发现的事实来注释这个IR，例如变量的类型和大小，以及推导出的事实，比如它可以将每个值存储在哪里。编译器使用两种机制来构建IR及其辅助数据结构：(1) 语法驱动翻译，一种嵌入到解析器中的计算形式，并由解析器的动作排序，以及 (2) 随后的IR遍历以执行更复杂的计算。",-1),e("p",null,"因此，编译器需要一个实现计划、命名空间的模型以及一种机制，用来将模型操作和中间表示（IR）生成与输入程序的结构和语法联系起来。为了完成这些任务：",-1),e("p",null,"编译器需要一种机制，将信息收集和IR构建过程与输入程序的语法结构和语义细节关联起来。 编译器需要理解代码中每个名称的可见性——也就是说，给定一个名称x，它必须知道x所绑定的实体。根据这种绑定，它需要有关x的完整类型信息和访问方法。 编译器需要为每个编程语言构造提供一个实现方案，从变量引用到case语句，从过程调用到堆分配。 本章专注于一种常用的机制，用于指定语法驱动的计算。编译器编写者规定在解析器通过特定产生式简化时应采取的动作。解析器生成器安排这些动作在解析过程中适当的点执行。编译器编写者使用这个机制来驱动基本的信息收集、IR生成以及比语法层次更深的错误检查（例如，语句是否引用了未声明的标识符？）。",-1)])])}const s=a(n,[["render",i]]),m=JSON.parse('{"path":"/compiler/qdwjf35y/","title":"介绍","lang":"zh-CN","frontmatter":{"title":"介绍","createTime":"2025/01/23 13:39:18","permalink":"/compiler/qdwjf35y/"},"readingTime":{"minutes":1.99,"words":597},"git":{"createdTime":1764058930000},"filePathRelative":"compiler/EaC/5.语法驱动翻译/1.介绍.md","headers":[]}');export{s as comp,m as data};
