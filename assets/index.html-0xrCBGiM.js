import{_ as r,c as e,a as o,o as n}from"./app-Qg1dpqDJ.js";const s={};function d(a,t){return n(),e("div",null,t[0]||(t[0]=[o('<p>这一节是书上没有对比的，个人疑问罢了。 解析树（Parse Tree）、语法树（Syntax Tree）和抽象语法树（Abstract Syntax Tree, AST）是编译器和解释器中常用的三种树形数据结构，它们在表示源代码语法结构时有不同的侧重点和用途。以下是它们的详细对比：</p><hr><h3 id="解析树、语法树和抽象语法树的对比" tabindex="-1"><a class="header-anchor" href="#解析树、语法树和抽象语法树的对比"><span><strong>解析树、语法树和抽象语法树的对比</strong></span></a></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>解析树（Parse Tree）</strong></th><th><strong>语法树（Syntax Tree）</strong></th><th><strong>抽象语法树（AST）</strong></th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>源代码语法结构的完整表示，严格遵循语法规则。</td><td>解析树的简化版本，保留较多语法细节。</td><td>语法树的进一步简化，只保留逻辑结构。</td></tr><tr><td><strong>节点内容</strong></td><td>包含所有非终结符和终结符（如语法规则、关键字、操作符等）。</td><td>包含非终结符和终结符，但比解析树更简洁。</td><td>只包含对程序逻辑重要的节点（如表达式、语句等）。</td></tr><tr><td><strong>语法细节</strong></td><td>包含所有语法细节（如括号、分号等）。</td><td>保留较多语法细节，但比解析树更简洁。</td><td>去除了不必要的语法细节（如括号、分号等）。</td></tr><tr><td><strong>抽象程度</strong></td><td>最低，最接近语法规则。</td><td>中等，介于解析树和AST之间。</td><td>最高，最接近程序的逻辑结构。</td></tr><tr><td><strong>用途</strong></td><td>用于语法分析，验证代码是否符合语法规则。</td><td>用于语法分析，是解析树的简化版本。</td><td>用于语义分析、代码优化和代码生成。</td></tr><tr><td><strong>示例（表达式 <code>3 + (4 * 5)</code>）</strong></td><td>完整表示语法规则，包含所有细节：<code>&lt;br&gt;Expression&lt;br&gt; ├── Term: 3&lt;br&gt; ├── Operator: +&lt;br&gt; └── Expression&lt;br&gt; ├── LeftParenthesis: (&lt;br&gt; ├── Term: 4&lt;br&gt; ├── Operator: *&lt;br&gt; ├── Term: 5&lt;br&gt; └── RightParenthesis: )&lt;br&gt;</code></td><td>简化了部分细节，但仍保留语法结构：<code>&lt;br&gt;Expression&lt;br&gt; ├── Term: 3&lt;br&gt; ├── Operator: +&lt;br&gt; └── Expression&lt;br&gt; ├── Term: 4&lt;br&gt; ├── Operator: *&lt;br&gt; └── Term: 5&lt;br&gt;</code></td><td>去除了所有冗余信息，只保留逻辑结构：<code>&lt;br&gt;BinaryExpression(operator: +)&lt;br&gt; ├── Literal(3)&lt;br&gt; └── BinaryExpression(operator: *)&lt;br&gt; ├── Literal(4)&lt;br&gt; └── Literal(5)&lt;br&gt;</code></td></tr></tbody></table><hr><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span><strong>总结</strong></span></a></h3><ol><li><strong>解析树</strong>：最详细的树结构，严格遵循语法规则，包含所有语法细节，用于语法分析。</li><li><strong>语法树</strong>：解析树的简化版本，保留了较多语法细节，但仍比解析树更简洁。</li><li><strong>抽象语法树（AST）</strong>：最简洁的树结构，去除了所有不必要的语法细节，只保留程序的逻辑结构，用于语义分析、优化和代码生成。</li></ol><p>在实际的编译器或解释器设计中，解析树通常作为语法分析的直接输出，语法树是解析树的简化版本，而AST则是后续阶段的主要数据结构。</p>',8)]))}const l=r(s,[["render",d]]),i=JSON.parse('{"path":"/compiler/9q1sjixf/","title":"各种树之间的区别","lang":"zh-CN","frontmatter":{"title":"各种树之间的区别","createTime":"2025/01/19 11:47:10","permalink":"/compiler/9q1sjixf/"},"readingTime":{"minutes":2.26,"words":677},"git":{"updatedTime":1737259052000,"contributors":[{"name":"TenOne506","username":"TenOne506","email":"w13852770506@163.com","commits":1,"avatar":"https://avatars.githubusercontent.com/TenOne506?v=4","url":"https://github.com/TenOne506"}],"changelog":[{"hash":"e0e13f270cd5e574121d5c0e1f72c9f9d8a1eb9a","time":1737259052000,"email":"w13852770506@163.com","author":"TenOne506","message":"中间代码结束"}]},"filePathRelative":"notes/compiler/EaC/4.中间代码表示/9.各种树之间的区别.md","headers":[]}');export{l as comp,i as data};
