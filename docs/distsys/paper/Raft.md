---
title: Raft
createTime: 2025/12/21 15:16:51
permalink: /distsys/huqj63jd/
---

Raft算法比Paxos更容易让人理解，也更简单。Paxos算法缺少标准的Multi-Paxos实践规范，不同团队直接实现差异大。
状态空间负责，容易引入bug。

而Raft算法，基于Paxos算法，在状态空间上进行了简化，只有一下三个状态，状态转移如图所示：

1. Follower
2. Candidate
3. Leader
![center](/distsys/raft/state.png){ style="display: block; margin-left: auto; margin-right: auto;" }

同时也只有三种RPC:

1. RequestVote：由候选者在选举期间发起
2. AppendEntries： 由领导者发起，用于复制日志条目，并兼作心跳机制
3. InstallSnapshot：用于在服务器之间传输快照

如果服务器未在合理时间内收到 RPC 的响应，它会进行重试；为了获得最佳性能，服务器还会并行地发起多个 RPC。

### 时间片划分

![center](/distsys/raft/terms.png){ style="display: block; margin-left: auto; margin-right: auto;" }
在 Raft 算法中，时间被划分为一系列逻辑上的任期（term），每个任期以一次选举开始：若选举成功，则由唯一选出的领导者管理集群直至该任期结束；若选举失败，则该任期在没有领导者的情况下直接结束。

由于网络延迟或分区等原因，不同服务器可能在不同时间感知到任期的切换，甚至可能完全错过某次选举或整个任期。为此，Raft 引入任期作为逻辑时钟，帮助服务器识别和处理过时的信息（如陈旧的领导者）。

每台服务器本地维护一个单调递增的当前任期号。当服务器之间通信时，会交换彼此的任期号：若发现自己的任期号小于对方，就立即更新为更大的值。相应地：

- 如果候选者或领导者发现自己任期已过时，会立即转为跟随者状态；
- 如果服务器收到任期号过期的请求，会直接拒绝该请求。

### Leader选举

Raft 采用心跳机制来追踪Leader的选举过程，使用空的AppendEntries RPC 来实现。如果一个Fllower在一个选举timeout之间没有收到联系，则会假设没有Leader，并开始新的选举。

开始选举，Fllower会再加自己自己的任期号，并且将状态转换为Candidate。并且会投自己一票，然后会发送一个 RequestVote RPC 给其他服务器，要求对当前任期进行投票。
上面的状态会一直持续，直到三件事的发生：

1. 票数过半，赢得选举
2. 其他服务器赢得选举
3. 在选举期间没有任何服务器赢得选举

Candidate 获得大多数的投票会赢得选举。每台服务器在任期内最多为一个Candidate投票。确保了统一任期内最多只有一个节点赢得选举。

其他服务器赢得选举，会发送一个AppendEntries RPC。这时候需要比较任期号，如果RPC中任期号大于本节点的任期号，则会认为是合法的，否则是不合法的。

如果没有任何服务器赢得选举，则会在超时之后增加自己的任期号，重新进行选举。为了避免这个分裂的情况重复发生，每个节点中超时时间的数值会在一定范围内随机选取
这样只有一个服务器会率先超时，最后会赢得选举，因为先超时了，先投自己一票，随后会发送RPC进行拉票。

论文里另一个讨论的点是采用排名系统来进行选举，高排名的服务器会赢得选举。然而，发现这种方法会引发一些微妙的可用性问题：例如，当一个高排名的服务器发生故障时，
低排名的服务器可能需要等待超时后再次成为候选者；但如果它过早地这样做，就可能打断正在进行的领导者选举进程，从而阻碍系统选出领导者。
论文中对这一算法进行了多次调整，但每次调整之后，又会出现新的边界情况（corner cases）。
最终，得出结论：基于随机重试的方案更加直观、易于理解，也避免了上述复杂性。

关于投票规则的细节，在后文阐述。

### 日志复制

一旦选举成功，就会开始处理客户端的请求。Leader会将命令追加到日志条目中