---
title: Raft
createTime: 2025/12/21 15:16:51
permalink: /distsys/huqj63jd/
---

Raft算法比Paxos更容易让人理解，也更简单。Paxos算法缺少标准的Multi-Paxos实践规范，不同团队直接实现差异大。
状态空间负责，容易引入bug。

而Raft算法，基于Paxos算法，在状态空间上进行了简化，只有一下三个状态，状态转移如图所示：

1. Follower
2. Candidate 
3. Leader
![center](/distsys/raft/state.png){ style="display: block; margin-left: auto; margin-right: auto;" }

同时也只有三种RPC:

1. RequestVote：由候选者在选举期间发起
2. AppendEntries： 由`Leader`发起，用于复制日志条目，并兼作心跳机制
3. InstallSnapshot：用于在服务器之间传输快照

如果服务器未在合理时间内收到 RPC 的响应，它会进行重试；为了获得最佳性能，服务器还会并行地发起多个 RPC。

### 时间片划分

![center](/distsys/raft/terms.png){ style="display: block; margin-left: auto; margin-right: auto;" }
在 Raft 算法中，时间被划分为一系列逻辑上的任期（term），每个任期以一次选举开始：若选举成功，则由唯一选出的`Leader`管理集群直至该任期结束；若选举失败，则该任期在没有`Leader`的情况下直接结束。

由于网络延迟或分区等原因，不同服务器可能在不同时间感知到任期的切换，甚至可能完全错过某次选举或整个任期。为此，Raft 引入任期作为逻辑时钟，帮助服务器识别和处理过时的信息（如陈旧的`Leader`）。

每台服务器本地维护一个单调递增的当前任期号。当服务器之间通信时，会交换彼此的任期号：若发现自己的任期号小于对方，就立即更新为更大的值。相应地：

- 如果候选者或`Leader`发现自己任期已过时，会立即转为`Follower`状态；
- 如果服务器收到任期号过期的请求，会直接拒绝该请求。

### Leader选举

Raft 采用心跳机制来追踪`Leader`的选举过程，使用空的AppendEntries RPC 来实现。如果一个`Follower`在一个选举timeout之间没有收到联系，则会假设没有`Leader`，并开始新的选举。

开始选举，`Follower`会再加自己自己的任期号，并且将状态转换为`Candidate`。并且会投自己一票，然后会发送一个 RequestVote RPC 给其他服务器，要求对当前任期进行投票。
上面的状态会一直持续，直到三件事的发生：

1. 票数过半，赢得选举
2. 其他服务器赢得选举
3. 在选举期间没有任何服务器赢得选举

`Candidate` 获得大多数的投票会赢得选举。每台服务器在任期内最多为一个`Candidate`投票。确保了统一任期内最多只有一个节点赢得选举。

其他服务器赢得选举，会发送一个AppendEntries RPC。这时候需要比较任期号，如果RPC中任期号大于本节点的任期号，则会认为是合法的，否则是不合法的。

如果没有任何服务器赢得选举，则会在超时之后增加自己的任期号，重新进行选举。为了避免这个分裂的情况重复发生，每个节点中超时时间的数值会在一定范围内随机选取
这样只有一个服务器会率先超时，最后会赢得选举，因为先超时了，先投自己一票，随后会发送RPC进行拉票。

论文里另一个讨论的点是采用排名系统来进行选举，高排名的服务器会赢得选举。然而，发现这种方法会引发一些微妙的可用性问题：例如，当一个高排名的服务器发生故障时，
低排名的服务器可能需要等待超时后再次成为候选者；但如果它过早地这样做，就可能打断正在进行的`Leader`选举进程，从而阻碍系统选出`Leader`。
论文中对这一算法进行了多次调整，但每次调整之后，又会出现新的边界情况（corner cases）。
最终，得出结论：基于随机重试的方案更加直观、易于理解，也避免了上述复杂性。

关于投票规则的细节，在后文阐述。

### 日志复制

一旦选举成功，就会开始处理客户端的请求。`Leader`会将命令追加到日志条目中，发起RPC AppendEntries 给其他服务器，并等待响应。超过半数的服务器复制成功，则会确认成功，在状态机中执行日志命令，相应客户端。

如果某些`Follower`发生崩溃、运行缓慢，或者网络数据包丢失，`Leader`会无限重试 AppendEntries RPC（即使在已经向客户端返回响应之后），直到所有`Follower`最终都成功存储了该日志条目。

只有已经提交（commit）的日志，可以被安全应用到状态机,大多数的服务器如果复制了该日志，则会认为已经提交了。
这一提交操作同时也会提交该`Leader`日志中所有先前的条目，包括由之前`Leader`创建的条目。

raft 保证了下面两条性质：

- 如果两个不同日志中的条目具有相同的索引（index）和任期号（term），那么它们所存储的命令是相同的。
- 如果两个不同日志中的条目具有相同的索引和任期号，那么这两个日志在该索引之前的所有条目都完全一致。

第一条是因为`Leader`在给定任期内对某个日志索引最多只会创建一个条目，并且日志条目在其日志中的位置永远不会改变。

第二条AppendEntries RPC执行的一个简单一致性检查来保证。当`Leader`发送 AppendEntries RPC 时，
会在请求中包含紧邻新条目之前那个日志条目的索引和任期号。
如果`Follower`在其本地日志中找不到具有相同索引和任期号的条目，它就会拒绝接收这些新条目

上面两条性质起到了归纳的作用，让`Leader`确信：`Follower`的日志在新增条目之前的部分与其自身日志完全一致。

但是还是存在一些特殊情况，一个`Follower`可能缺少`Leader`日志中已有的条目，也可能包含`Leader`日志中没有的额外条目，或者同时存在这两种情况。日志中的缺失条目和多余条目可能跨越多个任期。可以参考下面的图片和说明。

在 Raft 中，`Leader`通过强制让`Follower`的日志与自己的日志保持一致来处理不一致性。这意味着`Follower`日志中存在冲突的条目将被`Leader`日志中的条目覆盖。

`Leader`必须找到两个日志中最后一个一致的日志条目，然后删除`Follower`日志中该位置之后的所有条目，并将自己日志中该位置之后的所有条目发送给该`Follower`。

这些操作在RPC一致性检查之后生效。

`Leader`为每个`Follower`维护一个 `nextIndex` 值，表示下一次将要发送给该`Follower`的日志条目索引。当一个`Leader`刚当选时，它会将所有`Follower`的 `nextIndex` 初始化为其自身日志中最后一个条目之后的索引（例如上图 中为 11）。

如果`Follower`的日志与`Leader`的日志不一致，那么在下一次 AppendEntries RPC 中，一致性检查就会失败。
在收到拒绝响应后，`Leader`会将该`Follower`的 `nextIndex` 值减一，并重试 AppendEntries RPC。
如此反复，直到 `nextIndex` 递减到某个位置，使得`Leader`和`Follower`的日志在该位置之前完全一致。

之后删除`nextIndex`之后的日志条目，`Leader`把`nextIndex`之后的日志条目发送给`Follower`。