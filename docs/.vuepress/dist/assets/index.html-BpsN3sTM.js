import{_ as u,c as a,a as t,b as l,d as i,o as e}from"./app-D8Pywd0Q.js";const o="/compiler/eac/parsers/lr1cc0.png",s="/compiler/eac/parsers/lr1cc1.png",r="/compiler/eac/parsers/dfalr.png",p={};function c(m,n){return e(),a("div",null,n[0]||(n[0]=[t('<h3 id="lr解析算法" tabindex="-1"><a class="header-anchor" href="#lr解析算法"><span>LR解析算法</span></a></h3><p>LR解析算法的主要步骤包括：</p><ol><li><p>构建LR(1)项集族：</p><ul><li>计算闭包（closure）</li><li>计算转移（goto）</li><li>生成所有可能的项集</li></ul></li><li><p>构建解析表：</p><ul><li>ACTION表：决定移进、归约、接受或报错</li><li>GOTO表：记录状态转移</li></ul></li><li><p>解析过程：</p><ul><li>初始化状态栈和符号栈</li><li>根据当前状态和输入符号查找ACTION表</li><li>执行移进或归约操作</li><li>更新状态栈和符号栈</li><li>重复直到接受或报错</li></ul></li><li><p>错误处理：</p><ul><li>检测语法错误，尤其是可以定位错误</li><li>提供错误恢复机制</li><li>生成有意义的错误信息</li></ul></li></ol><h3 id="句柄-handle-的概念" tabindex="-1"><a class="header-anchor" href="#句柄-handle-的概念"><span>句柄（Handle）的概念</span></a></h3><p>在LR解析中，句柄是指一个产生式的右部，它出现在栈顶并且可以被归约。具体来说：</p><ol><li><p>定义：</p><ul><li>句柄是某个产生式右部的一个子串</li><li>该子串与产生式右部完全匹配</li><li>该子串出现在栈顶</li><li>可以通过归约操作将其替换为产生式左部的非终结符</li></ul></li><li><p>句柄的特征：</p><ul><li>总是出现在栈顶</li><li>是当前输入串的最左可归约子串</li><li>是语法分析过程中需要归约的最小单位</li></ul></li><li><p>句柄的识别：</p><ul><li>通过解析表的状态转移和归约动作来识别</li><li>当解析器处于某个状态时，如果ACTION表指示可以进行归约操作，则栈顶的相应符号序列就是句柄</li></ul></li><li><p>句柄的重要性：</p><ul><li>是LR解析算法正确性的关键</li><li>决定了何时进行归约操作</li><li>保证了语法分析的正确顺序</li></ul></li></ol><h3 id="详细计算步骤" tabindex="-1"><a class="header-anchor" href="#详细计算步骤"><span>详细计算步骤</span></a></h3><p>首先来几个要用的函数计算</p>',8),l("ol",null,[l("li",null,[l("p",null,"计算closure的步骤："),l("ul",null,[l("li",null,"对于每个项[A → α•Bβ, a]，其中B是非终结符"),l("li",null,"对于B的每个产生式B → γ"),l("li",null,"对于FIRST(βa)中的每个终结符b"),l("li",null,"添加项[B → •γ, b]到closure集合"),l("li",null,"重复直到没有新项可以添加")])]),l("li",null,[l("p",null,"计算goto的步骤："),l("ul",null,[l("li",null,"对于给定项集I和符号X"),l("li",null,"创建新项集J = {}"),l("li",null,"对于I中的每个项[A → α•Xβ, a]"),l("li",null,"添加项[A → αX•β, a]到J"),l("li",null,"返回closure(J)")])]),l("li",null,[l("p",null,"构建ACTION表的步骤："),l("ul",null,[l("li",null,"对于每个项集Ii"),l("li",null,[i("对于每个项[A → α•aβ, b]，其中a是终结符 "),l("ul",null,[l("li",null,"如果goto(Ii, a) = Ij"),l("li",null,'设置ACTION[i, a] = "移进 j"')])]),l("li",null,[i("对于每个项[A → α•, a] "),l("ul",null,[l("li",null,'设置ACTION[i, a] = "归约 A \\→ α"')])]),l("li",null,[i("对于包含[S' → S•, eof]的项集 "),l("ul",null,[l("li",null,'设置ACTION[i, eof] = "接受"')])])])]),l("li",null,[l("p",null,"构建GOTO表的步骤："),l("ul",null,[l("li",null,"对于每个项集Ii"),l("li",null,"对于每个非终结符A"),l("li",null,"如果goto(Ii, A) = Ij"),l("li",null,"设置GOTO[i, A] = j")])]),l("li",null,[l("p",null,"解析过程的步骤："),l("ul",null,[l("li",null,[i("初始化： "),l("ul",null,[l("li",null,"输入符号栈 = eof"),l("li",{0:""},"状态栈 ="),l("li",null,"输入符号 = 第一个输入符号")])]),l("li",null,[i("循环直到接受或报错： "),l("ul",null,[l("li",null,[i('如果ACTION[top(state stack), input symbol] = "移进 j" '),l("ul",null,[l("li",null,"将input symbol压入输入符号栈")])])])])])])],-1),l("h3",{id:"示例-构建括号列表文法的lr-1-解析表",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#示例-构建括号列表文法的lr-1-解析表"},[l("span",null,"示例：构建括号列表文法的LR(1)解析表")])],-1),l("p",null,"给定文法：",-1),l("ol",null,[l("li",null,"Goal → List"),l("li",null,"List → List Pair"),l("li",null,"List → Pair"),l("li",null,"Pair → ( List )"),l("li",null,"Pair → ( )")],-1),l("p",null,"构建过程：",-1),l("ol",null,[l("li",null,[l("p",null,"计算LR(1)项集族："),l("ul",null,[l("li",null,[i("I0 = closure([S' → \\•Goal, eof]) "),l("img",{src:o,alt:"lr1",style:{display:"block","margin-left":"auto","margin-right":"auto"}})]),l("li",null,"I1 = goto(I0, Goal)"),l("li",null,"I2 = goto(I0, List)"),l("li",null,"I3 = goto(I0, Pair)"),l("li",null,'I4 = goto(I0, "1")'),l("li",null,[i("...（继续计算所有项集） 所有的项集如下:"),l("img",{src:s,alt:"lrn",style:{display:"block","margin-left":"auto","margin-right":"auto"}})])])]),l("li",null,[l("p",null,"构建ACTION表和GOTO表："),l("p",null,"构建表的详细计算步骤如下，这里不展开了。")]),l("li",null,[l("p",null,'解析过程示例： 输入："( ( ) )" 解析步骤：'),l("ol",null,[l("li",null,[i("初始化： "),l("ul",null,[l("li",null,"输入符号栈 = eof"),l("li",{0:""},"状态栈 ="),l("li",null,"输入符号 = 第一个输入符号")])]),l("li",null,[i("循环直到接受或报错： "),l("ul",null,[l("li",null,[i('如果ACTION[top(state stack), input symbol] = "移进 j" '),l("ul",null,[l("li",null,"将input symbol压入输入符号栈"),l("li",null,"将状态j压入状态栈"),l("li",null,"读取下一个输入符号")])]),l("li",null,[i('如果ACTION[top(state stack), input symbol] = "归约 A → β" '),l("ul",null,[l("li",null,"从栈中弹出|β|个符号"),l("li",null,"将A压入输入符号栈"),l("li",null,"将GOTO[top(state stack), A]压入状态栈")])]),l("li",null,[i('如果ACTION[top(state stack), input symbol] = "接受" '),l("ul",null,[l("li",null,"解析成功，返回")])]),l("li",null,[i("如果ACTION[top(state stack), input symbol] = 空 "),l("ul",null,[l("li",null,"报错，返回错误信息")])])])]),l("li",null,[i("具体步骤： "),l("ul",null,[l("li",null,"移进 '('"),l("li",null,"移进 '('"),l("li",null,"移进 ')', 归约 Pair → ( )"),l("li",null,"移进 ')', 归约 List → Pair"),l("li",null,"归约 Pair → ( List )"),l("li",null,"归约 List → List Pair"),l("li",null,"归约 Goal → List"),l("li",null,"接受")])])])])],-1),l("p",null,"LR(1)解析器的效率来源于嵌入在Action和Goto表中的快速句柄查找机制。规范集合CC代表了文法的句柄查找有穷状态自动机（DFA）",-1),l("p",null,[l("img",{src:r,alt:"dfalr",style:{display:"block","margin-left":"auto","margin-right":"auto"}})],-1),l("p",null,"当LR(1)解析器执行时，它交错进行两种类型的动作：移进（shifts）和规约（reduces）。移进动作模拟了句柄查找DFA中的步骤。随着解析器将输入流中的每个单词移进解析栈，它也根据单词的语法类别改变DFA中的状态。规约动作发生在DFA到达一个终态时。此时，解析器弹出句柄及其DFA状态，以揭示开始寻找当前句柄之前DFA的状态。该状态位于栈中句柄左端之下。",-1)]))}const A=u(p,[["render",c],["__file","index.html.vue"]]),I=JSON.parse('{"path":"/compiler/fbf7a362/","title":"构造LR(1)解析表","lang":"zh-CN","frontmatter":{"title":"构造LR(1)解析表","createTime":"2025/01/11 20:53:43","permalink":"/compiler/fbf7a362/"},"headers":[],"readingTime":{"minutes":4.39,"words":1316},"git":{},"filePathRelative":"notes/compiler/EaC/3.解析器/5.构造LR(1)解析表.md","bulletin":false}');export{A as comp,I as data};
