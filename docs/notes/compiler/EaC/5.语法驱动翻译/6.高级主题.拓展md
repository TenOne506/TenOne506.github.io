---
title: 高级主题拓展
createTime: 2025/01/23 22:59:53
permalink: /compiler/41ytdjwp/
---

### 文法结构与结合性

给定输入表达式 a + b + c + d + e，这两种文法会导致显著不同的抽象语法树（AST），如页边所示。使用极限值时，这些树可以评估出明显不同的结果。

![picture6.2.2](/compiler/eac/sdt/last.png)
![picture6.2.2](/compiler/eac/sdt/rast.png)

来自左递归文法的 AST 的后序遍历将评估为 (((a + b) + c) + d) + e，而右递归版本将评估为 (((d + e) + c) + b) + a。对于加法运算，它既是交换律又是结合律的，这些求和之间的数值差异只有在极其大或极小的值的情况下才会出现。

在 LL(1) 解析器生成器中，其中左递归不是一个选项，编译器编写者可以通过编写左递归文法并使用转换将其转换为右递归来获得左结合性。而在 LR(1) 解析器生成器中，编译器编写者可以根据情况选择左递归或右递归。

一般来说，左递归可以导致更小的堆栈深度。考虑一下当一个 LR(1) 解析器使用我们前面展示的每种文法处理表达式 a + b + c + d + e 时会发生什么。

1. 左递归文法 这个文法会将 a 移入堆栈并立即简化为 Expr。接着，它会将 + 和 b 移入堆栈，并简化 Expr + b 为 Expr。它继续操作，移入一个 + 和一个名称到堆栈上，并简化左边的上下文为 Expr。当它到达字符串末尾时，最大堆栈深度为三，平均深度为 1.8。
2. 右递归文法 这个文法首先会将所有的标记移入堆栈 (a, +, b, +, c, +, d, +, e)。然后它使用第二条规则将 e 简化为 Expr。接下来它执行一系列四个简化操作，使用第一条产生式：d + Expr 简化为 Expr, c + Expr 简化为 Expr, b + Expr 简化为 Expr, 和 a + Expr 简化为 Expr。当它完成时，最大堆栈深度为九，平均堆栈深度为 4.8。

### 类型推断中的更难问题

强类型、静态检查的语言能够通过检测一大类错误程序来帮助程序员编写有效的程序。这些用于暴露错误的特性可以提高编译器为程序生成高效代码的能力，具体是通过（1）消除运行时检查或（2）揭示编译器可以针对某些结构进行代码特化的情况，以消除在运行时不会发生的情形。这些优势部分解释了类型系统在编程语言中日益增长的重要性。

然而，我们的例子所作的假设并不适用于所有编程语言。例如，我们假设变量和过程是声明过的——程序员为每个名称编写一个简明且具有约束力的说明。改变这些假设可能会从根本上改变类型检查问题的本质以及编译器实现语言策略的方法。

### 缓存性能

缓存存储器的广泛应用对内存中变量的布局有着微妙的影响。如果两个值在代码中被接近地使用，编译器希望确保它们能够同时存在于缓存中。这可以通过两种方式实现。在最理想的情况下，这两个值可以共享一个单一的缓存块，以保证这些值总是能一起被加载到缓存中。如果它们不能共享一个缓存块，编译器则希望确保这两个变量映射到不同的缓存行。编译器可以通过控制它们地址之间的距离来达到这个目的。

如果我们只考虑两个变量，控制它们之间的距离似乎是可管理的。然而，当考虑到所有活跃的变量时，为了缓存而进行最优排列的问题就变成了NP完全问题。大多数变量与其他许多变量都有交互；这就形成了一个编译器可能无法同时满足的关系网。如果我们考虑一个使用多个大型数组的循环，安排相互不干扰的问题将变得更加复杂。如果编译器能够发现循环中各种数组引用之间的关系，它可以在数组之间添加填充以增加引用命中不同缓存行的可能性，从而不互相干扰。

程序的虚拟地址空间映射到硬件的物理地址空间时，并不需要保持特定变量之间的距离。将这一想法延伸下去，读者应该会问，在相对偏移量大于虚拟内存页面大小的情况下，编译器如何能保证任何事情。处理器的缓存可以在其标签字段中使用虚拟地址或物理地址。使用虚拟地址的缓存保持了虚拟空间中值之间的距离；编译器可以强制大型对象之间不互相干扰。对于使用物理地址的缓存，不同页面中两个位置之间的距离由页面映射决定（除非缓存大小≤页面大小）。

因此，除了在同一页面内的情况外，编译器关于内存布局的决策几乎没有影响。在这种情况下，编译器应专注于将一起引用的对象放置在相同的页面中，如果可能的话，放置在相同的缓存行中。

### 总结

编译的真实工作是翻译：将源语言中的结构映射到目标机器上的操作。编译器的前端构建程序的初始模型：一个中间表示（IR）和一组辅助结构。本章探讨了语法驱动的翻译，这是一种机制，它允许编译器编写者指定在前端识别特定语法结构时要执行的动作。编译器编写者将这些动作与语法规则关联起来；当编译器识别出该规则时就会执行它们。

形式化技术已经自动化了扫描器和解析器构造的大部分工作。在翻译过程中，大多数编译器依赖于语法驱动翻译的即兴技术。虽然研究人员已经开发出了更形式化的技术，比如属性文法系统，但这些系统尚未被广泛采用。语法驱动的技术在很大程度上是即兴的；编译器编写者需要一些实践才能有效地使用它们。本章捕捉到了一些这样的经验。

为了进行翻译，编译器必须建立比语法更深的知识基础。它必须使用语言的类型系统来推断程序计算的每个值的类型，并利用这些信息来驱动错误检测和自动类型转换。最后，编译器必须为它看到的代码计算一个存储布局；这个存储布局必须与其他相关代码的编译结果保持一致和兼容。
