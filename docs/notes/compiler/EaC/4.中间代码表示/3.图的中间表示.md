---
title: 图的中间表示
createTime: 2025/01/14 13:48:59
permalink: /compiler/wnftm2lf/
---

## 图形化的中间表示（Graphical IRs）

许多编译器使用将底层代码表示为图的IR。虽然所有的图形化IR都由节点和边组成，但它们在抽象层次、图与底层代码之间的关系以及图的结构上有所不同。

解析树、抽象语法树（ASTs）和有向无环图（DAGs）都是用来表示代码的图。这些树状的中间表示（IRs）具有与源代码语法相对应的结构。

### 解析树

解析树是输入程序推导过程或解析过程的图形化表示。下图展示了经典的表达式语法规则以及表达式 a * x + 2 * x * b 的解析树。解析树相对于源文本来说较大，因为它表示了完整的推导过程，推导中的每个语法符号都有一个对应的节点。由于编译器必须为每个节点和每条边分配内存，并且在编译期间必须遍历所有这些节点和边，因此考虑缩小这棵解析树的方法是有价值的。

![picture4.2](/compiler/eac/IR/parsetree.png){ style="display: block; margin-left: auto; margin-right: auto;" }

解析树主要用在关于解析的讨论中，以及属性文法系统中，在这些地方它们是权威的中间表示（IR）。在大多数其他需要源代码级别树结构的应用中，编译器编写者倾向于使用更加简洁的替代方案，比如抽象语法树（AST）或有向无环图（DAG）。

### 抽象语法树（Abstract Syntax Tree, AST）

抽象语法树（AST）保留了解析树的结构和含义，但消除了冗余的节点。它去掉了表示推导细节的非终结符号节点。一个表达式 a x 2 + a x 2 x b 的AST展示在下面。

![picture4.2](/compiler/eac/IR/AST.png){ style="display: block; margin-left: auto; margin-right: auto;"}

### 有向无环图（Directed Acyclic Graph）

虽然抽象语法树（AST）比解析树更为简洁，但它忠实地保留了源代码的结构。例如，表达式 a \*x^2 + a*x^2*b 的AST中包含两个不同的 a * x^2 表达式的副本。有向无环图（DAG）是AST的一种压缩形式，它避免了这种重复。在DAG中，节点可以有多个父节点，并且相同的子树会被复用。这样的共享机制使得DAG比相应的AST更加紧凑。

对于没有赋值或函数调用的表达式，文本上相同的表达式必须产生相同的值。a \*x^2 + a\* x^2 \*b 的DAG，如边栏所示，通过共享单一的 a\*x^2 实例反映了这一事实。如果a的值在这两个使用位置之间不会发生变化，那么编译器应该生成代码来只计算一次 a\* x^2 并两次使用该结果。这种策略可以降低求值成本。DAG明确地编码了子表达式之间的冗余性。如果编译器在中间表示（IR）中表示此类事实，它可以避免重新发现它们的成本。
![picture4.2](/compiler/eac/IR/dag.png){ style="display: block; margin-left: auto; margin-right: auto;"}
在为这个表达式构建 DAG 时，编译器必须证明 'a' 的值在其被使用之间不能发生变化。如果表达式既不包含赋值也不包含对其他程序的调用，那么这个证明就很容易完成。由于赋值或程序调用可以改变与名称关联的值，DAG 构建算法必须在操作数的值可能发生改变时使子树失效。

如果内存限制制约了编译器能够处理的程序大小，那么使用 DAG 作为权威的中间表示（IR）可以减少 IR 的内存占用。其他系统使用 DAG 来揭示冗余。在这种情况下，好处在于生成更优质的编译代码。这些后者系统倾向于将 DAG 用作派生的中间表示——构建 DAG，转换权威的 IR 以反映冗余，并丢弃 DAG。这里的“揭示冗余”指的是通过分析程序的DAG表示来识别出程序中的重复计算或不必要的操作。

### 控制流图

控制流图（Control Flow Graph，CFG）是表示程序控制流结构的图形化中间表示。从数学上看，一个控制流图可以表示为一个有向图 G = (N,E)，其中：

- N 是节点集合，每个节点 n ∈ N 对应一个基本块
- E 是边集合，每条边 e = (ni,nj) ∈ E 表示从基本块 ni 到 nj 的可能控制流转移

控制流图由基本块（Basic Block）和边组成，其中：

1. 基本块是连续执行的指令序列，只有一个入口点和一个出口点
2. 边表示控制流的转移，通常对应条件跳转、无条件跳转或函数调用

控制流图的主要特点包括：

- 每个节点代表一个基本块
- 边表示可能的控制流转移
- 有向边表示执行顺序
- 通常包含一个入口节点和一个出口节点

控制流图在编译器中有多种重要用途：

1. 数据流分析：用于变量定义和使用分析
2. 优化：识别死代码、循环优化等
3. 调试：可视化程序执行路径
4. 测试：生成测试用例覆盖不同路径

构建控制流图的基本步骤：

1. 将代码划分为基本块
2. 确定基本块之间的控制流关系
3. 添加边表示控制流转移
4. 优化和简化控制流图

控制流图与其他图形化IR的关系：

- 比AST更关注控制流而非语法结构
- 比DAG更适合表示程序流程而非表达式计算
- 常用于优化阶段，与数据流图配合使用

示例控制流图：

```c
      [Entry]
        |
        v
      [Block 1]-----
        |          |
        v          |
      [Block 2]    |
        |          |
        v          |
      [Block 3]-----
        |
        v
      [Exit]
```

LLVM IR 控制流图示例：

```llvm
define i32 @example(i32 %a, i32 %b) {
entry:
  %cmp = icmp sgt i32 %a, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:
  %add = add nsw i32 %a, %b
  br label %if.end

if.else:
  %sub = sub nsw i32 %a, %b
  br label %if.end

if.end:
  %result = phi i32 [ %add, %if.then ], [ %sub, %if.else ]
  ret i32 %result
}
```

对应的控制流图结构：

```c
      [entry]
        |
        v
  +-----+-----+
  |           |
  v           v
[if.then]  [if.else]
  |           |
  +-----+-----+
        |
        v
     [if.end]
```

